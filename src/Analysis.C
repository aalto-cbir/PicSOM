// -*- C++ -*-  $Id: Analysis.C,v 2.1232 2018/12/16 08:26:23 jormal Exp $
// 
// Copyright 1998-2018 PicSOM Development Group <picsom@ics.aalto.fi>
// Aalto University School of Science
// PO Box 15400, FI-00076 Aalto, FINLAND
// 

#include <Analysis.h>

#if defined(HAVE_OPENCV2_CORE_CUDA_HPP)
#include <opencv2/core/cuda.hpp>
#endif // HAVE_OPENCV2_CORE_CUDA_HPP
#ifdef HAVE_OPENCV2_CORE_GPUMAT_HPP
#include <opencv2/core/gpumat.hpp>
#endif // HAVE_OPENCV2_CORE_GPUMAT_HPP

//#define USE_ELM

#ifdef USE_GVT
#include <CbirGVT.h>
#endif // USE_GVT

#include <SVM.h>

#ifdef USE_ELM
#include <Elm.h>
#endif // USE_ELM

#ifdef HAVE_WNSIM_H
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wreturn-type"
//#undef __DEPRECATED
#include <WNSim.h>
#pragma GCC diagnostic pop
#endif // HAVE_WNSIM_H

#ifdef HAVE_JAULA_H
#include <jaula.h>
#endif // HAVE_JAULA_H

#include <SubSpace.h>
#include <FigFile.h>
#include <Histogram.h>
#include <RandVar.h>
#include <StatVar.h>
#include <Matrix.h>
#include <base64.h>

#include <videofile.h>
#include <textfile.h>

#include <cox/stat>
#include <cox/subspace>
#include <cox/matlab>
#include <cox/lsc>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif // HAVE_UNISTD_H

#ifdef HAVE_WN_H
#include <wn.h>
//static string foo = string(license)+string(dblicense);
#endif // HAVE_WN_H

#if defined(HAVE_THC_H) && defined(PICSOM_USE_TORCH)
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
#include <luaT.h>
}
#include <THDiskFile.h>
#endif // HAVE_THC_H && PICSOM_USE_TORCH

// #include <klt.h>

#include <unordered_map>

#include <WordHist.h>

#ifdef PICSOM_USE_TENSORFLOW
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wignored-qualifiers"
#undef LOG
#undef VLOG
#undef VLOG_IS_ON
#undef CHECK
#undef CHECK_NE
#undef CHECK_NL
#undef CHECK_LE
#undef CHECK_EQ
#undef CHECK_OP
#undef CHECK_OP_LOG
#undef CHECK_LT
#undef CHECK_GT
#undef CHECK_GE
#undef CHECK_NOTNULL
#define PROTOBUF_DEPRECATED_ATTR
#define EIGEN_HAS_CUDA_FP16
#include <tensorflow/core/public/version.h>
#include <tensorflow/core/public/session.h>
#include <tensorflow/core/platform/env.h>
#pragma GCC diagnostic pop
#endif // PICSOM_USE_TENSORFLOW

#ifdef PICSOM_USE_PYTHON
#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#include <Python.h>
#endif // PICSOM_USE_PYTHON

#if defined(HAVE_CAFFE2_CORE_MACROS_H) && defined(PICSOM_USE_CAFFE2)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#include <caffe2/core/workspace.h>
#include <caffe2/core/tensor.h>
#include <caffe2/utils/proto_utils.h>
#pragma GCC diagnostic pop
    CAFFE2_DEFINE_string(init_net, "init_net.pb",
			 "The given path to the init protobuffer.");
    CAFFE2_DEFINE_string(predict_net, "predict_net.pb",
			 "The given path to the predict protobuffer.");

#endif // HAVE_CAFFE2_CORE_MACROS_H && PICSOM_USE_CAFFE2

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

namespace picsom {
  static const string Analysis_C_vcid =
    "@(#)$Id: Analysis.C,v 2.1232 2018/12/16 08:26:23 jormal Exp $";

  /////////////////////////////////////////////////////////////////////////////

  int  Analysis::use_pthreads        = 0;
  bool Analysis::use_pthreads_insert = false;
  bool Analysis::debug_script        = false;
  double Analysis::gaussian_kernel_d = 8;

  /////////////////////////////////////////////////////////////////////////////

  Analysis::Analysis(PicSOM *p, const Analysis *par, Query *q,
                     const vector<string>& args) {
    picsom    = p;
    parent    = par;
    query     = q;
    query_own = !q;

    dummy_db = new DataBase(p, "");
    dummy_tssom = new TSSOM(dummy_db, "", "");

    static ofstream dummy;
    aout = Picsom()->Quiet() ? &dummy : &cout;

    HasCin(Picsom()->HasCin());

    verbose = 1;
    units = 0;
    randproj = 0;
    columns = 0;
    concatfeat = "";
    fillorigins = stripvectors = meandist = lbg = ord = false;
    combineorphans = removecreated = updatediv = false;
    batchtrain = zipped = labelsonly = writedata = addlabels = false;
    divxml = false;
    multirescorrect = false;
    avgquanterror = false;
    neighkernel = 0;
    radiusbase = 1.0;
    saveumatrix = true;
    skipobjectlists = false;
    libsvmdump = false;
    elanoverwrite = elanconvert= false;
    keeptmp = tolerate_missing_features = reextract_zero_vectors = false;
    force = false;
    use_textindex = true;

    slave_features_missing = slave_features_requested
      = slave_features_stored = slave_objectinfos_stored
      = slave_detections_stored = slave_captions_stored = 0;

    check_first_feature_only = true;

    // either with create or insert:
    extractmedia = extractfeatures = dodetections = dosegments = false;
    recalculatefeatures = false;

    level = rounds = classrounds = firstforcedidx = -1;
    forcehit = convolved = logarithm = forkdisplay = false;
    usebias = true;
    threshold = 0;
    summarylength = 0.02;
    summarycliplength = 2.0;
    magnify = 1;
    histbins = 0;
    dryrun = false;
    truncate = false;
    recursive = false;
    insertcount = -1;
    count_inserted = 0;
    skipexisting = "";
    skipnonexistent = false;
    expand = true; // for now only...
    keeporder = false;
    dirplot = unseenzero = false;
    featextbatchsize = -100;
    hard_negative_mining = 0;
    
    clicks_min = 0;
    clicks_max = numeric_limits<size_t>::max();

    htmlfile_linkimages = 0;

    bgcolor = 1.0;
    alpha = beta = 0.0;

    trecvid_noexamples = trecvid_useaspects = false;
    trecvid_noprogressbar = false;

    imagenet_normalize = imagenet_specialpre = "";
    imagenet_func = "prod";
    imagenet_inputprefix = "svm";
    imagenet_rootclass = "n01317541";
    imagenet_allcl = "-allcl";

    prfrounds  = 0;
    prfobjects = 20;

    vcd_overlaps = "5";
    vcd_fusionmethod = "concat";
    vcd_argstart = vcd_argstop = -1;

    classmargin = 0.0;

    segments = 0;
    distcomp = 0;
    compress = 0;
    ntop     = 1;

    bestall      = 10;
    bestpositive = 10;
    bestother    = 10;
    resultcount  = 0;
    forcedonly = false;

    scoredumponly = false;

    xhtml = NULL;

    relaxcounttest = false;
    skipresults    = false;

    store_matrices = parent ? parent->StoreMatrices() : false;

    optimize_expand_line = true;

#ifdef USE_MRML
    mrml_connection = NULL;
#endif // USE_MRML

    rest_argv_str = args;

    // default values for shot boundary determination:
    sbdparams.votepercent = 0.6;
    sbdparams.framegap = 6;
    sbdparams.mindist = 11;
    sbdparams.gtfile = "";
    sbdparams.gradualoptpercent=0.5;
    sbdparams.precision_weight=0.5;
    sbdparams.nframes = 8;
    sbdparams.nframes_next = 8;

    // step sizes for optimal parameter combination search:
    sbdparams.stepsize.push_back(0.1); // votepercent
    sbdparams.stepsize.push_back(1.0); // framegap
    sbdparams.stepsize.push_back(1.0); // mindist
    sbdparams.stepsize.push_back(1.0); // nframes
    sbdparams.stepsize.push_back(1.0); // nframes_next
    sbdparams.stepsize.push_back(0.5); // boundaryexp
    sbdparams.stepsize.push_back(0.5); // feature_weight

    if (!ProcessArguments(rest_argv_str))
      ShowError("Analysis::Analysis() : failed in ProcessArguments()");
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::~Analysis() {
    if (query && query->GetAnalysis()==this)
      query->SetAnalysis(NULL);

    DeleteQuery();

    xml_result.DeleteDoc();

    if (xhtml)
      xmlFreeNode(xhtml);

    delete dummy_tssom;
    delete dummy_db;

#ifdef PICSOM_USE_PTHREADS
    if (Picsom()->DebugThreads())
      ShowThreadDataInfo();
#endif // PICSOM_USE_PTHREADS
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::Dump(Simple::DumpMode dt, ostream& os) const {
    os << Simple::Bold("Analysis ")    << (void*)this
       << " xhtml="            << (void*)xhtml
       << " verbose="          << verbose
       << " treesomstruct="    << Simple::ShowString(treesomstruct)
       << " units="            << units
       << " stripvectors="     << stripvectors
       << " extractfeatures="  << extractfeatures
       << " combineorphans="   << combineorphans
       << " removecreated="    << removecreated
       << " updatediv="        << updatediv
       << " meandist="         << meandist
       << " lbg="              << lbg
       << " ord="              << ord
       << " batchtrain="       << batchtrain
       << " batchtrainperiod=" << Simple::ShowString(batchtrainperiod)
       << " zipped="           << zipped
       << " labelsonly="       << labelsonly
       << " saveumatrix="      << saveumatrix
       << " classname="        << Simple::ShowString(classname)
       << " level="            << level
       << " rounds="           << rounds
       << " classrounds="      << classrounds
       << " prfrounds="        << prfrounds
       << " prfobjects="       << prfobjects
       << " forcehit="         << forcehit
       << " firstforcedidx="   << firstforcedidx
       << " usebias="          << usebias
       << " convolved="        << convolved
       << " logarithm="        << logarithm
       << " threshold="        << threshold
       << " summarylength="    << summarylength
       << " summarycliplength="<< summarycliplength
       << " magnify="          << magnify
       << " imagefile="        << imagefilename
       << " forkdisplay="      << forkdisplay
       << " matlabname="       << Simple::ShowString(MatlabName())
       << " filename="         << Simple::ShowString(FileName())
       << " compress="         << compress
       << " relaxcounttest="   << relaxcounttest
       << " skipresults="      << skipresults 
       << endl;

    if (dt&Simple::DumpRecursiveLong) {
      os << " traincount=";
      traincount.Dump(Simple::DumpLong, os);
    }

    if (dt&Simple::DumpRecursiveLong) {
      os << " bmudivdepth=";
      bmudivdepth.Dump(Simple::DumpLong, os);
    }
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::IsCreate() const {
    return method=="create" || method=="featuredata"	|| method=="bindump"
      || method=="sqldump"  || method=="pdf"
      || method=="extract" || method=="objectinfo"
      || method=="cluster"  || method=="erasefeatures"
      || method=="importfeatures" || method=="importdatfeatures"
      || method=="importexternalfeatures" || method=="importbindata"
      || method=="fillzerofeaturedata" || method=="createdummyfeatures"
      || method=="kmeanshistograms" || method=="pairdistances"
      || method=="elanize" || method=="segmentdetect" || method=="detect"
      || method=="sentences" || method=="kmeans"
      || method=="extractrawfeatures" || method=="videoshotsequence"
      || method=="nearest" || method=="featuretest"
      || method=="maskeddetection" || method=="exportlmdbfeatures"; 
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::DoAnalyse(PicSOM *p, const vector<string>& args) {
    p->PossiblyShowDebugInformation("Before calling Analyse()");

    Analysis analysis(p, NULL, NULL, args);
    analyse_result res = analysis.Analyse();

    p->PossiblyShowDebugInformation("After returning from Analyse()");

    if (analysis.XmlResultIsError())
      ShowError("DoAnalyse() XML error : ["+analysis.XmlResultErrorText()+"]");

    return !res.errored();
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::Optimize() {
    PicSOM::ThreadTestCancel();

    string msg = "Analysis::Optimize() : ";

    if (!ScriptHasChoices())
      return ShowError(msg+"no choices");

    vector<string> argv = DashedExtraArguments();

    stringstream ss;
    if (argv.size()) {
      ss << " argv.size()=" << argv.size();
      ss << " argv[0]=<" << argv[0] << ">";
    }

    list<string> before, block_orig, after, opts;
    string blockname;

    if (!ScriptSplitBlocks(script, blockname, opts, before, block_orig, after))
      return ShowError(msg+"ScriptSplitBlocks() failed");

    list<string> before_after = before;
    for (list<string>::const_iterator i=after.begin(); i!=after.end(); i++)
      if (i->find('$')==string::npos && (*i)[0]!='*')
        before_after.push_back(*i);

    if (!ScriptExecute(before_after))
      return ShowError(msg+"ScriptExecute() failed");

    DataBase *db = query ? query->GetDataBase() : NULL;

    string optvar = OptimizeVariable();
    if (optvar=="" && blockname=="MAX")
      return ShowError(msg+"optimize not set while optimize MAX");

    list<string> block = optimize_expand_line ?
      ScriptExpandBlock(block_orig, db) : block_orig;

    ss << " " << block.size() << " choices of type " << blockname
       << " for " << (optvar!=""?optvar:"no-optimize");

    batchblock = blockname;

    WriteLog("Optimize :", ss.str());

    string matlabn;

    bool ok = true, keep_subs = blockname=="LIST";
    for (list<string>::const_iterator oi=opts.begin(); oi!=opts.end(); oi++)
      if (*oi=="keep")
        keep_subs = true;

    script_list_t script_list;
    // list<string>::const_iterator biter = block.begin();

    size_t ii = 1; // should be changed to 0...
    // expand optimize blocks into separate scripts
    for (list<string>::const_iterator i = block.begin();
         ok && i!=block.end(); i++, ii++) {
      list<string> onescript = ScriptJoinBlocks(before, *i, after);

      string loopidi = loopid;
      if (loopidi!="")
	loopidi += "-";
      loopidi += ToStr(ii);
      onescript.push_back("loopid="+loopidi);

      script_list.push_back(make_pair(*i, make_pair(onescript, argv)));
    }

    // This is just to truncate treceval file if it exists, we'll be
    // appending to it from here on...
    if (!treceval.empty()) {
      ofstream os(treceval.c_str(), ios_base::trunc | ios_base::out);
      os.close();      
    }

    list<analyse_result> results = Analyse(script_list, true, false);
    
    list<analyse_result>::iterator riter=results.begin();
    for (size_t i=0; ok && i<results.size(); i++, riter++) {
      analyse_result res = *riter;

      if (res.errored()) {  // eg. AnalyseDiv() returns plain true...
        ok = false;
        break;
      }

      res.batchloop = i;

      bool to_be_inserted = true;
      if (optvar!="" && res.sub_result_type!="LIST") {
        pair<float,float> opt = OptimizeValue(res);
        res.optval  = opt.first;
        res.sortval = opt.second;

        *aout << "Analysis batch result #" << i << " : " << optvar << "="
              << opt.first << (res.params!=""?" with "+res.params:"")
              << endl;

        if (blockname=="MAX") { // insert in opt.second order
          list<analyse_result>::iterator pos;
          for (pos=result.sub_result.begin(); pos!=result.sub_result.end(); 
               pos++) 
            if (pos->sortval > res.sortval) break;
          result.sub_result.insert(pos,res);
          to_be_inserted = false;
        } 
      }
      
      if (to_be_inserted) // insert to end
        result.add_sub_result(res);

      if (blockname=="SUM")
        AddToResult(res, result);

      matlabn = MatlabName();
    }

    if (!result.sub_result.empty())
      result.sub_result_type = blockname;

    if (!ok)
      return ShowError(msg+"failed");

    if (result.sub_result.size()>0) { // was >1 until 201-09-15, why???
      if (blockname=="MAX") {
        Analysis::analyse_result& bestres = result.sub_result.front();
        AddToResult(bestres, result);
        result.params = bestres.params;
      }

      *aout << "Summary of analysis batch results with " << blockname
            << (optvar!=""?" "+optvar:"") << ":" << endl;
      for (list<analyse_result>::const_iterator i=result.sub_result.begin(); 
           i!=result.sub_result.end(); i++){
        const analyse_result& res = *i;
        *aout << " " << res.optval << " #" << res.batchloop
              << " " << res.params << endl;
      }
    }

    if (!keep_subs)
      result.clear_sub_results();

    if (result.ok()) { //obs! should this be !result.errored() ?
      if (matlabn!="")
        MatlabName(matlabn+"_sum");
      string mstr;
      WriteAnalyseResults("Optimize", result, mstr, true, true);
    }
    
    ConditionallyWriteResult(result);

    return result;
  }

  /////////////////////////////////////////////////////////////////////////////

  list<Analysis::analyse_result> Analysis::Analyse(script_list_t& sl,
						   bool sync, bool loop) {
    bool pth = UsePthreads() || !sync;
#ifndef ANALYSIS_USE_PTHREADS
    pth = false;
#endif // ANALYSIS_USE_PTHREADS

    if (Picsom()->HasSlaves())
      return AnalyseSlaves(sl, sync);

    if (!loop) {
#ifdef ANALYSIS_USE_PTHREADS
      return pth ? AnalysePthread(sl, sync) : AnalyseSerial(sl);
#else
      return AnalyseSerial(sl);
#endif // ANALYSIS_USE_PTHREADS
    }

    list<Analysis::analyse_result> ret;

    size_t oldsize = 0;
    for (;;)
      if (sl.size()>oldsize) {
	script_list_t csl;
	auto i = sl.begin();
	for (size_t j=0; j<oldsize; j++)
	  i++;

	for (; i!=sl.end(); i++)
	  csl.push_back(*i);
	oldsize += csl.size();
	    
	ret = Analyse(csl, sync, false);
	
      } else
	sleep(1);

    return ret;
  }

  /////////////////////////////////////////////////////////////////////////////

  list<Analysis::analyse_result>
  Analysis::AnalyseSlaves(script_list_t& sl, bool sync) {
    string msg = "AnalyseSlaves() : ";

    // see maxtaskspar / max_tasks_par
    bool allow_many = AllowManySlaveThreads(sl); 
    WriteLog(msg+"starting with allow_many=", ToStr(allow_many));

    list<analyse_result> results, error;

    script_list_t::const_iterator i = sl.begin();

    string loglineold;

    bool alive = true; // obs! this logic is questionable
    size_t i_no = 0, n_finish = 0, listsize = sl.size();
    while (true) { //outer
      struct timespec sleep_time = { 0, 100000000 }; // 0.1 second

      size_t nslt_runo = Picsom()->NslaveThreadsAlive(this);
      size_t nslt_limt = Picsom()->NslaveThreadsAlsoLimbo(this);
      size_t nslt_tert = Picsom()->NslaveThreadsAlsoTerminated(this);
      size_t nslt_lim  = nslt_limt-nslt_runo;
      size_t nslt_ter  = nslt_tert-nslt_runo;

      size_t nslh_conn = Picsom()->NslaveHostsContacted();
      size_t nslh_runo = Picsom()->NslaveHostsAlive(this);
      size_t nslh_limt = Picsom()->NslaveHostsAlsoLimbo(this);
      size_t nslh_tert = Picsom()->NslaveHostsAlsoTerminated(this);
      size_t nslh_lim  = nslh_limt-nslh_runo;
      size_t nslh_ter  = nslh_tert-nslh_runo;

      bool is_idle = false;
      // Picsom()->RwLockReadAnalysisScriptList();
      if (!sync /*&& i==sl.end()*/) {
	//Picsom()->RwUnlockReadAnalysisScriptList();
	//struct timespec ts = { 1, 0 }; // 1 second
	//nanosleep(&ts, NULL);
	Picsom()->RwLockReadAnalysisScriptList();

	if (sl.size()!=listsize) {
	  WriteLog(msg+ToStr(sl.size()-listsize)+" *NEW TASKS ARRIVED*");
	  listsize = sl.size();
	  alive = true;
	  i = sl.begin();
	  for (size_t ii=0; ii<i_no; ii++)
	    i++;
	} else
	  is_idle = true;

	Picsom()->RwUnlockReadAnalysisScriptList();
      }
      //Picsom()->RwUnlockReadAnalysisScriptList();

      if ((!alive || i==sl.end()) && !nslt_runo && sync)
	break;

      bool do_sleep = true;

      stringstream ss;
      ss << sl.size() << " tasks: " << i_no << " started + "
	 << sl.size()-i_no << " waiting, " << nslt_runo
	 << " alive slave threads (in " << nslh_runo
	 << " slave hosts, " << nslh_conn << " connected), "
	 << n_finish << " finished";
      if (nslt_ter)
	ss << ", " << nslt_ter << " (" << nslh_ter << ") terminated";
      if (nslt_lim)
	ss << ", " << nslt_lim << " (" << nslh_lim << ") in limbo";
      if (is_idle)
	ss << " *IDLE*";
      string logline = ss.str();
      if (logline!=loglineold)
	WriteLog(msg+logline);
      loglineold = logline;

      if (alive && i!=sl.end()) {
	const string& batchline = i->first;

	stringstream script;
	bool outdir_set = false, is_featext = false;
	size_t n_args = 0;
	const list<string>& scrl = i->second.first;
	for (list<string>::const_iterator j=scrl.begin(); j!=scrl.end(); j++) {
	  string tmp = *j;
	  if (tmp[0]==' ' || tmp[0]=='\t') {
	    size_t p = tmp.find_first_not_of(" \t");
	    if (p!=string::npos)
	      tmp.erase(0, p);
	  }
	  string atmp = tmp;
	  size_t p = tmp.find_first_of("= \t");
	  if (p!=string::npos) {
	    tmp.erase(p);
	    atmp.erase(0, p);
	  }

	  if (tmp!="slaves")
	    script << *j << endl;
	  
	  if (tmp=="outdir")
	    outdir_set = true;

	  if (tmp=="extractfeatures")
	    is_featext = true;

	  if (tmp=="args") {
	    p = atmp.find_first_not_of("= \t");
	    atmp.erase(0, p);
	    vector<string> dummy = SplitInSpaces(atmp);
	    n_args = dummy.size();
	  }	      
	}
	if (!outdir_set)
	  script << "outdir=" << PicSOM::Cwd() << endl;
	
	string scriptstr = script.str(), cmdline = scriptstr;
	while (true) { //inner 1
	  size_t q = cmdline.find('\n');
	  if (q==string::npos)
	    break;
	  cmdline[q] = ' ';
	}

	PicSOM::slave_info_t *slave =
	  Picsom()->SelectSlave(allow_many, 0.0, batchline,
				cmdline, sl.size(), alive);

	bool is_free = false, is_submit = false, is_wait = false;
	if (slave) {
	  // slave->RwLockIt();

	  is_free   = slave->status.find("_free")  !=string::npos;
	  is_submit = slave->status.find("_submit")!=string::npos;
	  is_wait   = slave->status.find("_wait")  !=string::npos;
	}

	if (is_submit || is_wait) {
	  ShowError(msg+"is_submit=="+ToStr((int)is_submit)+
		    " is_wait=="+ToStr((int)is_wait));
	  slave->RwUnlockIt();
	  return error;
	}

	string aname = "free-running";

	if (slave && !is_free) {
	  XmlDom xml = XmlDom::Doc("picsom:request");
	  XmlDom roo = xml.Root("request");
	  XmlDom ana = roo.Element("analysis");
	  
	  ana.Element("batchline", batchline);
	  ana.Element("script",    scriptstr);

	  for (vector<string>::const_iterator j=i->second.second.begin();
             j!=i->second.second.end(); j++)
	    ana.Element("arg", *j);

	  slave->conn->WriteOutXml(xml);
	  
	  bool dummy = false;
	  if (!slave->conn->ReadAndParseXML(dummy, false)) {
	    slave->RwUnlockIt();
	    //ShowError(msg+"ReadAndParseXML() failed 1");
	    //return error;
	    cerr << TimeStamp() << ThreadIdentifierUtil() << " "
		 << msg+"ReadAndParseXML() failed 1, continuing still..."
		 << endl;
	    Picsom()->TerminateSlave(*slave,
				     "because ReadAndParseXML() failed 1");
	    continue;
	  }
	  
	  XmlDom res(slave->conn->XMLdoc());
	  aname = res.FindContent("/result/analysis/thread/name", true);
	  if (aname=="") {
	    slave->RwUnlockIt();
	    //ShowError(msg+"FindContent() failed");
	    //return error;
	    cerr << TimeStamp() << ThreadIdentifierUtil() << " "
		 << msg+"FindContent(/result/analysis/thread/name) failed,"
	      " continuing still..."
		 << "[[[" << res.Stringify() << "]]]"
		 << endl;
	    Picsom()->TerminateSlave(*slave, "because <analyse_result/"
				     "thread/name> missing");
	    continue;
	  }

	  SetTimeNow( slave->task_started);
	  SetTimeZero(slave->task_finished);

	  if (is_featext)
	    slave_features_requested += n_args;

	  results.push_back(analyse_result(false));
	  
	  PicSOM::thread_info_t e;
	  e.object = this;
	  e.data   = &*results.rbegin();

	  XmlDom thr = res.FindPath("/result/analysis/thread", true);
	  Picsom()->UpdateSlaveThreadInfo(e, thr);

	  slave->threads.push_back(e);
	}

	if (slave) {
	  string blshort = batchline;
	  if (blshort.size()>500) {
	    vector<string> tv = SplitInSpaces(blshort);
	    if (tv.size()>2)
	      blshort = tv[0]+" ... "+tv.back()+" (total "+ToStr(tv.size())
		+" arguments)";
	  }

	  WriteLog("Started slave analysis <"+aname+"> in ["+slave->hostname+
		   "] ("+slave->hostspec+") with "
		   "keys=["+ToStr(slave->keys)+"] jobids=["+
		   ToStr(slave->jobids)+"] pid="+ToStr(slave->pid)+
		   " batchline=["+blshort+"]");
	  do_sleep = false;
	  i++;
	  i_no++;

	  slave->RwUnlockIt();

	  if (slave->hostspec.find("(condor,")!=string::npos) {
	    float sleeptime = 10;
	    WriteLog("... condor extra sleep "+ToStr(sleeptime)+" sec");
	    NanoSleep(sleeptime);
	  }
	}
      }

      // if (i==sl.end()) {
      // 	Picsom()->UpdateSlaveInfo();
      // 	sleep_time = { 10, 0 };
      // }

      while (true) { //inner 2
        pair<PicSOM::slave_info_t*, PicSOM::thread_info_t*> si
	  = Picsom()->SlaveThreadWithResults(this);

        if (!si.first) {
	  NanoSleep(0.1); // 0.1s;
          break;
	}

	// si.first->RwLockIt();
        WriteLog("Slave "+Picsom()->SlaveInfoString(*si.first, false)+
                 " finished with thread "+
                 Picsom()->ThreadInfoString(*si.second, true));

	n_finish++;

        if (si.second->slave_state!="ready") {
	  si.first->RwUnlockIt();
          ShowError(msg+"slave_state != ready");
          return error;
        }

	bool result_ok = true;

        XmlDom xml = XmlDom::Doc("picsom:request");
        XmlDom roo = xml.Root("request");
        XmlDom ana = roo.Element("analysis");
        ana.Prop("name", si.second->name);
        si.first->conn->WriteOutXml(xml);
        bool dummy = false;
        bool parseresult = si.first->conn->ReadAndParseXML(dummy, false);
	if (!parseresult) {
          //ShowError(msg+si.first->conn->LogIdentity()+
	  // " ReadAndParseXML() failed 2");
	  si.first->RwUnlockIt();
          // return error;
	  cerr << TimeStamp() << ThreadIdentifierUtil() << " "
	       << msg+"ReadAndParseXML() failed 2, continuing still..."
	       << endl;
	  Picsom()->TerminateSlave(*si.first,
				   "because ReadAndParseXML() failed 2");
	  result_ok = false;
	  continue;
        }

        XmlDom res(si.first->conn->XMLdoc());
        XmlDom ars = res.FindPath("/result/analysis/analyse_result", true);
        if (!ars) {
          //ShowError(msg+"FindPath(/result/analysis/analyse_result) failed");
          //return error;
	  cerr << TimeStamp() << ThreadIdentifierUtil() << " "
	       << msg+"FindPath(/result/analysis/analyse_result) failed"
	       << endl;
	  Picsom()->TerminateSlave(*si.first,
				   "because <analyse_result> missing");
	  result_ok = false;
        }

	if (result_ok) {
	  ((analyse_result*)si.second->data)->from_xml(ars);

	  XmlDom xrs = res.FindPath("/result/analysis/xmlresult", true);
	  if (xrs && !ProcessSlaveXmlResult(xrs, *si.first)) {
	    ShowError(msg+"ProcessSlaveXmlResult() failed");
	    si.first->RwUnlockIt();
	    return error;
	  }
	  alive = true;  // obs! chewing cum added 2014-11-14
	}

	SetTimeNow(si.first->task_finished);
	si.first->RwUnlockIt();

        if (!Picsom()->RemoveSlaveThread(si)) {
	    cerr << TimeStamp() << ThreadIdentifierUtil() << " "
		 << msg+"RemoveSlaveThread() failed, continuing still..."
		 << endl;
          // ShowError(msg+"RemoveSlaveThread() failed");
          // return error;
        }
	
	si.first->n_tasks_fin++;
	si.first->n_tasks_par--;

	if (result_ok)
	  Picsom()->PossiblyTerminateSlave(*si.first);

	if (i!=sl.end()) {
	  if (si.first->parent)
	    Picsom()->PossiblyStartNewSlaves(*si.first->parent);

	  break;
	}
      }

      if (do_sleep) {
	struct timespec ts = sleep_time;
	nanosleep(&ts, NULL);
      }
    }

    return results;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AllowManySlaveThreads(const script_list_t& sl) const {
    if (sl.empty())
      return false;

    bool is_create = false, is_extractfeatures = false;

    script_list_t::const_iterator i=sl.begin();
    const list<string>& scrl = i->second.first;
    for (list<string>::const_iterator j=scrl.begin(); j!=scrl.end(); j++) {
      if (j->find('=')==string::npos)
        continue;

      pair<string,string> kv = SplitKeyEqualValueNew(*j);

      if (kv.first=="analyse" && kv.second=="create")
        is_create = true;
      
      if (kv.first=="extractfeatures" && IsAffirmative(kv.second))
        is_extractfeatures = true;
    }

    return !is_create || !is_extractfeatures;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResult(const XmlDom& xml,
				       const PicSOM::slave_info_t& si) {
    string msg = "Analysis::ProcessSlaveXmlResult() : ";

    bool allow_overwrite = true;
    bool debug = true, save = false;
    if (debug)
      WriteLog(msg+"starting");

    if (save) {
      static size_t no = 0;
      string fname = "picsom-slave-result-"+ToStr(no++)+".xml";
      XmlDom doc(xml.doc);
      bool ok = doc.Write(fname);
      if (ok)
	WriteLog(msg+"saved in <"+fname+">");
      else
	ShowError(msg+"failed to save in <"+fname+">");
    }

    if (xml.NodeName()!="xmlresult")
      return ShowError(msg+"not an <xmlresult> element");

    stringstream info;
    if (si.hostname!="")
      info << " hostname=" << si.hostname;
    info << " keys=[" << ToStr(si.keys) << "]";
    info << " jobids=[" << ToStr(si.jobids) << "]";
    if (si.threads.size())
      info << " spec=\"" << si.threads.begin()->text << "\"";

    bool ok = true;
    for (XmlDom n=xml.FirstElementChild(); ok&&n; n=n.NextElement()) {
      if (n.NodeName()=="featurevectorlist") {
	string fn;
	size_t c = 0;
	ok = ProcessSlaveXmlResultFeatureVectorList(n, allow_overwrite, fn, c);
	WriteLog("Stored "+ToStr(c)+" <"+fn+"> features from"+info.str());
	slave_features_stored += c;

      } else if (n.NodeName()=="detectionvectorlist") {
	string fn;
	size_t c = 0;
	ok = ProcessSlaveXmlResultDetectionVectorList(n, allow_overwrite, fn, c);
	WriteLog("Stored "+ToStr(c)+" <"+fn+"> detections from"+info.str());
	slave_detections_stored += c;

      } else if (n.NodeName()=="captionlist") {
	string fn;
	size_t c = 0;
	ok = ProcessSlaveXmlResultCaptionList(n, allow_overwrite, fn, c);
	WriteLog("Stored "+ToStr(c)+" <"+fn+"> captions from"+info.str());
	slave_captions_stored += c;

      } else if (n.NodeName()=="objectinfohashlist") {
	size_t c = 0;
	ok = ProcessSlaveXmlResultObjectInfoHashList(n, c);
	WriteLog("Stored "+ToStr(c)+" objects' info from"+info.str());
	slave_objectinfos_stored += c;

      } else if (n.NodeName()=="objectchildinfolist") {
	size_t c1 = 0, c2 = 0;
	ok = ProcessSlaveXmlResultObjectChildInfoList(n, c1, c2);
	WriteLog("Stored info on "+ToStr(c1)+" objects' "+ToStr(c2)
		 +" children from"+info.str());

      } else if (n.NodeName()=="detectionsummary") {
	PicSOM::detection_stat_t& dstat = detection_stat;
	stringstream ss;
	map<string,string> m = n.PropertyMap();
	for (auto i=m.begin(); i!=m.end(); i++) {
	  ss << " " << i->first << "=" << i->second;
	  size_t val = atoi(i->second.c_str());
	  if (i->first=="status")
	    (i->second=="ok" ? dstat.nok : dstat.nfailed)++;
	  else if (i->first=="sum_jobs")
	    dstat.njobs += val;
	  else if (i->first=="sum_processed")
	    dstat.ntot += val;
	  else if (i->first=="sum_skipped")
	    dstat.nskip += val;
	  else if (i->first=="sum_found")
	    dstat.nfound += val;
	  else if (i->first=="sum_nodata")
	    dstat.nnodata += val;
	  else if (i->first=="sum_done")
	    dstat.ndone += val;
	}
	WriteLog("Summary of detections:"+ss.str()+" from"+info.str());

      } else
	return ShowError(msg+"element <"+n.NodeName()+"> unknown");
    }

    if (debug)
      WriteLog(msg+"finished");

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultFeatureVectorList(const XmlDom& xml,
							bool allow_overwrite,
							string& fn,
							size_t& c) {
    string msg = "Analysis::ProcessSlaveXmlResultFeatureVectorList() : ";
    // cout << msg << endl;

    if (xml.NodeName()!="featurevectorlist")
      return ShowError(msg+"not an <featurevectorlist> element");

    c = 0;
    bool ok = true;
    for (XmlDom n=xml.FirstElementChild(); ok&&n; n=n.NextElement()) {
      if (n.NodeName()=="featurevector") {
	ok = ProcessSlaveXmlResultFeatureVector(n, allow_overwrite, fn);
	c++;
      } else
	return ShowError(msg+"element <"+n.NodeName()+"> unknown");
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultFeatureVector(const XmlDom& xml,
						    bool allow_overwrite,
    						    string& fn) {
    string msg = "Analysis::ProcessSlaveXmlResultFeatureVector() : ";

    bool debug = false;
    if (debug)
      WriteLog(msg+"starting");

    if (xml.NodeName()!="featurevector")
      return ShowError(msg+"not an <featurevector> element");

    string b64src   = xml.FirstChildContent();
    string database = xml.Property("database");
    string name     = xml.Property("name");
    string label    = xml.Property("label");
    string length   = xml.Property("length");
    string type     = xml.Property("type");

    if (debug)
      WriteLog(msg+"content read");

    if (b64src=="" || database=="" || name=="" || label=="" ||
	length=="" || type=="")
      return ShowError(msg+"mandatory content missing");

    DataBase *db = Picsom()->FindDataBase(database);

    int oidx = db->LabelIndex(label);
    if (!db->IndexOK(oidx))
      return ShowError(msg+"index of label <"+label+"> not solved in <"+
		       database+">");

    istringstream b64i(b64src);
    ostringstream b64o;
    if (!b64::decode(b64i, b64o))
      return ShowError(msg+"b64::decode() failed");

    string b64 = b64o.str();

    if (debug)
      WriteLog(msg+"decoded");

    size_t vl = atoi(length.c_str());
    if (!vl || b64.size()!=vl*sizeof(float))
      return ShowError(msg+"vector length problem");

    FloatVector vec(vl, (float*)b64.c_str(), label.c_str());

    Index *idx = db->FindIndex(name, "", true);
    if (!idx)
      return ShowError(msg+"index <"+name+"> not found in <"+
		       database+">");
    
    VectorIndex *vidx = dynamic_cast<VectorIndex*>(idx);
    if (!vidx)
      return ShowError(msg+"VectorIndex casting error");
 
    if (vidx->BinDataExists(oidx)) {
      string zz = msg+"data for object #"+ToStr(oidx)+" exists in <"+
	name+"> in <"+database+">";
      if (!allow_overwrite)
	return ShowError(zz);
      WriteLog(msg+zz);
    }

    if (debug)
      WriteLog(msg+"existence checked");

    for (int i=0; i<vec.Length(); i++) {
      int cfy = fpclassify(vec[i]);
      if (cfy==FP_NAN || cfy==FP_INFINITE) {
	stringstream ss;
	ss << "float with index " << i << " is NaN or Inf in ["
	   << b64src << "]";
	return ShowError(msg+ss.str());
      }
    }
    
    if (!vidx->BinDataStoreFeature(vec))
      return ShowError(msg+"BinDataStoreFeature() failed");
    
    if (debug) {
      stringstream ss;
      ss << "[" << vidx->BinInfoFileName() << "] "
	 << vidx->BinInfoVectorLength() << " " << vl << " #" << oidx << " <"
	 << label << ">";
      for (size_t i=0; i<10 && i<vl; i++)
	ss << " " << vec[i];
      WriteLog(msg+"stored "+ss.str());
    }

    fn = name;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultDetectionVectorList(const XmlDom& xml,
							  bool allow_overwrite,
							  string& fn,
							  size_t& c) {
    string msg = "Analysis::ProcessSlaveXmlResultDetectionVectorList() : ";
    // cout << msg << endl;

    if (xml.NodeName()!="detectionvectorlist")
      return ShowError(msg+"not an <detectionvectorlist> element");

    c = 0;
    bool ok = true;
    for (XmlDom n=xml.FirstElementChild(); ok&&n; n=n.NextElement()) {
      if (n.NodeName()=="detectionvector") {
	ok = ProcessSlaveXmlResultDetectionVector(n, allow_overwrite, fn);
	c++;
      } else
	return ShowError(msg+"element <"+n.NodeName()+"> unknown");
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultDetectionVector(const XmlDom& xml,
						      bool /*allow_overwrite*/,
						      string& fn) {
    string msg = "Analysis::ProcessSlaveXmlResultDetectionVector() : ";

    bool debug = false;
    if (debug)
      WriteLog(msg+"starting");

    if (xml.NodeName()!="detectionvector")
      return ShowError(msg+"not an <detectionvector> element");

    string b64src   = xml.FirstChildContent();
    string database = xml.Property("database");
    string name     = xml.Property("name");
    string label    = xml.Property("label");
    string length   = xml.Property("length");
    string type     = xml.Property("type");

    if (debug)
      WriteLog(msg+"content read");

    if (b64src=="" || database=="" || name=="" || label=="" ||
	length=="" || type=="")
      return ShowError(msg+"mandatory content missing");

    DataBase *db = Picsom()->FindDataBase(database);

    int oidx = db->LabelIndex(label);
    if (!db->IndexOK(oidx))
      return ShowError(msg+"index of label <"+label+"> not solved in <"+
		       database+">");

    istringstream b64i(b64src);
    ostringstream b64o;
    if (!b64::decode(b64i, b64o))
      return ShowError(msg+"b64::decode() failed");

    string b64 = b64o.str();

    if (debug)
      WriteLog(msg+"decoded");

    size_t vl = atoi(length.c_str());
    if (!vl || b64.size()!=vl*sizeof(float))
      return ShowError(msg+"vector length problem");

    vector<float> vec((float*)b64.c_str(), (float*)b64.c_str()+vl);

    // existing detections are not yet checked...

    XmlDom dummy;
    bool incore = false;
    db->StoreDetectionResult(oidx, name, vec, dummy, incore);

    // if (debug)
    //   WriteLog(msg+"existence checked");

    if (debug)
      WriteLog(msg+"stored");

    fn = name;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultCaptionList(const XmlDom& xml,
						  bool allow_overwrite,
						  string& fn, size_t& c) {
    string msg = "Analysis::ProcessSlaveXmlResultCaptionList() : ";
    // cout << msg << endl;

    if (xml.NodeName()!="captionlist")
      return ShowError(msg+"not a <captionlist> element");

    c = 0;
    size_t nc = 0;
    for (XmlDom n=xml.FirstElementChild(); n; n=n.NextElement()) {
      if (n.NodeName()=="caption")
	nc++;
      else
	return ShowError(msg+"element <"+n.NodeName()+"> unknown");
    }

    bool ok = true;
    for (XmlDom n=xml.FirstElementChild(); ok&&n; n=n.NextElement())
      if (n.NodeName()=="caption") {
	ok = ProcessSlaveXmlResultCaption(n, allow_overwrite, c==nc-1, fn);
	c++;
      }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultCaption(const XmlDom& xml,
					      bool /*allow_overwrite*/,
					      bool do_flush,
					      string& fn) {
    string msg = "Analysis::ProcessSlaveXmlResultCaption() : ";

    bool debug = false;
    if (debug)
      WriteLog(msg+"starting");

    if (xml.NodeName()!="caption")
      return ShowError(msg+"not an <caption> element");

    string caption  = xml.FirstChildContent();
    string database = xml.Property("database");
    string name     = xml.Property("name");
    string label    = xml.Property("label");

    if (debug)
      WriteLog(msg+"content read");

    if (caption=="" || database=="" || name=="" || label=="")
      return ShowError(msg+"mandatory content missing");

    DataBase *db = Picsom()->FindDataBase(database);

    int oidx = db->LabelIndex(label);
    if (!db->IndexOK(oidx))
      return ShowError(msg+"index of label <"+label+"> not solved in <"+
		       database+">");

    textline_t tl(db, oidx);
    if (!tl.txt_decode(caption))
      return ShowError(msg+"parsing <"+caption+"> failed");

    if (debug)
      WriteLog(msg+"decoded");

    // existing captions are not yet checked...

    XmlDom dummy;
    if (!db->StoreCaptioningResult(oidx, name, tl, use_textindex, do_flush, dummy))
      return ShowError(msg+"StoreCaptioningResult() failed with name="+name
		       +" idx="+ToStr(oidx));

    // if (debug)
    //   WriteLog(msg+"existence checked");

    if (debug)
      WriteLog(msg+"stored");

    fn = name;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultObjectInfoHashList(const XmlDom& xml,
							 size_t& c) {
    string msg = "Analysis::ProcessSlaveXmlResultObjectInfoHashList() : ";
    // cout << msg << endl;

    if (xml.NodeName()!="objectinfohashlist")
      return ShowError(msg+"not an <objectinfohashlist> element");

    DataBase *db = CheckDB();
    if (!db->SqlBeginTransaction())
      return ShowError(msg+"SqlBeginTransaction() failed");

    c = 0;
    bool ok = true;
    for (XmlDom n=xml.FirstElementChild(); ok&&n; n=n.NextElement()) {
      if (n.NodeName()=="objectinfohash") {
	ok = ProcessSlaveXmlResultObjectInfoHash(n);
	c++;
      } else
	return ShowError(msg+"element <"+n.NodeName()+"> unknown");
    }

    if (!db->SqlEndTransaction())
      return ShowError(msg+"SqlEndTransaction() failed");

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultObjectInfoHash(const XmlDom& xml) {
    string msg = "Analysis::ProcessSlaveXmlResultObjectInfoHash() : ";
    // cout << msg << endl;

    if (xml.NodeName()!="objectinfohash")
      return ShowError(msg+"not an <objectinfohash> element");

    map<string,string> m = xml.PropertyMap();

    DataBase *db = CheckDB();

    if (db->SqlMode()!=2)
      return ShowError(msg+"db->SqlMode()!=2");

    string label = m["label"];
    int idx     = db->LabelIndexGentle(label, false);
    bool update = idx>=0;
    if (!update) {
      target_type tt = target_image; // obs! hard-coded
      idx = db->AddOneLabel(label, tt, false, false);
    }
    db->UpdateOriginsInfoSql(idx, m, update);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultObjectChildInfoList(const XmlDom& xml,
							  size_t& c1,
							  size_t& c2) {
    string msg = "Analysis::ProcessSlaveXmlResultObjectChildInfoList() : ";
    // cout << msg << endl;

    if (xml.NodeName()!="objectchildinfolist")
      return ShowError(msg+"not an <objectchildinfolist> element");

    bool ok = true;
    for (XmlDom n=xml.FirstElementChild(); ok&&n; n=n.NextElement()) {
      if (n.NodeName()=="objectchildinfo") {
	size_t c = 0;
	ok = ProcessSlaveXmlResultObjectChildInfo(n, c);
	c1++;
	c2 += c;
      } else
	return ShowError(msg+"element <"+n.NodeName()+"> unknown");
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessSlaveXmlResultObjectChildInfo(const XmlDom& xml,
						      size_t& c) {
    string msg = "Analysis::ProcessSlaveXmlResultObjectChildInfo() : ";
    // cout << msg << endl;

    if (xml.NodeName()!="objectchildinfo")
      return ShowError(msg+"not an <objectchildinfo> element");

    DataBase *db = CheckDB();

    string ps = xml.Property("parent");
    string cs = xml.Property("child");

    vector<string> psv = SplitInSpaces(ps);
    vector<string> csv = SplitInSpaces(cs);

    vector<size_t> piv, civ;
    for (auto i=psv.begin(); i!=psv.end(); i++)
      piv.push_back(db->LabelIndex(*i));
    for (auto i=csv.begin(); i!=csv.end(); i++)
      civ.push_back(db->LabelIndex(*i));

    c = civ.size();

    for (auto i=piv.begin(); i!=piv.end(); i++)
      if (!db->AppendSubobjectsFile(*i, civ))
	return ShowError(msg+"AppendSubobjectsFile() failed");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  list<Analysis::analyse_result> Analysis::AnalyseSerial(const script_list_t&
                                                         sl) {
    list<analyse_result> results;
    script_list_t::const_iterator liter = sl.begin();
    bool ok = true;
    string detstr;
    for (size_t i=0; ok && i<sl.size(); i++, liter++) {
      WriteLog("Starting analysis batch loop "+ToStr(i)+"/"+ToStr(sl.size()));
      analyse_result res = Analyse(*liter);
      results.push_back(res);
    }

    /// obs! this is relevant for analyse=retrieve database=mirflickr1m ...
    if (verbose) {
      double map    = 0, prec50 = 0, auc = 0;
      double mapstd = 0, prec50std = 0, aucstd = 0;

      double sm = 0, sm2 = 0, sp = 0, sp2 = 0, sa = 0, sa2 = 0;
      size_t n = 0;
      for (auto i=results.begin(); i!=results.end(); i++)
	if (i->avgprecision.size()) {
	  double v = i->avgprecision.back()/i->rescount;
	  sm  += v;
	  sm2 += v*v;

	  v = i->precision[49]/i->rescount;
	  sp  += v;
	  sp2 += v*v;

	  v = i->roc_auc/i->rescount;
	  sa  += v;
	  sa2 += v*v;
	  n++;
	}

      if (n>1) {
	sm /= n;
	sm2 = sqrt((sm2-n*sm*sm)/(n-1));
	sp /= n;
	sp2 = sqrt((sp2-n*sp*sp)/(n-1));
	sa /= n;
	sa2 = sqrt((sa2-n*sa*sa)/(n-1));
	cout << sm << " " << sm2 << " " << sp << " " << sp2
	     << " " << sa << " " << sa2 << endl;
	map       = sm;
	prec50    = sp;
	auc       = sa;
	mapstd    = sm2;
	prec50std = sp2;
	aucstd    = sa2;

	cout << "RESULT: <" << classname << "> [" << detstr << "] MAP="
	     << map << " (" << mapstd
	     << ") Prec@50=" << prec50
	     << " (" << prec50std << ") AUC=" << auc << " ("
	     << aucstd << ")" << endl;
      }
    }

    return results;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::Analyse(const script_list_e& scr) {
    const string& bline         = scr.first;
    const list<string>& bscript = scr.second.first;
    const vector<string>& argv  = scr.second.second;

    WriteLog("Starting analysis of batch entry ["+bline+"]");

    Analysis analysis(Picsom(), this, NULL, argv);
    analysis.Script(bscript); 
    analysis.BatchParameters(bline, this);

    analyse_result res = analysis.Analyse();

    if (res.params=="") // this was unconditional until 17.8.2006
      res.params = analysis.BatchParameters();
      
    return res;
  }

  /////////////////////////////////////////////////////////////////////////////

#ifdef ANALYSIS_USE_PTHREADS

  list<Analysis::analyse_result>
  Analysis::AnalysePthread(const script_list_t& sl, bool sync) {
    string msg = "AnalysePthread(script_list_t, sync="+ToStr(sync)+") : ";

    list<analyse_result> result, err;
    err.push_back(analyse_result(false));

    script_list_t::const_iterator liter = sl.begin();
    bool ok = true;
    for (size_t i=0; ok && i<sl.size(); i++, liter++) {
      string astr;
      for (auto j=liter->second.first.begin();
	   j!=liter->second.first.end(); j++)
	if (j->find("args=")==0)
	    astr = *j;

      WriteLog(msg+"Starting analysis batch loop <"+astr+"> "+
               ToStr(i)+"/"+ToStr(sl.size())+" threads running "+
	       ToStr(Picsom()->ThreadsRunning())+"/"+
	       (Picsom()->Threads()>=0?
		ToStr(Picsom()->Threads()):"unlimited"));

      analyse_pthread_data_t *tdata = AnalysePthread(*liter);

      if (!tdata) {
        ShowError(msg+"pthread_create() failed");
        return err;
      }

      if (!AnalysePthreadJoin(result, false))
	return err;

      Picsom()->SleepIfNoThreadsAvailable();
    }

    if (sync) {
      WriteLog(msg+"Now joining rest of "+
	       ToStr(thread_data.size())+" pthreads");

      if (!AnalysePthreadJoin(result, true))
	return err;
    }

    return result;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AnalysePthreadJoin(list<analyse_result>& result,
				    bool collect_all) {
    string msg = "Analysis::AnalysePthreadJoin() : ";

    if (Picsom()->DebugThreads())
      WriteLog(msg+"starting with thread_data.size()="
	       +ToStr(thread_data.size())+" collect_all="+ToStr(collect_all));

    string myid = ThreadIdentifierUtil();

    size_t loop = 0, osize = thread_data.size();
    for (thread_data_t::iterator i=thread_data.begin();
	 i!=thread_data.end(); loop++) {
      analyse_pthread_data_t& data = *i;
      string parid = ThreadParentIdentifier(data);
      if (Picsom()->DebugThreads())
	WriteLog(msg+"loop="+ToStr(loop)+"/"+ToStr(osize)
		 +" thread="+ThreadIdentifier(data)
		 +" parent="+parid
		 +" running="+ToStr(data.running)
		 +" ready="+ToStr(data.ready)
		 +" collected="+ToStr(data.collected)
		 +" joined="+ToStr(data.joined));
      
      if (myid!=parid || (!collect_all && !data.ready) || data.collected) {
	i++;
	continue;
      }

      bool do_join = (collect_all || data.ready) && !data.joined;
      if (do_join && !AnalysePthreadJoin(data))
	return false;
      
      if (data.ready && !data.collected) {
	result.push_back(data.result);
	data.collected = true;
      }
      Picsom()->UnregisterThread(data.thread_id);

      i = thread_data.erase(i);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AnalysePthreadJoin(analyse_pthread_data_t& data) {
    string msg = "AnalysePthreadJoin() : ";

    WriteLog(msg+"trying to join "+ThreadIdentifier(data)+" "+data.param.first);

    void *void_ret = NULL;
    int r = pthread_join(data.thread_id, &void_ret);
    data.joined = true;

    if (r) {
      string err = "???";
      if (r==EDEADLK)
	err = "EDEADLK";
      if (r==EINVAL)
	err = "EINVAL";
      if (r==ESRCH)
	err = "ESRCH";

      err += 
	" running="+ToStr(data.running)+
	" ready="+ToStr(data.ready)+
	" collected="+ToStr(data.collected)+
	" joined="+ToStr(data.joined);

      return ShowError(msg+"pthread_join() failed when trying to join "+
		       ToStr(data.thread_id)+" with "+err);
    }

    if (!void_ret || void_ret!=&data)
      return ShowError(msg+"pthread_join() returned strange");

    WriteLog(msg+"joined "+ThreadIdentifier(data)+" \""+data.param.first
	     +"\" -- thread_data size "+ToStr(thread_data.size()));

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  string Analysis::ThreadDataInfo(const analyse_pthread_data_t& d) const {
    stringstream ss;
    ss << "thread=" << ThreadIdentifier(d)
       << " parent=" << ThreadParentIdentifier(d)
       << " thread_set=" << d.thread_set
       << " ready=" << d.ready
       << " joined=" << d.joined
       << " collected=" << d.collected
       << " identifier=" << d.param.first
       << " script=[";
    for (list<string>::const_iterator i=d.param.second.first.begin();
	 i!=d.param.second.first.end(); i++)
      ss << *i << " ";
    ss << "] args=[";
    for (vector<string>::const_iterator i=d.param.second.second.begin();
	 i!=d.param.second.second.end(); i++)
      ss << *i << " ";
    ss << "]";

    return ss.str();
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::ShowThreadDataInfo() const {
    if (thread_data.size()) {
      cout << "Analysis \"" << Identity() << "\" " << ThreadIdentifierUtil()
	   << " threads:" << endl;
      for (thread_data_t::const_iterator i=thread_data.begin();
	   i!=thread_data.end(); i++)
	cout << "  " << ThreadDataInfo(*i) << endl;
    }
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_pthread_data_t
  *Analysis::AnalysePthread(const script_list_e& sa) {
    string msg = "AnalysePthread(script_list_e) : ";
    WriteLog(msg+"Starting analysis pthread -- thread_data size "+
	     ToStr(thread_data.size()));

    analyse_pthread_data_t d; // duplicated in InsertOneFileParallel()
    d.thread_set = false;
    d.tid        = 0;
    d.analysis   = this;
    d.param      = sa;
    d.running    = false;
    d.ready      = false;
    d.joined     = false;
    d.collected  = false;
    d.result     = analyse_result(false);
    d.parent_thread_id = pthread_self();
    d.parent_tid       = gettid();

    thread_data.push_back(d);
    thread_data_t::reverse_iterator di = thread_data.rbegin();
    analyse_pthread_data_t& datax = *di;
    volatile analyse_pthread_data_t& data = *di;

    int r = pthread_create(&datax.thread_id, NULL,
                           (CFP_pthread) AnalysePthreadCall,
                           (void*)&datax);
    data.thread_set = true;

    if (r) {
      ShowError(msg+"pthread_create() failed");
      return NULL;
    }

    while (!data.tid) {
      struct timespec ts = { 0, 1000 }; // 1 microsecond
      nanosleep(&ts, NULL);
    }

    string thread_text = datax.param.first;

    if (thread_text.size()>500) {
      vector<string> tv = SplitInSpaces(thread_text);
      if (tv.size()>2)
	thread_text = tv[0]+" ... "+tv.back()+" (total "+ToStr(tv.size())
	  +" arguments)";
    }

    RegisterThread(datax.thread_id, datax.tid, thread_text, &datax);

    return &datax;
  }

  /////////////////////////////////////////////////////////////////////////////

  void *Analysis::AnalysePthreadCall(void *p) {
    if (!p)
      return NULL;

    int ssec = 10;

    DataBase::MysqlThreadInit();

    analyse_pthread_data_t *d = (analyse_pthread_data_t*)p;
    d->tid = gettid();

    struct timespec ts = { 0, 1000000 }; // 1 millisecond
    nanosleep(&ts, NULL); // obs! this tries to solve the race...
 
    for (;;) {
      int nt = d->analysis->Picsom()->ThreadsTotal();
      int nr = d->analysis->Picsom()->Threads("running", "analysis");
      int np = d->analysis->Picsom()->Threads("pending", "analysis");
      
      string str = ToStr(nr)+" running (max "+ToStr(use_pthreads)+
	") and "+ToStr(np)+" pending analyse threads out of "+ToStr(nt);
      int slee = 0;
      if (use_pthreads && nr>=use_pthreads)
	slee = ssec;

      if (slee)
	str += " -- sleeping "+ToStr(slee)+" seconds";
      
       d->analysis->WriteLog(str);
       
       if (slee)
	 sleep(slee);
       else
	 break;
    }

    d->running = true;
    d->result = d->analysis->Analyse(d->param);
    d->ready = true;

    DataBase::MysqlThreadEnd();

    return p;
  }

  /////////////////////////////////////////////////////////////////////////////

  const string& Analysis::ThreadState(analyse_pthread_data_t *p) const {
    static string null = "null", uninit = "uninit", pending = "pending";
    static string running = "running", cancelled = "cancelled";
    static string errored = "errored", ready = "ready", joined = "joined";
    static string collected = "collected";

    if (!p)
      return null;

    if (!p->thread_set)
      return uninit;
    
    if (!p->running && !p->ready)
      return pending;

    if (!p->ready)
      return running;  // or cancelled ?

    if (p->result.errored())
      return errored;

    if (p->collected)
      return collected;

    if (p->joined)
      return joined;

    return ready;
  }

  /////////////////////////////////////////////////////////////////////////////

  const Analysis::analyse_result&
  Analysis::ThreadResult(analyse_pthread_data_t *p) const {
    static analyse_result err(false);

    if (!p)
      return err;

    return p->result;
  }

#endif // ANALYSIS_USE_PTHREADS

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::CrossValidateNew() {
    string msg = "CrossValidateNew ["+method+"/"+crossval+"]";
    WriteLog(msg);

    string err = "CrossValidateNew() : ";

    if (query->HasViewClass())
      return ShowError(err+"cannot handle non-empty viewclass");

    vector<string> argv = DashedExtraArguments();

    string xvalhdr = "xval";
    size_t n = GetDataBase()->ContentsErase(xvalhdr);
    WriteLog("CrossValidate: cleared contents: "+ToStr(n));

    vector<string> specbase = SplitInSomething("/", false, crossval);
    string posi = query->Positive();
    string spec = specbase[0];
    string base = specbase.size()>1 ? specbase[1] : posi;

    ground_truth base_gt = GroundTruthExpression(base, Target(), -1, false);
    WriteLog("CrossValidate: base set <"+base+"> ["+
             TargetTypeString(Target())+"] contains "+
             ToStr(base_gt.positives())+" positives");
    
    CheckDB()->GroundTruthSummaryTable(base_gt, false, false, *aout);

    if (base==posi)
      WarnOnce(msg+" it is not recommended to have base==posi ...");

    size_t nfold = 0;
    bool do_H = false, do_V = false;

    if (spec!="LOO") {
      size_t p = spec.find_first_not_of("0123456789");
      if (p)
        nfold = atoi(spec.substr(0, p).c_str());
      if (spec.size()!=p+1 && spec.size()!=p+2)
        return ShowError(err+"unable to interpret [", spec, "] A");
      if (spec[p]=='H' || spec[p+1]=='H')
        do_H = true;
      if (spec[p]=='V' || spec[p+1]=='V')
        do_V = true;
      
      if (!p || (!do_H && !do_V))
        return ShowError(err+"unable to interpret [", spec, "] B");
    } else {
      WarnOnce(msg+" LOO perhaps/surely not working");
      // some logic is certainly still missing...
      ground_truth all = GroundTruthExpression(posi);
      nfold = all.positives();
      do_H = true;
    }

    const string rstr = CheckDB()->RestrictionName();

    target_type tt = target_any_target;
    aspect_map_t posiasp = query->PositiveAspectsMap(tt, -1, false);
    aspect_map_t negaasp = query->NegativeAspectsMap(tt, -1, false);

    ground_truth_list gtl;
    AddAspectInfo(gtl, "positive", posiasp);
    AddAspectInfo(gtl, "negative", negaasp);

    string mstr;
    list<string> extra;
    AddExtraVariableInfo(extra, "crossval",        crossval);
    AddExtraVariableInfo(extra, "spec",            spec);
    AddExtraVariableInfo(extra, "base",            base);
    AddExtraVariableInfo(extra, "batchparameters", batchparameters);
    AddExtraVariableInfo(extra, "depth",           ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack",       TaskStack());

    query->WriteAnalyseVariablesNew("CrossVal", mstr, gtl, extra);
    query->DoubleLogSeparator(mstr);

    const string rstrhdr = rstr=="" ? "~" : "("+rstr+")\\";
    const string nfoldstr = ToStr(nfold);

    analyse_result total;
    
    bool ok = true;
    for (size_t i=0; ok && i<2*nfold; i++) {
      if ((i%2==0 && !do_H) || (i%2==1 && !do_V))
        continue;
      
      const string ii = ToStr(i/2), hv = i%2==0?"H":"V", hvx = hv+"x";
      string niihvx = nfoldstr+"-"+ii+"-"+hvx;
      string tsetname = xvalhdr+"-"+niihvx;
      string gt_tsetn = "gt("+tsetname+")";
      string tsetexpr = "$split("+base+","+TargetTypeString(Target())+","
        +nfoldstr+","+ii+","+hvx+")";

      WriteLog(msg+" : "+niihvx);

      // CheckDB()->SetGroundTruth(tsetname, tsetexpr); // better in script...
      
      string tsetexpname = tsetname+"-exp";
      string gt_tsetexpn = "gt("+tsetexpname+")";
      string tsetexpexpr = "$exp("+tsetname+")";

      // CheckDB()->SetGroundTruth(tsetexpname, tsetexpexpr); // ditto

      string reststr = rstrhdr+tsetexpname;
      string vclsstr = "("+posi+")\\"+tsetname;
      if (rstr!="")
        vclsstr = "("+vclsstr+")&("+rstr+")";

      script_exp_t plist = ScriptExpand(script, false);

      if (!CrossValScriptCorrect(plist, posiasp, "positive", tsetname) ||
          !CrossValScriptCorrect(plist, negaasp, "negative", tsetname)) {
        ok = ShowError(err+"updating aspects in script failed");
        break;
      }
      
      script_exp_t::iterator dbp = ScriptFind(plist, "database");
      if (dbp==plist.end())
        return ShowError(err+"database not found in the script");
      plist.insert(++dbp, make_pair(gt_tsetn,    tsetexpr));
      plist.insert(dbp,   make_pair(gt_tsetexpn, tsetexpexpr));

      if (!ScriptReplace(plist, "crossval",    "",          false, false) ||
          !ScriptReplace(plist, "viewclass",   vclsstr,     true,  false) ||
          !ScriptReplace(plist, "restriction", reststr,     true,  false)) {
        ok = ShowError(err+"updating script failed");
        break;
      }

      Analysis analysis(Picsom(), this, NULL, argv);
      analysis.Script(ScriptUnExpand(plist));
      analysis.BatchParameters("*crossval*="+niihvx, this);
      
      analyse_result res = analysis.Analyse();
      if (!(ok=res.ok()))
        break;

      AddToResult(res, total, false);
    }

    CheckDB()->Restriction(rstr);

    if (!ok)
      return ShowError(err+"failed");
      
    // query->DoubleLogSeparator(mstr);
    SolveAndWriteAnalyseResults("CrossVal", total, mstr, true, true);

    ConditionallyWriteResult(total);

    return total;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::CrossValScriptCorrect(script_exp_t& plist,
                                       const aspect_map_t& am,
                                       const string& name,
                                       const string& part) {
    for (aspect_map_t::const_iterator i=am.begin(); i!=am.end(); i++) {
      string aname = FormatAspectName(name, i->first);
      script_exp_t::iterator j = ScriptFind(plist, aname);
      if (j==plist.end())
        return ShowError("CrossValScriptCorrect() failed with \""+aname+"\"");
      vector<string> cls_weight = SplitInSomething("/", false, j->second); 
      string corr = "("+cls_weight[0]+")&"+part;
      if (cls_weight.size()>1)
        corr += "/"+cls_weight[1];
      if (debug_script)
        cout << "SCRIPT correcting [" << j->first << "]=[" << j->second
             << "] => [" << corr << "]" << endl;
      j->second = corr;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::CrossValidateOld() {
    string msg = "CrossValidateOld ["+method+"/"+crossval+"]";
    WriteLog(msg);

    string err = "CrossValidateOld() : ";

    if (crossval.find("old")!=0)
      return ShowError(err+"crossval specification doesn't start with old");

    string spec = crossval.substr(3);
    if (query->HasViewClass())
      return ShowError(err+"cannot handle non-empty viewclass");

    vector<string> argv = DashedExtraArguments();

    size_t n = GetDataBase()->ContentsErase("cross-val");
    WriteLog("CrossValidate: cleared contents: "+ToStr(n));

    size_t nfold = 0;
    bool do_H = false, do_V = false;
    
    if (spec!="LOO") {
      size_t p = spec.find_first_not_of("0123456789");
      if (p)
        nfold = atoi(spec.substr(0, p).c_str());
      if (spec.size()!=p+1 && spec.size()!=p+2)
        return ShowError(err+"unable to interpret [", spec, "] A");
      if (spec[p]=='H' || spec[p+1]=='H')
        do_H = true;
      if (spec[p]=='V' || spec[p+1]=='V')
        do_V = true;
      
      if (!p || (!do_H && !do_V))
        return ShowError(err+"unable to interpret [", spec, "] B");
    } else {
      // some logic is certainly still missing...
      ground_truth all = GroundTruthExpression(query->Positive());
      nfold = all.positives();
      do_H = true;
    }

    const string posi = query->Positive();
    const string nega = query->Negative();  // cannot handle this yet
    const string rstr = CheckDB()->RestrictionName();

    if (nega!="")
      WarnOnce("CrossValidate() : unable to handle negative="+nega);

    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "positive", GTExpr(posi));
    AddGroundTruthInfo(gtl, "negative", GTExpr(nega));
    // gtl.push_back(ground_truth_list_e("viewclass",   GTExpr(view)));

    string mstr;
    list<string> extra;
    AddExtraVariableInfo(extra, "crossval",        crossval);
    AddExtraVariableInfo(extra, "spec",            spec);
    AddExtraVariableInfo(extra, "batchparameters", batchparameters);
    AddExtraVariableInfo(extra, "depth",           ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack",       TaskStack());
    query->WriteAnalyseVariablesNew("CrossVal", mstr, gtl, extra);
    query->DoubleLogSeparator(mstr);

    const string nfoldstr = ToStr(nfold);
    const string rstrhdr = rstr=="" ? "~" : rstr+"\\";

    analyse_result total;
    
    bool ok = true;
    for (size_t i=0; ok && i<2*nfold; i++) {
      if ((i%2==0 && !do_H) || (i%2==1 && !do_V))
        continue;
      
      const string ii = ToStr(i/2), hv = i%2==0?"H":"V", hvx = hv+"x";
      string niihvx = nfoldstr+"-"+ii+"-"+hvx;
      string tsetname = "cross-val-"+niihvx;
      string tsetexpr = "$split("+posi+","+TargetTypeString(Target())+","
        +nfoldstr+","+ii+","+hvx+")";

      WriteLog(msg+" : "+niihvx);

      CheckDB()->SetGroundTruth(tsetname, tsetexpr); // better in script...
      
      string tsetexpname = tsetname+"-exp";
      string tsetexpexpr = "$exp("+tsetname+")";
      CheckDB()->SetGroundTruth(tsetexpname, tsetexpexpr); // ditto

      // CheckDB()->Restriction(rstrhdr+tsetexpname);  // this is an uglu duck
      
      string vclsstr = posi+"\\"+tsetname;
      string reststr = rstrhdr+tsetexpname;

      script_exp_t plist = ScriptExpand(script, false);

      ok = ok && ScriptReplace(plist, "crossval",    "",       false, false);
      ok = ok && ScriptReplace(plist, "positive",    tsetname, false, false);
      ok = ok && ScriptReplace(plist, "negative",    nega,     true,  false);
      ok = ok && ScriptReplace(plist, "viewclass",   vclsstr,  true,  false);
      ok = ok && ScriptReplace(plist, "restriction", reststr,  true,  false);

      if (!ok) {
        ShowError(err+"updating script failed");
        break;
      }

      Analysis analysis(Picsom(), this, NULL, argv);
      analysis.Script(ScriptUnExpand(plist));
      analysis.BatchParameters("*crossval*="+niihvx, this);
      
      analyse_result res = analysis.Analyse();
      if (!(ok=res.ok()))
        break;

      AddToResult(res, total, false);
    }

    CheckDB()->Restriction(rstr);

    if (!ok)
      return ShowError(err+"failed");
      
    // query->DoubleLogSeparator(mstr);
    SolveAndWriteAnalyseResults("CrossVal", total, mstr, true, true);

    ConditionallyWriteResult(total);

    return total;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::MultiFoldFeatSel(const string& optarg,
                                                      const string& rest) {
    string msg = "Analysis::MultiFoldFeatSel("+optarg+","+rest+") : ";
    bool debug = true;
    DataBase* db = CheckDB();

    int folds = 10;

    string fsopt = optarg;
    size_t cpos = rest.find(',');
    if (cpos != string::npos)
      fsopt += ","+rest.substr(0, cpos);

    size_t epos = rest.find('=', cpos+1);
    if (epos != string::npos)
      folds = atoi(rest.substr(epos+1).c_str());

    script_exp_t plist = ScriptExpand(script, false);

    bool ok =
      ScriptReplace(plist, "analyse", "featsel("+fsopt+")", false, false);

    script_exp_t::iterator it = ScriptFind(plist, "positive");
    string posstr = it->second;

    string restriction = db->RestrictionName();

    it = ScriptFind(plist, "featurechoices");
    if (it == plist.end()) 
      return ShowError(msg, "featsel without featurechoices doesn't "
                       "make any sense.");
    
    vector<string> feats = SplitInCommas(it->second);

    it = ScriptFind(plist, "features");
    if (it != plist.end()) {
      vector<string> tmp = SplitInCommas(it->second);
      feats.insert(feats.end(), tmp.begin(), tmp.end());
    }

    string cv;
    it = ScriptFind(plist, "crossval");
    if (it != plist.end()) 
      return ShowError(msg, "not implemented for crossval.");
    //   {
    //   cv = it->second;
    //   plist.erase(it);
    //   cv.erase(cv.find('/'));
    // }

    vector<analyse_result> results;

    for (int i=0; i<folds && ok; i++) {
      string ttstr = TargetTypeString(Target());
      string restr = restriction+"&$type("+ttstr+")";
      string foldstr =
        "$split("+restr+","+ttstr+","+ToStr(folds)+","+ToStr(i)+",V)";

      ok = ok &&
        ScriptReplace(plist, "restriction", foldstr, false, false) &&
        ScriptReplace(plist, "positive", posstr+"&"+foldstr, false, false);

      // if (!cv.empty()) {
      //   ScriptReplace(plist, "crossval", cv+"/"+foldstr, true, false);
      // }

      list<string> newscript = ScriptUnExpand(plist);

      if (debug)
        ScriptDump(newscript, true);

      Analysis a(Picsom(), this, NULL, DashedExtraArguments());
      a.Script(newscript); 
      analyse_result res = a.Analyse();
      res.clear_sub_results();
      
      results.push_back(res);
    }

    WriteLog(string(64, '='));
    WriteLog(msg+"finished.");

    map<string, float> feat_weights;
    for (size_t i=0; i<feats.size(); i++)
      feat_weights[feats[i]] = 0.0;
    float sum = 0.0;

    for (size_t i=0; i<results.size(); i++) {
      string key, value;
      if (!SplitKeyEqualValue(results[i].params, key, value) ||
          key != "features")
        return ShowError(msg, "Bad analyse_result param:"+results[i].params);

      vector<string> ff = SplitInCommas(value);
      
      for (size_t j=0; j<ff.size(); j++) {
        map<string, float>::iterator it = feat_weights.find(ff[j]);
        if (it == feat_weights.end())
          return ShowError(msg, "Feature not in featurechoices or "
                           "features given: "+ff[j]);
        float w = 1.0;
        it->second += w;
        sum += w;
      }

      WriteLog("   Fold "+ToStr(i+1)+"/"+ToStr(folds)+": "+value);
    }

    string fstr;
    map<string, float>::iterator fit = feat_weights.begin();
    for (; fit != feat_weights.end(); fit++) {
      fit->second /= sum;
      fstr += (fstr.empty()?"":",")+fit->first+"("+ToStr(fit->second)+")";
    }

    WriteLog("   Final weights: "+fstr);

    return true;
  }
  
  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::MultipleFeatSel(const string& optarg,
                                                     const string& rest) {
    string msg = "Analysis::MultipleFeatSel("+optarg+","+rest+") : ";
    bool debug = true;

    vector<string> methods = SplitInSomething("+", false, rest);

    script_exp_t plist = ScriptExpand(script, false);
    script_exp_t::iterator it = ScriptFind(plist, "analyse");

    analyse_result best_res;
    pair<float,float> best_opt = make_pair(0.0,0.0);
    
    for (size_t i=0; i<methods.size(); i++) {

      it->second = "featsel("+optarg+","+methods[i]+")";

      list<string> newscript = ScriptUnExpand(plist);

      if (debug)
        ScriptDump(newscript, true);

      Analysis a(Picsom(), this, NULL, DashedExtraArguments());
      a.Script(newscript); 
      analyse_result res = a.Analyse();

      pair<float, float> opt = a.OptimizeValue(res);
      if (opt.second < best_opt.second) {
        best_res = res;
        best_opt = opt;
      }
    }
    best_res.clear_sub_results();

    WriteLog(msg, "search finished.");
    WriteLog("   best overall combination was: ", best_res.params);

    return best_res;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseFeatSel(const vector<string>&
                                                    args) {
    string msg = "Analysis::AnalyseFeatSel() : ";

    bool do_weighting=false;

    bool earlystop=true;

    bool do_tuning=false;

    const float minImprovement=0.0; //0.0015; // fraction

    map<string,float> weights;
    
    // get optimize argument (eg. best) from args
    // clean away comma-separated keywords
    string optarg;
    enum search_method {sfs,sbs,sfbs,exhaustive};

    search_method searchMethod=sfs;
    bool start_from_full = false;

    for (size_t i=0; i<args.size(); i++) {
      const string& str = args[i];
      size_t last = str.size()-1;
      if (str[0] == '(' && str[last] == ')') {
        optarg = str.substr(1,last-1);
        size_t commapos=optarg.find(',');
        if(commapos!=string::npos){
          string rest=optarg.substr(commapos+1);
          optarg = optarg.substr(0,commapos);

          if (rest.find("multifold")!=string::npos)
            return MultiFoldFeatSel(optarg, rest);

          if (rest.find("+")!=string::npos)
            return MultipleFeatSel(optarg, rest);

          if(rest.find("sbs")!=string::npos)
            searchMethod = sbs;
          if (rest.find("sfbs")!=string::npos)
            searchMethod = sfbs;
          if(rest.find("exhaustive")!=string::npos)
            searchMethod = exhaustive;
          if(rest.find("weight")!=string::npos)
            do_weighting=true;
          if(rest.find("tune")!=string::npos){
            do_weighting=true; // tuning implies weighting
            do_tuning=true;
          }
          
          if (rest.find("-full") != string::npos) {
            start_from_full = true;
          }
        }

        break;
      }
    }

    vector<string> argv = DashedExtraArguments();
    
    list<string> before, feats, weightstrings;
    script_exp_t plist = ScriptExpand(script, false);
    
    // generate before list, get starting features list if it exists
    for (list< pair<string,string> >::iterator i=plist.begin(); 
         i!=plist.end(); i++) {
      if (i->first == "features") {
        string featstr = i->second;
        if(!featstr.empty())
          feats = ExpandFeaturesString(featstr);
        continue;
      } 
      else if (do_weighting && i->first.substr(0,7)=="weight("){
        string str=i->first.substr(7);
        size_t last = str.size()-1;
        
        //        cout << "weight statement found, str="<<str<<" , second="<<i->second<<endl;

        if (str[last] == ')'){ 
          float w;
          sscanf(i->second.c_str(),"%f",&w);
          weights[str.substr(0,last)]=w;
          //          cout << "parsed weight "<<w<<" for feat "<<str.substr(0,last)<<endl;
        }

        continue;
      }
      else if (i->first == "featurechoices")
        continue;
      else if (i->first == "analyse") {
        i->second = optarg;
      }
      before.push_back(i->first+"="+i->second);
    }

    // generate local list of feature choices, remove features that
    // are already in starting list

    list<string> fchoices = RemoveListIntersection(featurechoices, feats);

    // obs! HAS_CBIRALGORITHM_NEW problem:
    if (!CheckQuery()->SelectIndices(NULL, fchoices))
      return ShowError("AnalyseFeatSel() : SelectIndices() failed");

    pair<float,float> opt;
    pair<float,float> o_opt;
    int round=1;

    if (searchMethod==sbs || start_from_full) {
      feats.insert(feats.end(),fchoices.begin(),fchoices.end()); 
      // backward search starts from full feature list
    }

    if(do_weighting){
      // augment feature names with weights

      list<string>::iterator it;
      for(it=feats.begin();it!=feats.end();it++){
        if(weights.count(*it)==0)
          weights[*it]=1.0;

         char weightstr[80];
         sprintf(weightstr,"weight(%s)=%f",it->c_str(),weights[*it]);
         weightstrings.push_back(weightstr);
      }

      for(it=fchoices.begin();it!=fchoices.end();it++){
        weights[*it]=1.0;
        //*it += "(weight=1.0)";
      }
    }

    WriteLog(string(64, '='));
    while (true) {
      switch(searchMethod){
      case sfs:

        WriteLog("AnalyseFeatSel: sfs starting round ",ToStr(round));
        WriteLog("  with initial features : ",JoinFeaturesString(feats));
        WriteLog("  and feature choices   : ",JoinFeaturesString(fchoices));
        WriteLog(string(64, '='));
        break;
      case sbs:
        WriteLog("AnalyseFeatSel: sbs starting round ",ToStr(round));
        WriteLog("  with initial features : ",JoinFeaturesString(feats));
        WriteLog("  and feature choices   : ",JoinFeaturesString(fchoices));
        WriteLog(string(64, '='));
        break;
      case sfbs:
        WriteLog("AnalyseFeatSel: sfbs starting round ",ToStr(round));
        WriteLog("  with initial features : ",JoinFeaturesString(feats));
        WriteLog("  and feature choices   : ",JoinFeaturesString(fchoices));
        WriteLog(string(64, '='));
        break;
      case exhaustive:
        WriteLog("AnalyseFeatSel: exhaustive search starting ",ToStr(round));
        WriteLog("  with fixed features : ",JoinFeaturesString(feats));
        WriteLog("  and feature choices   : ",JoinFeaturesString(fchoices));
        WriteLog(string(64, '='));
        break;
      default:
        throw string("Analysis::AnalyseFeatSel() : "
                     "search method not implemented."); 
      }
      //if(do_weighting){
      //        weightstrings.clear();
      //        list<string>::iterator it;
      //        for(it=fchoices.begin();it!=fchoices.end();it++){
      //          char weightstr[80];
      //          sprintf(weightstr,"weight(%s)=%f",it->c_str(),weights[*it]);
      //          weightstrings.push_back(weightstr);
      //        }
      //      }

      // populate after list with feature choices
      // and possibly with weights

      list<string> after;
      string btype;
      
      string weightstring;
      list<string>::iterator it;
      for(it=weightstrings.begin();it!=weightstrings.end();it++)
        weightstring += " ; " + *it;

      switch (searchMethod) {
      case sfs:
        if (round==1&&feats.size()) {
          string entry="features="+JoinFeaturesString(feats);
          if(do_weighting) 
            entry += weightstring;
          after.push_back(entry);
          //btype = "*MAX*";

        } else if (fchoices.size()>1) {
          for (list<string>::const_iterator fiter=fchoices.begin(); 
               fiter!=fchoices.end(); fiter++){
            string entry="* features="+JoinFeaturesString(feats,*fiter);
            if(do_weighting)
              entry += weightstring+" ; weight("+*fiter+")=1";
            after.push_back(entry);
          }
          if (!fchoices.empty())
            btype = "*MAX*";

        } else if (fchoices.size()) {
          string entry="features="+JoinFeaturesString(feats,
                                                      fchoices.front());

          if (do_weighting)
            entry += weightstring+" ; weight("+fchoices.front()+")=1";
          after.push_back(entry);

        } else
          throw string("Analysis::AnalyseFeatSel() : sfs with empty fchoices");

        break;

      case sbs:
        if (round==1) {
          after.push_back("features="+JoinFeaturesString(feats));
          //btype = "*MAX*";

        } else if (fchoices.size() > 1) {
          for (list<string>::const_iterator fiter=fchoices.begin(); 
               fiter!=fchoices.end(); fiter++){
            list<string> oneitem;
            oneitem.push_back(*fiter);
            after.push_back("* features="+
                    JoinFeaturesString(RemoveListIntersection(feats,oneitem)));
          }
          if (!fchoices.empty())
            btype = "*MAX*";

        } else {
          list<string> oneitem;
          oneitem.push_back(fchoices.front());
          after.push_back("features="+
                    JoinFeaturesString(RemoveListIntersection(feats,oneitem)));
        }
        break;

      case sfbs:
        fchoices = RemoveListIntersection(featurechoices,feats);

        if (round==1 && feats.size()) {
          after.push_back("features="+JoinFeaturesString(feats));
        } else {
          for (list<string>::const_iterator fiter=fchoices.begin(); 
               fiter!=fchoices.end(); fiter++) {
            after.push_back("* features="+JoinFeaturesString(feats,*fiter));
          }

          if (feats.size() > 1) {
            for (list<string>::const_iterator fiter=feats.begin(); 
                 fiter!=feats.end(); fiter++){
              list<string> oneitem;
              oneitem.push_back(*fiter);
              string featstr =
                JoinFeaturesString(RemoveListIntersection(feats,oneitem));
              after.push_back("* features="+featstr);
            }
          }

          btype = "*MAX*";
        }

        break;

      case exhaustive:
        {
          size_t s=fchoices.size();
          if(s>20)
            throw string("Analysis::AnalyseFeatSel() : too many choices for "
                         "exhaustive search.");
          if(s>0){
            vector<string> fchoices_vec;
            fchoices_vec.insert(fchoices_vec.end(),fchoices.begin(),
                                 fchoices.end());
            for(unsigned int mask=0;mask<(unsigned)(1<<s);mask++){
              if(mask==0 && feats.empty()) continue;
              list<string> tmpfeatlist=feats;
              //cout << "feats.size()="<<feats.size()<<" mask="<<mask<<endl;
              for(size_t j=0;j<s;j++)
                if(mask&(1<<j)) tmpfeatlist.push_back(fchoices_vec[j]);
              after.push_back("* features="+JoinFeaturesString(tmpfeatlist));
            }
            if (!fchoices.empty())
              btype = "*MAX*";
          } else
            after.push_back("features="+JoinFeaturesString(feats));
        }
        break;

      default:
        throw string("Analysis::AnalyseFeatSel() : search method not "
                     "implemented.");
      }            
      
      // run script

      Analysis analysis(Picsom(), this, NULL, argv);
      // cout << "About to run script, before is " << endl;
      // for(list<string>::iterator it=before.begin();it!=before.end();it++)
      //   cout << "  "<<*it << endl;

      list<string> scr=ScriptJoinBlocks(before,btype,after);

      // cout << "Setting script to " << endl;
      // for(list<string>::iterator it=scr.begin();it!=scr.end();it++)
      //   cout << "  "<<*it << endl;
      
      analysis.Script(scr);
      
      analyse_result res = analysis.Analyse();
      if (!res.ok())
        return ShowError("AnalyseFeatSel() : Analyse() failed");
      
      opt = analysis.OptimizeValue(res);

      string best;
      switch(searchMethod){
      case sfs:        
        best= ((feats.empty()||round>1) && fchoices.size()>1) ? res.params : 
          after.front();
        break;
      case sbs:
        best= (round>1 && fchoices.size()>1) ? res.params : after.front();
        break;
      case sfbs:
        // best= ((feats.empty()||round>1) && fchoices.size()>1) ? res.params : 
        //   after.front();
        best = (round==1 && feats.size()) ? after.front() : res.params;
        // best = res.params;
        break;
      case exhaustive:
        best= res.params;
        break;
      }

      if(do_weighting){
        // strip away the weight part
        // cout <<"stripping away weight part" << endl;
        size_t p = best.find_first_of(" \t;");
        if (p==string::npos)
          return ShowError("AnalyseFeatSel() : weight part not found in\""+
                         best+"\"");
        best=best.substr(0,p);
      }

      string logbest = best;
        
      size_t fp = best.find("features=");
      if (fp==string::npos)
        return ShowError("AnalyseFeatSel() : Bad batch parameter=\""+
                         best+"\"");

      best = best.erase(0, fp+9); // cut off "features="
      fp = best.find_first_of(" \t;");
      if (fp!=string::npos)
        best.erase(fp);

      WriteLog(string(64, '='));
      WriteLog("AnalyseFeatSel: best combination was: ", logbest);

      if(do_weighting && searchMethod==sfs && round>1){
        list<string> bestfeats=ExpandFeaturesString(best);
        list<string> diff=RemoveListIntersection(bestfeats,feats);
        string new_feat=diff.front();
        string newbase=new_feat.substr(0,new_feat.find('('));

        WriteLog("AnalyseFeatSel: tuning weight for feature ", new_feat);

        optEvaluator eval(&analysis,&before,&feats,&new_feat,&weightstring);

        float p0=o_opt.first;
        float p3=opt.first;

        // bracket maximum

        float ax,bx,cx;
        float fa,fb,fc;

        ax=0; bx=1;    // initial interval [0,1]
        fa=-p0; fb=-p3;  // we know already fvals at endpoints

        mnbrak(&ax,&bx,&cx,&fa,&fb,&fc,&eval);

        float ploc;
        float tol=fabs(cx-ax)/5+0.01;
        cout << "using tolerance " << tol << endl;

        // float pval=golden(ax,bx,cx,&eval,tol,&ploc,fb);
        float pval=brent(ax,bx,cx,&eval,tol,&ploc,fb);

        opt=pair<float,float>(-pval,pval);
        res=eval.bestresult;
        weights[newbase]=ploc;
        
        char weightstr[80];
        sprintf(weightstr,"weight(%s)=%f",newbase.c_str(),weights[newbase]);
        weightstrings.push_back(weightstr);

        cout << "best weight was "<<weights[newbase]<<endl;

      }

      if (round>1 && opt.second >= o_opt.second) {
        WriteLog("AnalyseFeatSel: breaking because result declined...");
        WriteLog("   ",ToStr(opt.first)," not better than ",
                 ToStr(o_opt.first));
        WriteLog("   best overall combination was: ",
                 JoinFeaturesString(feats));
        if (weightstrings.size())
          weightstrings.pop_back();
        break;
      }
      else if (earlystop && round>1 && (opt.first-o_opt.first)/(1-o_opt.first) <= minImprovement) {
        WriteLog("AnalyseFeatSel: breaking because result didn't improve enough");
        WriteLog("   ",ToStr(opt.first)," not much better than ",
                 ToStr(o_opt.first));
        WriteLog("   best overall combination was: ",
                 JoinFeaturesString(feats));
        if (weightstrings.size())
          weightstrings.pop_back();
        break;
      }

      o_opt = opt;
      result = res;
      result.clear_sub_results();

      if(searchMethod==exhaustive){
        WriteLog("AnalyseFeatSel: exhaustive search finished.");
        WriteLog("   best overall combination was: ", best);
        break;
      }

      feats = ExpandFeaturesString(best);

      switch(searchMethod){
      case sfs:
        fchoices = RemoveListIntersection(fchoices,feats);
        break;
      case sbs:
        fchoices = ListIntersection(fchoices,feats);
        break;
      case sfbs:
        // fchoices = RemoveListIntersection(fchoices,feats);
        break;
      default:
        throw string("Analysis::AnalyseFeatSel() : search method not "
                     "implemented.");
      }

      if (searchMethod!=sfbs && fchoices.empty()) {
        WriteLog("AnalyseFeatSel: no more choices, breaking...");
        WriteLog("   best overall combination was: ", best);
        break;
      }

      if (searchMethod==sbs && fchoices.size()==1) {
        WriteLog("AnalyseFeatSel: no more choices, breaking...");
        WriteLog("   best overall combination was: ", best);
        break;
      }

      round++;
    }

    // WriteLog(string(64, '='));
    WriteAnalyseResults("FeatSel", result, "", true, true);
    if(do_weighting){
      cout << "best weights" << endl;
      list<string>::iterator it;
      for(it=weightstrings.begin();it!=weightstrings.end();it++)
        cout << "  "<<*it <<endl;
    }

    if(do_tuning){

      analyse_result res;


      cout << "tuning weights" << endl;
      float incr;
      do{
        float oldperf=opt.first;
        
        list<string>::iterator it,it2;
        
        for(it=feats.begin();it!=feats.end();it++){
          Analysis analysis(Picsom(), this, NULL, argv);
          string new_feat=*it;
          
          list<string> otherfeats;
          string weightstring;
          for(it2=feats.begin();it2!=feats.end();it2++){
            if(*it!=*it2){
              otherfeats.push_back(*it2);
              char weightstr[80];
              sprintf(weightstr," ; weight(%s)=%f",it2->c_str(),weights[*it2]);
              weightstring += weightstr;
            }
          }
        
          string newbase=new_feat.substr(0,new_feat.find('('));

          float oldw=weights[*it];

          WriteLog("AnalyseFeatSel: tuning weight for feature ", new_feat);
          
          optEvaluator eval(&analysis,&before,&otherfeats,&new_feat,&weightstring);

          float p0=-eval.eval(0);
          float pold=opt.first;

          cout << "pold=" << pold<<endl;

        // bracket maximum

          float ax,bx,cx;
          float fa,fb,fc;

          ax=0; bx=oldw;    // initial interval [0,oldw]
          fa=-p0; fb=-pold;  // we know already fvals at endpoints

          mnbrak(&ax,&bx,&cx,&fa,&fb,&fc,&eval);

          cout << "got bracket ("<<ax<<" "<<bx<<" "<<cx<<")"<<endl;
          cout << "fvals ("<<fa<<" "<<fb<<" "<<fc<<")"<<endl;

          float ploc;
          float tol=0.4*(fabs(cx-ax)/5+0.01);
          cout << "using tolerance " << tol << endl;

          // float pval=golden(ax,bx,cx,&eval,tol,&ploc,fb);
          float pval=brent(ax,bx,cx,&eval,tol,&ploc,fb);

          opt=pair<float,float>(-pval,pval);
          res=eval.bestresult;
          weights[newbase]=ploc;
        
          cout << "best weight was "<<weights[newbase]<<endl;
          cout << "best performance: " << pval;

        }

      incr=(opt.first-oldperf)/(1-oldperf);
      } while(incr>minImprovement);

      result = res;
      result.clear_sub_results();

      WriteAnalyseResults("FeatSel", result, "", true, true);
      cout << "best weights" << endl;

      list<string>::iterator it;
      for(it=feats.begin();it!=feats.end();it++){
        char weightstr[80];
        sprintf(weightstr,"weight(%s)=%f",it->c_str(),weights[*it]);
        cout << weightstr << endl;
      }
    }

    return result;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::Analyse() {
    string hdr = "Analysis::Analyse() : ";

    PicSOM::ThreadTestCancel();

    bool do_crossval = true; // used to be false until 23.3.2006

    if (ScriptHasChoices())
      return Optimize();

    ScriptExecuteAndShow();

    if (!query)
      return ShowError(hdr+"query==NULL");

    if (method=="")
      return xml_result.DocOK() ? true :
        ShowAnalyseUsage("No analyse type specified.");

    if (method=="create") {
      if (!Depth())
        return Create(rest_argv_str);
      else {
	// this is the way slave anaysis are run... don't remember why...
        Analysis a(Picsom(), this, NULL, Picsom()->CmdLineArgs());
        a.Script(script);
        a.ScriptExecuteAndShow();  // this used to be in Create()
        analyse_result res = a.Create(rest_argv_str);

	a.CopyXmlResultTo((Analysis*)parent);

        return res;
      }
    }

    if (method=="insert") {
      Tic("Analyse_insert");
      bool ret = Insert();
      Tac("Analyse_insert");
      return ret;
    }

    /// Methods that don't need some specification should set these to false!
    bool tt_needed = true, db_needed = true, features_needed = true;
    bool cls_needed = false, query_needed = false;
    bool ifile_preferred = !InServer();

    analyse_result (Analysis::*func)(const vector<string>&) = NULL;

    vector<string> args;
    string method_x = method, n, a;
    if (SplitParentheses(method, n, a)) {
      method_x = n;
      args.push_back("("+a+")");
    }
    args.insert(args.end(), rest_argv_str.begin(), rest_argv_str.end());

    if (method_x=="dummy") {
      func = &Analysis::AnalyseDummy;
      tt_needed = db_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="env") {
      func = &Analysis::AnalyseEnv;
      tt_needed = db_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="sleep") {
      func = &Analysis::AnalyseSleep;
      tt_needed = db_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="caffeconvertimageset") {
      func = &Analysis::AnalyseCaffeConvertImageset;
      // all diagnostics are deferred
      tt_needed = features_needed = ifile_preferred = false;
      cls_needed = true;
    }
    else if (method_x=="query") {
      func = &Analysis::AnalyseQuery;
      // all diagnostics are deferred
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="gt") {
      func = &Analysis::AnalyseGT;
      cls_needed = true;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="metaclassfile") {
      func = &Analysis::AnalyseMetaClassFile;
      cls_needed = true;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="createclassfile") {
      func = &Analysis::AnalyseCreateClassFile;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="createlabelmap") {
      func = &Analysis::AnalyseCreateLabelMap;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="checksums") {
      func = &Analysis::AnalyseCheckSums;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="dtw") {
      func = &Analysis::AnalyseDTW;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="suvivk") {
      func = &Analysis::AnalyseSuviVk;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="suvibenchmark") {
      func = &Analysis::AnalyseSuviBenchmark;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="lscom") {
      func = &Analysis::AnalyseLscom;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="ontology") {
      func = &Analysis::AnalyseOntology;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="defineclass") {
      func = &Analysis::AnalyseDefineClass;
      cls_needed = true;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="erfdata") {
      func = &Analysis::AnalyseErfData;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="display") {
      func = &Analysis::AnalyseDisplay;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="extractmedia") {
      func = &Analysis::AnalyseExtractMedia;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="extractvideothumbnails") {
      func = &Analysis::AnalyseExtractVideoThumbnails;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="extractlfwfaces") {
      func = &Analysis::AnalyseExtractLfwFaces;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="extractrawfeatures") {
      func = &Analysis::AnalyseExtractRawFeatures;
      ifile_preferred = false;
    }
    else if (method_x=="objectinfo" || method_x=="extract") {
      func = &Analysis::AnalyseObjectInfo;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="nextfreelabel") {
      func = &Analysis::AnalyseNextFreeLabel;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="slavetest") {
      func = &Analysis::AnalyseSlaveTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="gvttest") {
      func = &Analysis::AnalyseGvtTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="odtest") {
      func = &Analysis::AnalyseOdTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="objectsettest") {
      func = &Analysis::AnalyseObjectSetTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="opencvtest") {
      func = &Analysis::AnalyseOpenCvTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="cudatest") {
      func = &Analysis::AnalyseCudaTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="pythontest") {
      func = &Analysis::AnalysePythonTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="tensorflowtest") {
      func = &Analysis::AnalyseTensorFlowTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="jaulatest") {
      func = &Analysis::AnalyseJaulaTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="tfidftest") {
      func = &Analysis::AnalyseTfIdfTest;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="wordnettest") {
      func = &Analysis::AnalyseWordNetTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="visualgenometest") {
      func = &Analysis::AnalyseVisualGenomeTest;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="word2vectest") {
      func = &Analysis::AnalyseWord2VecTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="translatetest") {
      func = &Analysis::AnalyseTranslateTest;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="sparqltest") {
      func = &Analysis::AnalyseSparqlTest;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="rdftest") {
      func = &Analysis::AnalyseRdfTest;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="types") {
      func = &Analysis::AnalyseTypes;
      features_needed = false;
    }
    else if (method_x=="labelhash") {
      func = &Analysis::AnalyseLabelHash;
      features_needed = false;
    }
    else if (method_x=="rgb") {
      func = &Analysis::AnalyseRgb;
      ifile_preferred = false;
    }
    else if (method_x=="conv") {
      func = &Analysis::AnalyseConv;
      ifile_preferred = false;
    }
    else if (method_x=="mi")
      func = &Analysis::AnalyseMI;
  
    else if (method_x=="div") {
      func = &Analysis::AnalyseDiv;
      ifile_preferred = false;
    }
    else if (method_x=="divold")
      func = &Analysis::AnalyseDivOld;

    else if (method_x=="somvalues") {
      func = &Analysis::AnalyseSomValues;
      tt_needed = false;
    }
    else if (method_x=="imagefile") {
      func = &Analysis::AnalyseImageFile;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="imagenet") {
      func = &Analysis::AnalyseImageNet;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="mapclassprob") {
      func = &Analysis::AnalyseMapClassProbability;
      ifile_preferred = false;
    }
    else if (method_x=="maparea")
      func = &Analysis::AnalyseMapArea;

    else if (method_x=="colornames") {
      func = &Analysis::AnalyseColorNames;
      tt_needed = db_needed = features_needed = false;
    }
    else if (method_x=="mapcollage")
      func = &Analysis::AnalyseMapCollage;

    else if (method_x=="randomcollage") {
      func = &Analysis::AnalyseRandomCollage;
      features_needed = false;
    }
    else if (method_x=="createcollage") {
      func = &Analysis::AnalyseCreateCollage;
      features_needed = false;
    }
    else if (method_x=="createvideocollage") {
      func = &Analysis::AnalyseCreateVideoCollage;
      tt_needed = features_needed = false;
    }
    else if (method_x=="gazetrace") {
      func = &Analysis::AnalyseGazeTrace;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="gazerelevance") {
      func = &Analysis::AnalyseGazeRelevance;
      tt_needed = features_needed = ifile_preferred = false;
    }
  
    else if (method_x=="finlandiakatsaus") {
      func = &Analysis::AnalyseFinlandiaKatsaus;
      tt_needed = features_needed = ifile_preferred = false;
    }

    else if (method_x=="shotboundarythreshold") {
      func = &Analysis::AnalyseShotBoundaryThreshold;
      tt_needed = features_needed = ifile_preferred = false;
    }

    else if (method_x=="shotboundary") {
      func = &Analysis::AnalyseShotBoundary;
      tt_needed = features_needed = ifile_preferred = false;
    }

    else if (method_x=="shotboundarytrecvid")
      func = &Analysis::AnalyseShotBoundaryTrecvid;

    else if (method_x=="shotboundaryparams")
      func = &Analysis::AnalyseShotBoundaryParams;
  
    else if (method_x=="trecvidsindevel") {
      func = &Analysis::AnalyseTrecvidSINdevel;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="trecvidsinweights") {
      func = &Analysis::AnalyseTrecvidSINweights;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="trecvidiframes") {
      func = &Analysis::AnalyseTrecvidIframes;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="treceval") {
      func = &Analysis::AnalyseTrecEval;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="trecvidmedoutput") {
      func = &Analysis::AnalyseTrecvidMedOutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="trecvidsinoutput") {
      func = &Analysis::AnalyseTrecvidSinOutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="trecvidlocoutput") {
      func = &Analysis::AnalyseTrecvidLocOutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="trecvidvttoutput") {
      func = &Analysis::AnalyseTrecvidVttOutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="cocooutput") {
      func = &Analysis::AnalyseCOCOoutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="lsmdcoutput") {
      func = &Analysis::AnalyseLSMDCoutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="imagenetoutput") {
      func = &Analysis::AnalyseImageNetOutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="vocoutput") {
      func = &Analysis::AnalyseVocOutput;
      tt_needed = features_needed = ifile_preferred = false;
      cls_needed = true;

    } else if (method_x=="ylejsonoutput") {
      func = &Analysis::AnalyseYleJsonOutput;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="evaluatedetections") {
      func = &Analysis::AnalyseEvaluateDetections;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="evaluatedetectionswiththresholds") {
      func = &Analysis::AnalyseEvaluateDetectionsWithThresholds;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="showtopdetections") {
      func = &Analysis::AnalyseShowTopDetections;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="dumpdetections") {
      func = &Analysis::AnalyseDumpDetections;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="selectthresholds") {
      func = &Analysis::AnalyseSelectThresholds;
      tt_needed = features_needed = ifile_preferred = false;

    } else if (method_x=="spread")
      func = &Analysis::AnalyseSpread;
  
    else if (method_x=="vote") {
      func = &Analysis::AnalyseVote;
      ifile_preferred = false;
      cls_needed = true;
    }
    else if (method_x=="classsim") {
      func = &Analysis::AnalyseClassSim;
      features_needed = false;
      ifile_preferred = false;
      cls_needed = true;
    }
    else if (method_x=="classification") {
      func = &Analysis::AnalyseClassification;
      features_needed = false;
      cls_needed = true;
      ifile_preferred = false;
    }
    else if (method_x=="classify" || method_x=="knn") {
      func = &Analysis::AnalyseClassify;
      cls_needed = true;
      ifile_preferred = false;
    }
    else if (method_x=="knnold") {
      func = &Analysis::AnalyseKnnOld;
      cls_needed = true;
      ifile_preferred = false;
    }
    else if (method_x=="featclassify" || method_x=="featureclassify") {
      func = &Analysis::AnalyseFeatureClassify;
      cls_needed = true;
      ifile_preferred = false;
    }
    else if (method_x=="twoclassnew") {
      func = &Analysis::AnalyseTwoClass;
      ifile_preferred = false;
    }
    else if (method_x=="twoclass") { // was also "detect"
      func = &Analysis::AnalyseTwoClassOld;
      ifile_preferred = false;
    }
    else if (method_x=="kmeans") {
      func = &Analysis::AnalyseKMeans;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="vectorquantize") {
      func = &Analysis::AnalyseVectorQuantize;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="createhistograms") {
      func = &Analysis::AnalyseCreateHistograms;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="findhistogrammatches") {
      func = &Analysis::AnalyseFindHistogramMatches;
      db_needed = tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="kmeanshistograms") {
      func = &Analysis::AnalyseKMeansHistograms;
      ifile_preferred = false;
    }
    else if (method_x=="pairdistances") {
      func = &Analysis::AnalysePairDistances;
      ifile_preferred = false;
    }
    else if (method_x=="cluster") {
      func = &Analysis::AnalyseCluster;
      ifile_preferred = false;
    }
    else if (method_x=="tau" || method_x=="simulate") {
      func = &Analysis::AnalyseSimulate;
      cls_needed = true;
      ifile_preferred = false;
    }
    else if (method_x=="best") {
      func = &Analysis::AnalyseBest;
      ifile_preferred = false;
    }
    else if (method_x=="retrieve") {
      func = &Analysis::AnalyseRetrieve;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="bmucoord") {
      func = &Analysis::AnalyseBMUcoord;
      ifile_preferred = false;
    }
    else if (method_x=="videoannotate") {
      func = &Analysis::AnalyseVideoAnnotate;
      tt_needed = false;
    }
    else if (method_x=="videotimeline") {
      func = &Analysis::AnalyseVideoTimeline;
      tt_needed = features_needed = false;
    }
    else if (method_x=="videosummary") {
      func = &Analysis::AnalyseVideoSummary;
      tt_needed = ifile_preferred = false;
    }
    else if (method_x=="videoshotsequence") {
      func = &Analysis::AnalyseVideoShotSequence;
      tt_needed = ifile_preferred = false;
    }
    else if (method_x=="videocopydetection" || method_x=="vcd") {
      func = &Analysis::AnalyseVideoCopyDetection;
      tt_needed = ifile_preferred = false;
    }
    else if (method_x=="extractkeyframes") {
      func = &Analysis::AnalyseExtractKeyFrames;
      features_needed = false;
      tt_needed = ifile_preferred = false;
    }
    else if (method_x=="insertframes") {
      func = &Analysis::AnalyseInsertFrames;
      features_needed = false;
      tt_needed = ifile_preferred = false;
    }
    else if (method_x=="subtitles") {
      func = &Analysis::AnalyseSubtitles;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="subtitlesold") {
      func = &Analysis::AnalyseSubtitlesOld;
      tt_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="elanize") {
      func = &Analysis::AnalyseElanize;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="fixorigins") {
      func = &Analysis::AnalyseFixOrigins;
      features_needed = false;
      tt_needed = ifile_preferred = false;
    } 
    else if (method_x=="featsel") {
      func = &Analysis::AnalyseFeatSel;
      ifile_preferred = false;
      features_needed = false;
      do_crossval = false;
    }
    else if (method_x=="class")
      func = &Analysis::AnalyseClass;
  
    else if (method_x=="fill") {
      func = &Analysis::AnalyseFill;
      query_needed = true;
      tt_needed = db_needed = features_needed = ifile_preferred = false;
    }
    else if (method_x=="interactive") {
      func = &Analysis::AnalyseInteractive;
      ifile_preferred = false;
      features_needed = false;
      cls_needed = true;
    }
    else if (method_x=="search") {
      func = &Analysis::AnalyseSearch;
      ifile_preferred = false;
      features_needed = false; //!InServer();
      tt_needed = !InServer();
    }
    else if (method_x=="concattext") {
      func = &Analysis::AnalyseConcatText;
      cls_needed = true;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="obsprob") {
      func = &Analysis::AnalyseObsProb;
      cls_needed = true;
      ifile_preferred = false;
    }
    else if (method_x=="fillzerofeaturedata") {
      func = &Analysis::AnalyseFillZeroFeatureData;
      ifile_preferred = false;
    }
    else if (method_x=="featuredata") {
      func = &Analysis::AnalyseFeatureData;
      ifile_preferred = false;
    }
    else if (method_x=="nearest") {
      func = &Analysis::AnalyseNearest;
      ifile_preferred = false;
    }
    else if (method_x=="detectordifference") {
      func = &Analysis::AnalyseDetectorDifference;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="detectorperformance") {
      func = &Analysis::AnalyseDetectorPerformance;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="detectiondata") {
      func = &Analysis::AnalyseDetectionData;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="detectionstats") {
      func = &Analysis::AnalyseDetectionStats;
      cls_needed = true;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="detectionstofeatures") {
      func = &Analysis::AnalyseDetectionsToFeatures;
      features_needed = ifile_preferred = false;
    }
    else if (method_x=="value") {
      func = &Analysis::AnalyseValue;
      cls_needed = true;
    }
    else if (method_x=="eigdim") {
      func = &Analysis::AnalyseEigDim;
      ifile_preferred = false;
    }
    else if (method_x=="siblings") {
      func = &Analysis::AnalyseSiblings;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="bmus") {
      func = &Analysis::AnalyseBMUs;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="focus") {
      func = &Analysis::AnalyseFocus;
      ifile_preferred = false;
    }
    else if (method_x=="viewxy") {
      func = &Analysis::AnalyseViewXY;
      cls_needed = true;
      ifile_preferred = features_needed = tt_needed = false;
    }
    else if (method_x=="post") {
      func = &Analysis::AnalysePost;
      db_needed = cls_needed = ifile_preferred = features_needed = false;
      tt_needed = query_needed = false;
    }
    else if (method_x=="segmenthistogram") {
      func = &Analysis::CreateSegmentHistogram;
      ifile_preferred = false;
    }
    else if (method_x=="concatmapcoord") {
      func = &Analysis::ConcatMapCoord;
      ifile_preferred = false;
    }
    else if (method_x=="divstats") {
      func = &Analysis::DivStats;
      ifile_preferred = false;
    }
    else if (method_x=="videostream") {
      func = &Analysis::AnalyseVideoStream;
      ifile_preferred = tt_needed = db_needed = features_needed = false;
    }
    else if (method_x=="convertdiv") {
      func = &Analysis::AnalyseConvertDiv;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="ajax") {
      func = &Analysis::AnalyseAjax;
      ifile_preferred = tt_needed = db_needed = features_needed = false;
    }
#if defined(HAVE_CAFFE_CAFFE_HPP) && defined(PICSOM_USE_CAFFE)
    else if (method_x=="createleveldb") {
      func = &Analysis::AnalyseCreateLevelDB;
      ifile_preferred = false;
    }
    else if (method_x=="caffetest") {
      func = &Analysis::AnalyseCaffeTest;
      ifile_preferred = features_needed = false;
    }
#endif // HAVE_CAFFE_CAFFE_HPP && PICSOM_USE_CAFFE
#if defined(CAFFE2_VERSION) && defined(PICSOM_USE_CAFFE2)
    else if (method_x=="caffe2test") {
      func = &Analysis::AnalyseCaffe2Test;
      ifile_preferred = db_needed = features_needed = false;
    }
#endif // CAFFE2_VERSION && PICSOM_USE_CAFFE2
#if defined(HAVE_THC_H) && defined(PICSOM_USE_TORCH)
    else if (method_x=="torchtest") {
      func = &Analysis::AnalyseTorchTest;
      ifile_preferred = features_needed = false;
    }
#endif // HAVE_THC_H && PICSOM_USE_TORCH
    else if (method_x=="mathtest") {
      func = &Analysis::AnalyseMathTest;
      ifile_preferred = db_needed = tt_needed = features_needed = false;
    }
    else if (method_x=="neuraltalktest") {
      func = &Analysis::AnalyseNeuraltalkTest;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="sqltest") {
      func = &Analysis::AnalyseSqlTest;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="sqldump") {
      func = &Analysis::AnalyseSqlDump;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="sqlfile") {
      func = &Analysis::AnalyseSqlFile;
      db_needed = ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="sqltables") {
      func = &Analysis::AnalyseSqlTables;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="sqlupdate") {
      func = &Analysis::AnalyseSqlUpdate;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="updatevideoinfo") {
      func = &Analysis::AnalyseUpdateVideoInfo;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="updateimageinfo") {
      func = &Analysis::AnalyseUpdateImageInfo;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="updateobjectinfo") {
      func = &Analysis::AnalyseUpdateObjectInfo;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="bindatatest") {
      func = &Analysis::AnalyseBinDataTest;
      db_needed = ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="bindata") {
      func = &Analysis::AnalyseBinData;
      db_needed = ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="bindump") {
      func = &Analysis::AnalyseBinDump;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="testbindump") {
      func = &Analysis::AnalyseBinDumpTest;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="maskeddetection") {
      func = &Analysis::AnalyseMaskedDetection;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="cocomasks") {
      func = &Analysis::AnalyseCOCOmasks;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="featuretest") {
      func = &Analysis::AnalyseFeatureTest;
      ifile_preferred = false;
    }
    else if (method_x=="erasefeatures") {
      func = &Analysis::AnalyseEraseFeatures;
      ifile_preferred = false;
    }
    else if (method_x=="importfeatures") {
      func = &Analysis::AnalyseImportFeatures;
      ifile_preferred = false;
    }
    else if (method_x=="importdatfeatures") {
      func = &Analysis::AnalyseImportDatFeatures;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="importexternalfeatures") {
      func = &Analysis::AnalyseImportExternalFeatures;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="exportlmdbfeatures") {
      func = &Analysis::AnalyseExportLmdbFeatures;
      ifile_preferred = false;
    }
    else if (method_x=="createdummyfeatures") {
      func = &Analysis::AnalyseCreateDummyFeatures;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="erasedetections") {
      func = &Analysis::AnalyseEraseDetections;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="importdetections") {
      func = &Analysis::AnalyseImportDetections;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="importexternaldetections") {
      func = &Analysis::AnalyseImportExternalDetections;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="exportwadm") {
      func = &Analysis::AnalyseExportWadm;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="importbindata") {
      func = &Analysis::AnalyseImportBinData;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="test") {
      func = &Analysis::AnalyseTest;
      ifile_preferred = tt_needed = db_needed = features_needed = false;
    }
    else if (method_x=="rewritemapslabelsonly") {
      func = &Analysis::AnalyseRewriteMapsLabelsOnly;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="detect") {
      func = &Analysis::AnalyseDetect;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="segment") {
      func = &Analysis::AnalyseSegment;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="segmentdetect") {
      func = &Analysis::AnalyseSegmentDetect;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="pdf") {
      func = &Analysis::AnalysePDF;
      ifile_preferred = tt_needed = false;
    }
    else if (method_x=="insertsentences") {
      func = &Analysis::AnalyseInsertSentences;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="captioning") {
      func = &Analysis::AnalyseCaptioning;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="sentencecandidates") {
      func = &Analysis::AnalyseSentenceCandidates;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="evaluatesentences") {
      func = &Analysis::AnalyseEvaluateSentences;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="bleu") {
      func = &Analysis::AnalyseBLEUdeprecated;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="textquery") {
      func = &Analysis::AnalyseTextQuery;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="dumptextindex") {
      func = &Analysis::AnalyseDumpTextIndex;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="textretrieve") {
      func = &Analysis::AnalyseTextRetrieve;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="textaddfield") {
      func = &Analysis::AnalyseTextAddField;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="textindexupdatelabels") {
      func = &Analysis::AnalyseTextIndexUpdateLabels;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="textwash") {
      func = &Analysis::AnalyseTextWash;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="googlecustomsearch") {
      func = &Analysis::AnalyseGoogleCustomSearch;
      db_needed = ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="trangeoverlaps") {
      func = &Analysis::AnalyseTrangeOverlaps;
      ifile_preferred = tt_needed = features_needed = false;
    }
    else if (method_x=="insertsubobjects") {
      func = &Analysis::AnalyseInsertSubObjects;
      ifile_preferred = features_needed = false;
    }
    else if (method_x=="createtars") {
      func = &Analysis::AnalyseCreateTars;
      ifile_preferred = features_needed = tt_needed = false;
    }
    else if (method_x=="data") {
      return ShowAnalyseUsage("Analyse method \"data\""
			      " has been renamed to \"featuredata\"");
    }

    else
      return ShowAnalyseUsage("Unrecognized analyse method: <"+method+">");

    if (db_needed && !query->GetDataBase())
      return ShowError(hdr+"database not defined");

    if (tt_needed && query->Target()==target_no_target)
      return ShowError(hdr+"missing target specification");

    if (features_needed &&
	((query->Algorithms().empty() && !query->Nindices(NULL)) ||
	 (!query->Algorithms().empty() && 
	  !query->Nindices(&query->Algorithms()[0]))))
      return ShowError(hdr+"features not defined");

    if (cls_needed && classname=="")
      return ShowError(hdr+"class not defined");

    if (query_needed && queryname=="")
      return ShowError(hdr+"queryname not defined");

    if (ifile_preferred && imagefilename=="")
      ShowError(hdr+"imagefile not defined, continuing still");
  
    if (do_crossval && crossval!="" && crossval!="none") {
      if (crossval.find("old")==0)
        return CrossValidateOld();
      else
        return CrossValidateNew();
    }

    string ticf = "Analyse_"+method_x;
    Tic(ticf.c_str());
    TicTac tictac;
    result = (this->*func)(args);
    tictac.Stop();
    Tac(ticf.c_str());

    result.set_times(tictac);

    if (plot!="" && result.ok() && !result.empty())
      Plot(result);

    ConditionallyWriteResult(result);

    if (callback!="")
      DoCallback(callback);

    if (parent)
      CopyXmlResultTo((Analysis*)parent);

    return result;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ShowAnalyseUsage(const string& msg) {
    cerr << picsom->MyName() << " -a: " << msg << endl << endl
         << "ANALYSIS USAGE:" << endl
         << "   " << picsom->MyName()
         << " -a|-analyse method [inputfile] [args]" 
         << endl << endl
         << "ANALYSIS METHODS:" << endl
         << "   conv         Convolutions" << endl
         << "   spread       Spread of classes in 2-D PCA space" << endl
         << "   div          Spread of classes on maps and in units" << endl
         << "   obsprob      Observed probability function" << endl
         << "   knn          k-Nearest Neighbor classification" << endl
         << "   tau          Tau test" << endl;

    return false;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseSleep(const vector<string>& args) {
    string hdr = "AnalyseSleep("+CommaJoin(args)+") : ";

    if (args.size()) {
      int stime = atoi(args[0].c_str());
      if (stime > 0) {
        WriteLog(hdr+"sleeping "+ToStr(stime)+" seconds...");
        sleep(stime);      
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseDummy(const vector<string>& args) {
    for (size_t i=0; i<args.size(); i++)
      cout << i << " \"" << args[i] << "\"" << endl;

    RandVar rr;
    size_t n = 43L*1024*1024, m = 0;
    set<size_t> ss;
    for (;;) {
      size_t v = rr.RandomInt(n);
      if (v>m)
	cout << (m=v) << endl;
      if (ss.size()==1000000)
	break;
      ss.insert(v);
      cout << " "  << ss.size() << endl;
    }

    return true;


#ifdef PICSOM_USE_MPI    
    MPI::Info info;
    char port_name[MPI_MAX_PORT_NAME];

    int root = 0, tag = 123;

    if (args.size()==0) {
      string msg0 = "0123456789", msg = msg0;
      msg += msg0;
      msg += msg0;
      msg += msg0;

      MPI::Open_port(info, port_name);
      cout << "Opened \"" << port_name << "\"" << endl;
      for (;;) {
	// MPI_Send(port_name, MPI_MAX_PORT_NAME, MPI_CHAR, 1, 0, MPI_COMM_WORLD);
	MPI::Intracomm intra(MPI_COMM_WORLD);
	MPI::Intercomm inter = intra.Accept(port_name, info, root);
	cout << "Accepted..." << endl;
	MPI::Request r = inter.Isend(msg.c_str(), msg.size()+1, MPI::CHAR, root, tag);
	cout << "Isent..." << endl;
      }

    } else {
      strcpy(port_name, args[0].c_str());
      MPI::Intracomm intra(MPI_COMM_WORLD);
      MPI::Intercomm inter = intra.Connect(port_name, info, root);
      cout << "Connected..." << endl;
      for (size_t i=0; i<50; i++) {
	MPI::Status status;
	bool p = inter.Iprobe(root, tag, status);
	cout << "Iprobe'd " << (int)p << endl;
	if (p) {
	  char buf[20] = "";
	  MPI::Request r = inter.Irecv(buf, sizeof(buf), MPI::CHAR, 0, tag);
	  cout << "Irecv'd \"" << buf << "\" " << (int)r.Get_status() << endl;
	}
	sleep(1);
      }
    }

    return true;
#endif // PICSOM_USE_MPI    

    if (args.size()) {
      int stime = atoi(args[0].substr(1,args[0].length()-2).c_str());
      if (stime > 0) {
        WriteLog("dummy sleeping "+ToStr(stime)+" seconds...");
        struct timespec ts = { 0, 1000*stime };
        nanosleep(&ts, NULL);      
      }
    }

    list<string> a = BraceCommaExpand("a{b,c{d,e}}{f,g}");
    cout << "["+JoinWithString(a, "] [")+"]" << endl;

    // DataBase *db = CheckDB();
    // vector<float> v { 7, 2 };
    // db->StoreDetectionResult(0, "koe", v);

    // string fname = Picsom()->TempDirPersonal()+"/dummy.txt";
    // string hello = "Hello world!\n";
    // if (StringToFile(hello, fname))
    //   WriteLog("Stored in a temporary file <"+fname+">");
    // else
    //   ShowError("Failed to write in <"+fname+">");

    // string dstr, ctype;
    // if (!Connection::DownloadString(Picsom(), "GET",
    // 				    "http://users.ics.aalto.fi/jorma/dummy.cgi",
    // 				    "", "", dstr, ctype, 5, 10))
    //   return ShowError("DownloadString() failed");

    // cout << ctype << " " << dstr.size() << endl
    // 	 << dstr << endl;

    Picsom()->ConditionallyStartSlaveStatusThread();
    Picsom()->ConditionallyStartAnalysisThread();

    vector<string> cmd { "slurm", "q" };
    auto r = Picsom()->ShellExecute(cmd, false, true);
    if (!r.first)
      WriteLog("FAILED");
    else
      for (auto i=r.second.begin(); i!=r.second.end(); i++)
    	WriteLog(*i);

    PicSOM::slave_info_t si("", "");
    for (size_t i=0; i<10; i++)
      Picsom()->PossiblyStartNewSlaves(si);

    WriteLog("--exclude="+CommaJoin(Picsom()->SbatchExclude()));

    WriteLog("dummy operation finishing");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseEnv(const vector<string>&) {
    WriteLog("Starting to dump the environment");

#if HAVE_DECL_ENVIRON
    char **e = environ;
#else
    char **e = NULL; // SunOS/MacOS...
#endif //  HAVE_DECL_ENVIRON

    map<string,string> m;

    while (e && *e) {
      string v = *(e++);
      try {
        pair<string,string> kv = SplitKeyEqualValueNew(v);
	m.insert(kv);
      } catch (...) {
	ShowError("Failed with <"+v+">");
      }
    }

    for (auto i=m.begin(); i!=m.end(); i++)
      *aout << "[" << i->first << "]=[" << i->second << "]" << endl;
    
    WriteLog("Finished dumping the environment");

    if (GetDataBase()) {
      string tmpdir = CheckDB()->TempDir("testdir");
       *aout << "Created temporary directory [" << tmpdir << "]" << endl;
       string tmpfile = tmpdir+"/test.txt";
       string hello = "Hello World!";
       StringToFile(hello, tmpfile);
       if (FileExists(tmpfile))
	 *aout << "Wrote to and read from [" << tmpfile << "] \""
	       << FileToString(tmpfile) << "\"" << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCaffeConvertImageset(const vector<string>& args) {
    string msg = "AnalyseCaffeConvertImageset() : ";

    string d_or_a = "d", colorspace = "bgr";
    size_t w = 256, h = 256;
    size_t crops = 500;
    vector<float> scales { 1, 1.3, 1.6, 2, 2.4, 2.8, 3.2, 3.6, 4 };
    bool shuffle = true;

    float as = 0;
    for (size_t i=0; i<scales.size(); i++)
      as += scales[i]*scales[i];
    vector<float> per_scale;
    for (size_t i=0; i<scales.size(); i++)
      per_scale.push_back(crops*scales[i]*scales[i]/as);

    RegExp wh("^([0123456789]+)x([0123456789]+)([ad]?)$");
    if (!wh.ok())
      return ShowError(msg+"regexp failed"); 

    for (size_t i=0; i<args.size(); i++) {
      bool done = false;

      vector<RegExpMatch> rem = wh.match(args[i], 3);
      if (rem.size()==3) {
	done = true;
	w = atoi(rem[0].str().c_str());
	h = atoi(rem[1].str().c_str());
	if (rem[2].str()!="")
	  d_or_a = rem[2].str();
      }

      if (!done)
	return ShowError(msg+"argument \""+args[i]+"\" not understood"); 
    }

    if (d_or_a!="d")
      return ShowError(msg+"only \"d\" type aspect handling implemented"); 

    WriteLog(msg+"starting");

    DataBase *db = GetDataBase();
    const ground_truth& qgt = QueryRestrictionGT();
    cout << endl;
    db->GroundTruthSummaryTable(qgt, verbose>1, verbose>1);
    cout << endl;
    
    string dbname = db->ExpandPath("caffe/data/");
    Picsom()->MkDirHier(dbname, 02775);
    if (filename!="")
      dbname += filename;
    else if (qgt.label()!="*")
      dbname += qgt.label();
    else
      dbname += "all";

    dbname += "-"+classname;
    if (w!=256 || h!=256)
      dbname += "-"+ToStr(w)+"x"+ToStr(h);
    dbname += "-"+d_or_a;
    if (colorspace!="bgr")
      dbname += "-"+colorspace;

    if (crops)
      dbname += "+"+ToStr(crops)+"crops";

    if (FileExists(dbname) || DirectoryExists(dbname))
      return ShowError(msg+"<"+dbname+"> exists, not overwriting... bye...");

    list<string> clsl = db->SplitClassNames(classname);
    vector<string> clsn(clsl.begin(), clsl.end());
    vector<ground_truth> cls;
    for (size_t i=0; i<clsn.size(); i++) {
      cout << "  reading class <" << clsn[i] << ">" << endl;
      ground_truth gta = db->GroundTruthExpression(clsn[i]);
      ground_truth gtb = gta.TernaryAND(qgt);
      if (!gtb.has_plus()) {
	/*return*/ ShowError(msg+"ground truth intersection of <"+qgt.label()+
			 "> and <"+clsn[i]+"> is empty");
      }
      cls.push_back(gtb);
    }

    string objdir = db->ExpandPath("objects/");
    string rootfolder = db->ConvertGlobalToLocalDiskName(objdir); // obs! ??
    if (!DirectoryExists(rootfolder) &&
	!Picsom()->MkDirHier(rootfolder, 0755))
      return ShowError(msg+"failed to mkdir \""+rootfolder+"\"");

    string listfn = db->TempFile("convert_imageset.input");
    ofstream listf(listfn);

    size_t ntot = 0, npat = 0;
    vector<size_t> n(cls.size());
    vector<size_t> idxs = qgt.indices(1);

    string shufflemsg = "unshuffled";
    int rndseed = query->RndSeed();
    if (rndseed) {
      IntVector perm = RandVar::Permutation(idxs.size(), rndseed);
      vector<size_t> tmp = idxs;
      for (size_t i=0; i<idxs.size(); i++)
	idxs[i] = tmp[perm[i]];
      shufflemsg = "shuffled with rndseed="+ToStr(rndseed);
    }
    if (shuffle)
      shufflemsg += " + extra suffling";

    const size_t prog = 10000;
    for (size_t i=0; i<idxs.size(); i++) {
      if (idxs.size()>prog && i%prog==0)
	cout << "  i=" << i << "/" << idxs.size() << endl;
 
      bool hit = false;
      for (size_t j=0; j<cls.size(); j++)
	if (cls[j][idxs[i]]==1) {
	  if (hit)
	    return ShowError(msg+"multiple class hits for #"+ToStr(idxs[i]));
	  hit = true;
	  n[j]++;
	  ntot++;

	  //string fpath = db->SolveObjectPath(db->Label(idxs[i]));
	  string fpathx = db->ObjectPathEvenExtract(idxs[i]), fpath = fpathx;
	  if (fpath.find(rootfolder)==0)
	    fpath.erase(0, rootfolder.size());
	  else if (fpath.find(objdir)==0) {
	    size_t p = fpath.rfind('/');
	    if (p==string::npos)
	      return ShowError(msg+"/ not found in <"+fpath+">");
	    string dest = rootfolder; // obs!
	    dest += fpath.substr(p+1);
	    if (!Symlink(fpath, dest))
	      return ShowError(msg+"Symlink("+fpath+","+dest+") failed");
	    fpath.erase(0, p+1);
	  }
	  listf << fpath << " " << j << endl;

	  if (crops && scales.size()) {
	    imagedata img = imagefile(fpathx).frame(0);

	    map<string,string> m = db->ReadOriginsInfo(idxs[i], false, true);
	    size_t w = atoi(m["width"].c_str());
	    size_t h = atoi(m["height"].c_str());
	    if (!w || !h)
	      return ShowError(msg+"dimension failed with #"+ToStr(idxs[i]));

	    size_t wh = w<h ? w : h;

	    cout << w << "x" << h << endl;
	    for (size_t k=0; k<scales.size(); k++ ) {
	      size_t nh = (size_t)floor(sqrt(per_scale[k]*w/h)+0.5);
	      size_t nv = (size_t)floor(sqrt(per_scale[k]*h/w)+0.5);
	      size_t dh = (size_t)ceil(2.0*w/(nh+1));
	      size_t dv = (size_t)ceil(2.0*h/(nv+1));
	      size_t dd = dh>dv ? dh : dv;
	      if (dd>wh)
		dd = wh;
	      cout << "  k=" << k << " nh=" << nh << " nv=" << nv
		   << " dh=" << dh << " dv=" << dv << " dd=" << dd << endl;

	      for (size_t yi=0; yi<nv; yi++)
		for (size_t xi=0; xi<nh; xi++) {
		  size_t xx = nh>1 ? (w-dd)*xi/(nh-1) : (w-dd)/2;
		  size_t yy = nv>1 ? (h-dd)*yi/(nv-1) : (h-dd)/2;
		  imagedata piece = img.subimage(xx, yy, xx+dd-1, yy+dd-1);
		  string pfpath = fpath;
		  size_t q = pfpath.rfind('.');
		  pfpath.insert(q, "="+ToStr(k)+"-"+ToStr(xi)+"-"+ToStr(yi));
		  string pname = rootfolder+pfpath;
		  imagefile::write(piece, pname);
		  cout << "    " << xi << "," << yi << " : "
		       << xx << "," << yy << " " << pname << endl;
		  listf << pfpath << " " << j << endl;
		  npat++;
		}
	    }
	  }
	}
      if (!hit)
	return ShowError(msg+"no class hits for #"+ToStr(idxs[i]));
    }
    listf.close();

    cout << "Class names, indices and counts:" << endl;
    for (size_t i=0; i<clsn.size(); i++)
      cout << clsn[i] << "\t" << i << "\t" << n[i] << endl;
    cout << "Total: " << clsn.size() << " classes, " << ntot
	 << " images, " << npat << " patches" << endl;

    string exe_conv = "convert_imageset.bin";
    vector<string> cmd_conv {
      exe_conv, "-backend", "lmdb", "-resize_height", ToStr(h),
	"-resize_width", ToStr(w)
	};

    if (shuffle)
      cmd_conv.push_back("-shuffle");
    
    cmd_conv.push_back(rootfolder);
    cmd_conv.push_back(listfn);
    cmd_conv.push_back(dbname);

    if (Picsom()->ExecuteSystem(cmd_conv, true, true, true))
      return ShowError(msg+"convert_imageset failed...");

    string meanfile = dbname+"/mean";

    string exe_mean = "compute_image_mean.bin";
    vector<string> cmd_mean { exe_mean, dbname, meanfile, "lmdb" };

    if (Picsom()->ExecuteSystem(cmd_mean, true, true, true))
      return ShowError(msg+"convert_imageset failed...");

    chmod(dbname.c_str(), 02775);

    string readme = TimeStamp()+"created by "+Picsom()->UserName()+
      " in "+Picsom()->HostName()+" with:\npicsom "+commands_str+"\n";
    readme += JoinWithString(cmd_conv, " ")+"\n";
    readme += JoinWithString(cmd_mean, " ")+"\n";

    if (!StringToFile(readme, dbname+"/readme.txt"))
      return ShowError(msg+"writing readme.txt failed...");

    vector<string> cmd_cp { "cp", listfn, dbname };
    if (Picsom()->ExecuteSystem(cmd_cp, true, true, true))
      return ShowError(msg+"copying image list failed...");

    WriteLog("Successfully created caffe data from ["+qgt.label()+ "] and ["+
	     classname+"] to <"+db->ShortFileName(dbname)+"> "+shufflemsg);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseLscom(const vector<string>& args) {
    DataBase *db = GetDataBase();

    bool dir = true;
    list<string> clist;
    for (auto i=args.begin(); i!=args.end(); i++) {
      if (*i=="-") {
	dir = false;
	continue;
      }
      if (db && db->IsMetaClassFile(*i)) {
	list<string> cl_list = db->SplitClassNames(*i);
	clist.insert(clist.end(), cl_list.begin(), cl_list.end());
      } else
	clist.push_back(*i);
    }

    for (auto i=clist.begin(); i!=clist.end(); i++) {
      string cooked = DataBase::LscomName(Picsom(), *i, dir, lscommap);
      cout << cooked << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseOntology(const vector<string>&
						     args) {
    DataBase *db = GetDataBase();

    if (!db)
      db = Picsom()->FindDataBase("trecvid2011");

    db->LscomName("003", true, lscommap);

    const ontology& o = db->LscomOntology();

    cout << endl;
    bool rec = true;
    list<string> clist;
    for (auto i=args.begin(); i!=args.end(); i++) {
      if (i->find("rec=")==0) {
	rec = IsAffirmative(i->substr(4));
	continue;
      }

      cout << *i << " IS_A " << (rec?"(recursive) ":"") << ": ";
      ontology::rellist_t l = o.is_a(*i, rec);
      for (auto j=l.begin(); j!=l.end(); j++)
	cout << (j!=l.begin()?", ":"") << j->first;
      cout << endl;

      l = o.reverse_is_a(*i, rec);
      for (auto j=l.begin(); j!=l.end(); j++)
	cout << (j!=l.begin()?", ":"") << j->first;
      cout << " : IS_A " << (rec?"(recursive) ":"") << *i << endl;
	  
      cout << *i << " IS_PART " << (rec?"(recursive) ":"") << ": ";
      l = o.is_part(*i, rec);
      for (auto j=l.begin(); j!=l.end(); j++)
	cout << (j!=l.begin()?", ":"") << j->first;
      cout << endl;

      l = o.reverse_is_part(*i, rec);
      for (auto j=l.begin(); j!=l.end(); j++)
	cout << (j!=l.begin()?", ":"") << j->first;
      cout << " : IS_PART " << (rec?"(recursive) ":"") << *i << endl;
	  
      cout << *i << " EXCLUDES " << (rec?"(recursive) ":"") << ": ";
      l = o.excludes(*i, rec);
      for (auto j=l.begin(); j!=l.end(); j++)
	cout << (j!=l.begin()?", ":"") << j->first;
      cout << endl;

      l = o.reverse_excludes(*i, rec);
      for (auto j=l.begin(); j!=l.end(); j++)
	cout << (j!=l.begin()?", ":"") << j->first;
      cout << " : EXCLUDES " << (rec?"(recursive) ":"") << *i << endl;
	  
      cout << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseGT(const vector<string>& argv) {
    target_type tt = query->Target();
    WriteLog("AnalyseGT : query_target==", TargetTypeString(tt));

    DataBase *db = CheckDB();
    // ReadFiles(false);

    for (size_t i=0, kx=0; i<=argv.size(); i++) {
      const string& cls = i ? argv[i-1] : classname;
      list<string> ll;
      if (i==0) {
        ll = db->SplitClassNames(cls);
        if (ll.size()>1)
          cout << endl << "<" << cls << "> was split in " << ll.size()
               << " subsets" << endl;
      } else
        ll.push_back(cls);

      for (list<string>::const_iterator j=ll.begin(); j!=ll.end(); j++) {
        int oo = -1;
        ground_truth gtx = GroundTruthExpression(*j, tt, oo, expand);
        vector<size_t> gto;
        if (keeporder) {
          vector<size_t> ord = db->ReadOrderedClassFile(*j, -1, false);
          if (verbose>4)
            cout << endl << "Class [" << *j << "] had " << ord.size()
                 << " objects according to ReadOrderedClassFile()" << endl;
          ground_truth tmp = gtx;
          for (size_t oi=0; oi<ord.size(); oi++) {
            size_t o = ord[oi];
            if (tmp[o]==1) {
              if (verbose>4)                
                cout << endl << "Adding " << Label(o)
		     << " to ordered ground truth"
		     << endl;
              gto.push_back(o);
              tmp[o] = -1;
            }
          }
          vector<size_t> tmp2 = tmp.indices(1);
	  // currently this is always empty ?

          if (tmp2.size() && verbose>3)
            cout << endl << "Class [" << *j << "] had " << tmp2.size()
                 << " non-ordered objects" << endl;
          gto.insert(gto.end(), tmp2.begin(), tmp2.end());
          
        } else
          gto = gtx.indices(1);

	if (verbose==2 && argv.size()==0) {
	  // obs! works only for binary classes...
	  for (size_t k=0; k<gtx.size(); k++)
	    if (gtx[k]==0)
	      return ShowError("AnalyseGT() zero found...");
	    else if (gtx[k]==1)
	      cout << db->Label(k) << endl;
	  continue;
	}

	cout << endl;
        db->GroundTruthSummaryTable(gtx, verbose>2, verbose>2);
        cout << endl;

        if (verbose>3 && tt==target_image) {
	  list<video_frange> flist = db->SolveVideoFranges(gtx);
	  for (auto ri=flist.begin(); ri!=flist.end(); ri++)
	    cout << "   " << ri->str() << endl;
	  cout << endl;
        }

        if (verbose>4) {
          cout << endl << "<" << db->Name() << "> contains contents classes:"
               << endl << endl;
          for (size_t kk=0; kk<db->ContentsClasses(); kk++) {
            db->GroundTruthSummaryTable(db->Contents(kk), verbose>5, verbose>5);
            cout << endl;
          }
        }

        if (verbose>5)
          for (size_t oi=0; oi<gto.size(); oi++) {
            size_t o = gto[oi];
            cout << o << ": " << db->ObjectDump(o) << endl;
	    if (verbose>8) {
	      cout << "    ismissing=" << db->IsMissingObject(o)
		   << " videoclip="    << db->IsVideoClip(o)
		   << " audioclip="    << db->IsAudioClip(o)
		   << " videoframe="   << db->IsVideoFrame(o)
		   <<  endl;
	    }

            if (verbose>6) {
              bool find = verbose>7;
              keyword_list kwl = db->FindKeywords(o, find, find);
              cout << kwl.size() << " keywords=";
              for (keyword_list::const_iterator kk=kwl.begin();
                   kk!=kwl.end(); kk++)
                cout << (kk!=kwl.begin()?",":"") << kk->first << "("
                     << kk->second << ")";
              cout << endl;
            }
            cout << endl;
          }

        bool use_cwd = true;
        if (resultname!="")
          db->ConditionallyWriteClassFile(use_cwd, resultname+"-"+ToStr(++kx),
                                          gtx, "AnalyseGT() : ["+*j+"]",
                                          false);
        if (imagefilename!="") {
          list<string> labset;
          for (size_t oi=0; oi<gto.size(); oi++) {
            size_t o = gto[oi];
            labset.push_back(Label(o));
            if (labset.size()==(size_t)query->MaxQuestions())
              break;
          }

          size_t ncols = columns;
          if (!ncols)
            ncols = (size_t)ceil(sqrt((double)labset.size()));
          imagedata empty(0, 0);
          imagedata out = db->CreateImageCollage(labset, imagespec, ncols,
                                                 -5, -5, empty);

          if (labset.size()) {
            try {
              imagefile::write(out, imagefilename);
              WriteLog("Wrote image collage in <"+imagefilename+">");
            } catch (...) {
              ShowError("Failed to write image collage in <"+imagefilename+">");
            }
          } else
            WriteLog("Skipped writing an empty image collage in <"+
		     imagefilename+">");
        }

        if (dirplot && db->LabelFormat().size()>1) {
          size_t nsum = 0;
	  size_t dmax = db->ObjectDirectoryWidth(db->LabelFormat().size()-2,
						 true);
          for (size_t d=0; d<dmax && nsum<db->Size(); d++) {
            vector<int> o = db->AllObjectsIn(d);
            if (o.empty())
              continue;

            char tmp[10];
            sprintf(tmp, "%06d", (int)d);
            cout << tmp;
            
            for (size_t f=0; f<o.size(); f++)
              cout << " " << (gtx[o[f]]==1 ? '*' : '.');

            cout << endl;

            nsum += o.size();
          }
        }
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseCreateLabelMap(const vector<string>& argv) {
    string msg = "AnalyseCreateLabelMap() : ";

    if (filename=="")
      return ShowError(msg+"filename should be set");

    if (argv.size()!=1)
      return ShowError(msg+"one argument middleframe|kf1 expected");

    bool middleframe = argv[0]=="middleframe";
    bool kf1         = argv[0]=="kf1";
    
    if (!middleframe && !kf1)
      return ShowError(msg+"argument should be middleframe or kf1");

    string func = "$middleframe(<>)";
    
    DataBase *db = CheckDB();
    const ground_truth& qgt = QueryRestrictionGT();
    cout << endl;
    db->GroundTruthSummaryTable(qgt, verbose>1, verbose>1);
    cout << endl;

    ofstream out(filename);
    
    vector<size_t> idxs = qgt.indices(1);
    for (auto i : idxs) {
      out << db->Label(i);
      if (false) {
	string funcx = func;
	size_t p = funcx.find("<>");
	if (p!=string::npos)
	  funcx.replace(p, 2, db->Label(i));
	ground_truth g = db->GroundTruthFunction(funcx, Target());
	vector<size_t> v = g.indices(1);
	for (auto j : v)
	  out << " " << db->Label(j);
      }
      if (middleframe) {
	pair<size_t,size_t> ii = db->VideoOrSegmentMiddleFrame(i);
	out << " " << db->Label(ii.first);
      }
      if (kf1) {
	string labelkf = db->Label(i)+":kf1";
	if (db->LabelIndexGentle(labelkf)<0)
	  return ShowError(msg+"<"+labelkf+"> in inexistent label");
	out << " " << labelkf;
      }
      out << endl;
    }
    
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseCreateClassFile(const vector<string>& argv) {
    string msg = "AnalyseCreateClassFile() : ";
    string argerr = msg+"one argument of type 'func(arg,arg arg,...)'"
      " should be given";

    string aa = "["+JoinWithString(argv, "][")+"]";
    WriteLog(msg+aa);

    if (filename=="")
      return ShowError(msg+"filename should be set");

    if (argv.size()!=1)
      return ShowError(argerr+" A");

    const string& a = argv[0];
    size_t p = a.find('(');
    if (p==string::npos)
      return ShowError(argerr+" B");
    if (a[a.size()-1]!=')')
      return ShowError(argerr+" C");

    string func = a.substr(0, p);
    vector<string> fa = SplitInCommasObeyParentheses(a.substr(p+1,
							      a.size()-p-2));
    aa = func+"["+JoinWithString(fa, "][")+"]";
    WriteLog(msg+aa);

    if (func!="google_image_search" || fa.size()!=2)
      return ShowError(msg+"only google_image_search(N,query text)"
		       " is currently supported");

    // func=="google_image_search"

    DataBase *db = CheckDB();

    size_t n = atoi(fa[0].c_str());
    list<string> urll = query->GoogleCustomSearch(fa[1], "image", n);
    vector<string> urlv(urll.begin(), urll.end());

    vector<size_t> idxs;
    bool ok = InsertObjects(urlv, &idxs);
    string ltxt;
    if (idxs.size())
      ltxt += ": "+db->ObjectDump(idxs.front());
    if (idxs.size()>1)
      ltxt += " ... "+db->ObjectDump(idxs.back());
    WriteLog(msg+" inserted "+ToStr(idxs.size())+" object"+
	     (idxs.size()==1?"":"s")+ltxt);

    list<pair<size_t,double> > ord;
    for (size_t i=0; i<idxs.size(); i++)
      ord.push_back(make_pair(idxs[i], 0.0));

    db->WriteOrderedClassFile(ord, filename, TimeStamp(), false, true);

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseMetaClassFile(const vector<string>& argv) {
    string msg = "AnalyseMetaClassFile : ";

    WriteLog(msg);

    if (false && filename=="")
      return ShowError(msg+"filename should be specified");

    DataBase *db = CheckDB();

    map<string,set<size_t>> classes;
    set<string> clset;

    if (argv.size() && argv[0].find("text/")==0) {
      string ti = query->TextIndex();
      if (ti=="")
	ti = db->DefaultTextIndex();

      string f = argv[0].substr(5), pref;
      auto p = f.find('/');
      if (p!=string::npos) {
	pref = f.substr(p+1);
	f.erase(p);
      }

      const ground_truth& qgt = QueryRestrictionGT();
      cout << endl;
      db->GroundTruthSummaryTable(qgt, verbose>1, verbose>1);
      cout << endl;
	
      vector<size_t> idxs = qgt.indices(1);

      for (auto i=idxs.begin(); i!=idxs.end(); i++) {
	string w = db->TextIndexSearchByLabel(*i, ti, f);
	if (w=="")
	  continue;

	string cname = pref+w;
	clset.insert(cname);
	classes[cname].insert(*i);
      }
    }

    vector<string> cllist(clset.begin(), clset.end());
    ground_truth gtfoo;
    string comm = "created automatically "+TimeStamp()+"\n"+
      commands_str+" - "+ToStr(rest_argv_str);
    db->WriteClassFile(classname, cllist, "", gtfoo, comm, false, true);

    for (auto i=classes.begin(); i!=classes.end(); i++) {
      ground_truth gt(db->Size());
      for (auto j=i->second.begin(); j!=i->second.end(); j++)
	gt[*j] = 1;
      string c_comm = i->first+"\n"+comm;
      db->WriteClassFile(i->first, vector<string>(), "", gt,
			 c_comm, false, false);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseDTW(const vector<string>& argv) {
    bool debug = false;
    size_t nshow = 10;
    
    string err = "AnalyseDTW() : ";
     
    WriteLog("AnalyseDTW");

    DataBase *db = CheckDB();

    map<size_t,float> sh_weight;
    set<size_t> slmotion_comp { 59, 60, 61, 62 };
    bool sephands = true;
    double mul = 0.0;

    dtw_spec dtw;

    for (auto i=argv.begin(); i!=argv.end(); i++) {
      if (i->find("dtw=")==0) {
	dtw = dtw_spec::parse(i->substr(4));
	continue;
      }

      if (i->find("mul=")==0) {
	mul = atof(i->substr(4).c_str());
	continue;
      }
      if (i->find("sephands=")==0) {
	sephands = IsAffirmative(i->substr(9));
	continue;
      }
      if (i->find("sh_weight=")==0) {
	sh_weight.clear();
	string cspec = i->substr(10);
	if (cspec!="none") {
	  vector<string> vc = SplitInCommas(cspec);
	  for (auto j=vc.begin(); j!=vc.end(); j++) {
	    string s = *j;
	    size_t d = s.find('-');
	    size_t c = s.find(':');
	    if (d==string::npos || c==string::npos || c<d)
	      return ShowError(err+"failed to process \""+s+"\"");
	    int a = atoi(s.substr(0, d).c_str());
	    int b = atoi(s.substr(d+1, c-d-1).c_str());
	    float v = atof(s.substr(c+1).c_str());
	    for (size_t t=(size_t)a; t<=(size_t)b; t++)
	      sh_weight[t] = v;
	  }
	}
	continue;
      }
      if (i->find("slmotion_comp=")==0) {
	slmotion_comp.clear();
	string cspec = i->substr(14);
	if (cspec!="none") {
	  vector<string> vc = SplitInCommas(cspec);
	  for (auto j=vc.begin(); j!=vc.end(); j++)
	    slmotion_comp.insert(atoi(j->c_str()));
	}
	continue;
      }
      
      ostringstream os;
      // os << "mul=" << mul << " sephands=" << sephands << " slmotion_comp=";
      // for (auto j=slmotion_comp.begin(); j!=slmotion_comp.end(); j++)
      // 	os << (j==slmotion_comp.begin()?"":",") << *j;
      os << "dtw=" << dtw.str();
      string osstr = os.str();

      vector<string> v = SplitInCommas(*i);

      if (v.size()==3) {
        video_frange_match r = db->DTWmatch(v[0], v[1], v[2], dtw);

        // video_frange_match r = db->DTWmatch(v[0], v[1], v[2],
	// 				    slmotion_comp,
	// 				    sh_weight, sephands, mul);

	cout << osstr << " " << *i << " = " << r.str() << endl;

	if (filename!="") {
	  ofstream eval_out(filename.c_str(), ios::app);
	  eval_out << Label(r.b.idx) << " " << r.b.begin
		   << "-" << r.b.end-1 << endl;
	}
	continue;
      }

      if (v.size()<5 || v.size()>6)
	return ShowError(err+"A failed to parse <"+*i+">");

      int idx1 = db->LabelIndex(v[0]), idx2 =  db->LabelIndex(v[3]);
      int a1 = atoi(v[1].c_str()), b1 = atoi(v[2].c_str());

      video_frange r1(db, idx1, (size_t)a1, (size_t)b1);

      if (v.size()==5) {
	int l = b1-a1;
	map<double,string> res;

	int l2 = atoi(v[4].c_str());
	for (int a2=0; a2<l2; a2++)
	  for (int b2=a2+1; b2<=l2; b2++) {
	    if (b2-a2>l)
	      continue;

	    video_frange r2(db, idx2, (size_t)a2, (size_t)b2);

	    double d = db->DTWdistance(r1, r2, slmotion_comp, sh_weight,
	    			       sephands, mul);
	    string s = v[3]+":"+ToStr(a2)+"-"+ToStr(b2-1);
	    if (debug)
	      cout << osstr << " " << s << " " << d << endl;
	    res.insert(make_pair(d, s));
	  }
	
	size_t n = 0;
	for (auto i=res.begin(); i!=res.end() && (!nshow || n<nshow); i++, n++)
	  cout << n << " " << osstr << " " << i->first << " : " << i->second
	       << endl;

	continue;
      }
      
      if (v.size()!=6)
	return ShowError(err+"B failed to parse <"+*i+">");
      
      int a2 = atoi(v[4].c_str()), b2 = atoi(v[5].c_str());
      
      cout << osstr << " " << *i << " : "
	   << db->DTWdistance(video_frange(db, idx1, (size_t)a1, (size_t)b1),
			      video_frange(db, idx2, (size_t)a2, (size_t)b2),
			      dtw, NULL)
	   << endl;

      // cout << osstr << " " << *i << " : "
      // 	   << db->DTWdistance(video_frange(db, idx1, (size_t)a1, (size_t)b1),
      // 			      video_frange(db, idx2, (size_t)a2, (size_t)b2),
      // 			      slmotion_comp, sh_weight, sephands, mul)
      // 	   << endl;
    }
    
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSuviVk(const vector<string>&
						   /*argv*/) {
    //bool debug = false;
    //size_t nshow = 10;

    string err = "AnalyseSuviVk() : ";
     
    WriteLog("AnalyseSuviVk");

    DataBase *db = CheckDB();

    Index *slmotionp = db->FindIndex("slmotion", "", true);
    VectorIndex *slmotionv = dynamic_cast<VectorIndex*>(slmotionp);
    if (!slmotionv)
      return ShowError(err+"dynamic_cast() failed");
    slmotionv->ReadDataFile(false, false);
    slmotionv->SetDataSetNumbers(false, true);
    FloatVectorSet& slmotion = slmotionv->Data();
    
    const ground_truth& qgt = QueryRestrictionGT();
    cout << endl;
    db->GroundTruthSummaryTable(qgt, verbose>1, verbose>1);
    cout << endl;
	
    vector<size_t> idxs = qgt.indices(1);
    
    for (auto i=idxs.begin(); i!=idxs.end(); i++) {
      object_info *info = db->FindObject(*i);
      for (auto j=info->children.begin(); j!=info->children.end(); j++) {
	const FloatVector *v = slmotion.FindByNumber(*j);
	if (v)
	  cout << *j << " " << db->Label(*j)
	       << " " << v->Number() << " " << v->Label()
	       << " " << v->Get(44) << " " << v->Get(47)
	       << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseSuviBenchmark(const vector<string>& argvin) {
    string err = "AnalyseSuviBenchmark() : ";
     
    WriteLog("AnalyseSuviBenchmark");

    if (argvin.size()<1)
      return ShowError(err+"at least cd-A|cd-B|cd-C argument needed");

    string cd = argvin[0];
    vector<string> argv(argvin.begin()+1, argvin.end());

    DataBase *db = CheckDB();

    ground_truth gt_be = db->GroundTruthExpression(cd);
    ground_truth gt_all(db->Size());

    map<string,list<string> > lab2class;
    list<string> signs = db->SplitClassNames("B_ALL");
    // list<ground_truth> gts;
    for (auto i=signs.begin(); i!=signs.end(); i++) {
      ground_truth gt = db->GroundTruthExpression(*i);
      gt_all = gt_all.TernaryOR(gt);
      // gts.push_back(gt);
      vector<size_t> pos = gt.indices(1);
      set<int> pars;
      for (auto o=pos.begin(); o!=pos.end(); o++) {
	int par = db->ParentObject(*o);
	pars.insert(par);
      }
      for (auto p=pars.begin(); p!=pars.end(); p++) {
	string label = db->Label(*p);
	lab2class[label].push_back(*i);
      }
    }

    const ground_truth& qgt = QueryRestrictionGT();
    cout << endl;
    db->GroundTruthSummaryTable(qgt, verbose>1, verbose>1);
    cout << endl;
	
    ofstream eval_out;
    if (filename!="")
      Unlink(filename);

    string dict_prev;
    vector<size_t> idxs = qgt.indices(1);
    for (auto i=idxs.begin(); i!=idxs.end(); i++) {
      // object_info *info = db->FindObject(*i);
      string xmpl = db->Label(*i), dict = xmpl;
      if (dict.size()!=6)
	return ShowError(err+"failed with \""+dict+"\"");
      dict.replace(4, 2, "00");
      
      string xmpl_cls = CommaJoin(lab2class[xmpl]);

      ground_truth gt_dict = gt_be&
	db->GroundTruthChildren(target_image, "", dict, vector<string>());
      
      // ground_truth gt_xmpl = gtbegeng&
      //   db->GroundTruthChildren(target_image, "", xmpl, vector<string>());

      video_frange f_dict = db->FrameNumberFrange(db->LabelIndex(dict),&gt_be);
      video_frange f_xmpl = db->FrameNumberFrange(db->LabelIndex(xmpl),&gt_all);
      
      cout << dict << " " << xmpl
	   << " (" << xmpl_cls << ") " << f_dict.dashstr()
	   << " " << f_xmpl.dashstr()
	   << endl;

      if (dict!=dict_prev)
	db->ClearDataVectorByLabelCache();

      //vector<string> dtwargs { ",000100:41-67,000102:71-79" };
      vector<string> dtwargs = argv;
      dtwargs.push_back(","+f_dict.dashstr()+","+f_xmpl.dashstr());
      if (AnalyseDTW(dtwargs).errored())
	return ShowError(err+"failed...");

      dict_prev = dict;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseTranslateTest(const vector<string>&
							  args) {
    string err = "AnalyseTranslateTest() : ";

    WriteLog("AnalyseTranslateTest");

    if (args.size()<4)
      return ShowError(err+"4+ arguments needed, eg. "
		       "<yandex> <en> <fi> <hello world>");

    list<string> s;
    for (size_t i=3; i<args.size(); i++)
      s.push_back(args[i]);

    list<string> t = Picsom()->Translate(args[0], args[1], args[2], s);

    for (auto is=s.begin(), it=t.begin(); is!=s.end() && it!=t.end();
	 is++, it++)
      cout << "\"" << *is << "\" => \"" << *it << "\"" << endl;

    return t.size()==s.size();
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSlaveTest(const vector<string>&
                                                      /*args*/) {
    string err = "AnalyseSlaveTest() : ";

    WriteLog("AnalyseSlaveTest");

    if (0) {
      size_t num_slaves=2;
      int sleep_seconds=2;

      script_exp_t plist = ScriptExpand(script, false);
      script_exp_t::iterator i = ScriptFind(plist,"slaves");
      if (i==plist.end())
	return ShowError(err+"no slaves defined!");
      else
	plist.erase(i);
      i = ScriptFind(plist,"analyse");
      i->second = "dummy";

      list<string> newscript = ScriptUnExpand(plist);
      newscript.push_back("*LIST*");
      for (size_t i=0; i<num_slaves; i++)
	newscript.push_back("* args="+ToStr(sleep_seconds));
    
      Analysis a(Picsom(), this, NULL, DashedExtraArguments());
      a.Script(newscript); 
      a.Analyse();
    }

    Picsom()->SetUpListenConnection(true, true);
    Picsom()->ConditionallyStartSlaveStatusThread();

    while (!Picsom()->HasSlaves()) {
      cout << "waiting for Godot at " << Picsom()->HttpListenConnection()
	   << endl;
      sleep(1);
    }
    Picsom()->ShowSlaveInfoList();

    for (size_t i=0; i<30; i++) {
      Picsom()->ShowSlaveInfoList();
      sleep(1);
      if (i==15) {
	cout << endl << endl << endl << endl;
	cout << "killing Godot..." << endl;
	cout << endl << endl << endl << endl;
	const PicSOM::slave_info_t *si = Picsom()->SlaveInfo(0);
	if (si==NULL)
	  return ShowError(err+"slave not found");

	Picsom()->TerminateSlave(*(PicSOM::slave_info_t*)si, "just because");
	sleep(1);
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseGvtTest(const vector<string>&
						    args) {
    string err = "AnalyseGvtTest() : ";

    if (!GetDataBase())
      query->SetDataBase("flickr");

    WriteLog(err+"database="+query->DataBaseName());

#if defined(USE_GVT)

    CbirGVT pv(CheckDB(), "");

    for (size_t i=0; i<args.size(); i++) {
      ground_truth gtin = CheckDB()->GroundTruthExpression(args[i]);
      WriteLog(err+"["+args[i]+"] starting");
      CheckDB()->GroundTruthSummaryTable(gtin, false, false);

      ground_truth allowed(CheckDB()->Size(), 1);
      ground_truth gtout = pv.GetGvtImages(gtin, 50, 200, allowed);

      vector<size_t> vi = gtout.indices(1);

      WriteLog(err+"["+args[i]+"] GVT result list has "+
	       ToStr(vi.size())+" images");

      for (size_t j=0; j<Nindices(); j++) {
	FloatVectorSet vset = TsSom(j).DataByIndices(vi);
	cout << "  " << IndexFullName(j) << " " << vset.Nitems() << " x "
	     << vset.VectorLength() << endl;
      }

      WriteLog(err+"["+args[i]+"] features fetched");
    }

    return true;

#else
    if (args.size()<1 && args.size()>2)
      return true;

    return ShowError(err+"USE_GVT not defined");
#endif // USE_GVT
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseOdTest(const vector<string>&
						   args) {
    string err = "AnalyseOdTest() : ";

    WriteLog(err+"database="+query->DataBaseName());

#ifdef PICSOM_USE_OD
    if (GetDataBase()) {
      if (detections.size()) {
	// bool force = true;
	string classname;
	list<string> feats;
	Segmentation *ad = NULL;

	ground_truth gt(GetDataBase()->Size());
	for (size_t i=0; i<args.size(); i++)
	  gt = gt.TernaryOR(GetDataBase()->GroundTruthExpression(args[i]));
			    
	vector<size_t> idxs = gt.indices(1);

	string instance, augm;
	XmlDom xml;
	PicSOM::detection_stat_t dstat;
	GetDataBase()->DoAllDetections(force, idxs, detections, classname,
				       instance, feats, augm,
				       tolerate_missing_features,
				       ad, xml, dstat);

      } else {
	for (size_t i=0; i<args.size(); i++) {
	  string fname = args[i];
	  savetype savemode = NO_SAVING;
	  dbitem best;
	  if (!GetDataBase()->OdProcessImage(fname, savemode, best))
	    return ShowError(err+"DataBase::OdProcessImage("+fname+") failed");
	  WriteLog("Matched keypoint pairs: "+ToStr(best.nsurvivors)+" with "+
		   best.objectname);
	}
      }
      return true;
    }

    if (args.size()<2)
      return ShowError(err+"needs at least two arguments xxx.toc image.jpg");

    string dblist_fn = args[0], index_fn;

    ObjectDetection od;
    od.Initialize();
    od.SetDebug(1);

    od.SetUsedDetector("sift");
    od.SetUsedDescriptor("sift");

    od.SetShowKeypoints(false);
    od.SetShowResults(false);
    if (!od.LoadDbs(dblist_fn, index_fn)) 
      ShowError(err+"Loading database \""+dblist_fn+"\" failed");

    for (size_t i=1; i<args.size(); i++) {
      string fname = args[i];
      savetype savemode = NO_SAVING;
      dbitem best;
      od.ProcessImage(fname, savemode, best);
      WriteLog("Matched keypoint pairs: "+ToStr(best.nsurvivors)+" with "+
	       best.objectname);
    }

    return true;

#else
    return ShowError(err+"PICSOM_USE_OD not defined -- doing really nothing "+
		     ToStr(args.size()));
#endif // PICSOM_USE_OD
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseTfIdfTest(const vector<string>&
						      args) {
    string err = "AnalyseTfIdfTest() : ";

    size_t n = 2;

    DataBase *db = GetDataBase();
    vector<size_t> ns { 1, 2, 3, 4 };
    vector<size_t> idxs = QueryRestrictionGT().indices(1);
    db->CreateIdfs("captions", idxs, ns);
    
    vector<vector<float> > vec;
    for (auto i=args.begin(); i!=args.end(); i++) {
      map<string,size_t> ngc = db->NgramCounts(*i, n);
      for (auto j=ngc.begin(); j!=ngc.end(); j++) {
	size_t k = db->NgramIndex(j->first, n);
	cout << j->first << " : " << j->second << " " << k << endl;
      }
      vector<float> tfidf = db->TfIdf(*i, n);
      db->ShowTfIdf(tfidf, n);
      vec.push_back(tfidf);
    }

    for (size_t i=0; i<vec.size()-1; i++)
      for (size_t j=i+1; j<vec.size(); j++) {
	double al = sqrt(cox::blas::dot_product(vec[i], vec[i]));
	double bl = sqrt(cox::blas::dot_product(vec[j], vec[j]));
	double cosd = cox::blas::dot_product(vec[i], vec[j])/(al*bl);
	cout << i << " vs " << j << " cosd()=" << cosd << endl;
      }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseWord2VecTest(const vector<string>&
							 args) {
    string err = "AnalyseWord2VecTest() : ";

    // string file = "/triton/ics/project/imagedb/picsom/"
    //   "share/word2vec/text8-vectors.bin";

    string model = "text8-vectors.bin";

    vector<string> words;
    for (auto i=args.begin(); i!=args.end(); i++)
      if (i->find("model=")==0)
	model = i->substr(6);
      else
	words.push_back(*i);

    string file = Picsom()->Path()+"/share/word2vec/"+model;

    const vector<string>& vocab = WordHist::word2vec_vocabulary(file);

    if (words.size()==0) {
      cout << JoinWithString(vocab, "\n") << endl;
      return true;
    }

    bool first = true;
    for (auto i=words.begin(); i!=words.end(); i++) {
      const vector<float>& w = WordHist::word2vec_raw(*i);
      if (first) {
	cout << file << " " << vocab.size() << " x " << w.size() << endl;
      }
      cout << *i << " " <<  WordHist::word2vec_index(*i)
    	   << " " << cox::blas::dot_product(w, w)
    	   << " " << sqrt(cox::blas::dot_product(w, w)) << endl;
    }

    for (auto i=words.begin(); i!=words.end(); i++) {
      const vector<float>& w1r = WordHist::word2vec_raw( *i);
      const vector<float>& w1n = WordHist::word2vec_norm(*i);
      auto j = i;
      j++;
      for (; j!=words.end(); j++) {
    	const vector<float>& w2r = WordHist::word2vec_raw( *j);
    	const vector<float>& w2n = WordHist::word2vec_norm(*j);
    	double dpr = cox::blas::dot_product(w1r, w2r);
    	double dpn = cox::blas::dot_product(w1n, w2n);
    	double edr = cox::euclidean_squared_distance(w1r, w2r);
    	double edn = cox::euclidean_squared_distance(w1n, w2n);
    	cout << *i << " " << *j << " " << dpr << " " << dpn
    	     << " " << edr << " " << sqrt(edr)
    	     << " " << edn << " " << sqrt(edn) << endl;
      }
    }
	
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseVisualGenomeTest(const vector<string>& args) {
    string err = "AnalyseVisualGenomeTest() : ";

    DataBase *db = CheckDB();

    if (args.size()==0) {
      DataBase::graph_item i1, i2, i3;
      i1.idx     = 0;
      i1.type    = DataBase::graph_item::node;
      i1.name    = "subject";
      i1.content = "man.n.01";
      i1.weight  = 0.3;
      i2.idx     = 1;
      i2.type    = DataBase::graph_item::node;
      i2.name    = "object";
      i2.content = "gym_shoe.n.01";
      i2.weight  = 0.9;
      i3.idx     = 2;
      i3.type    = DataBase::graph_item::edge;
      i3.name    = "predicate";
      i3.content = "wear.v.01";
      i3.weight  = 0.7;
      i3.links.push_back(0);
      i3.links.push_back(1);
      DataBase::graph g { i1, i2, i3 };
      db->FindByGraph("image", g, 10);
    }

    for (size_t i=0; i<args.size(); i++) {
      DataBase::graph g  = db->ReadGraph(args[i]);
      db->FindByGraph("image", g, 10);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseWordNetTest(const vector<string>&
							args) {
    string err = "AnalyseWordNetTest() : ";

    vector<pair<string,float> > h;
    h.push_back(make_pair("earth.n.01", 0.1));
    h.push_back(make_pair("man.n.01", 0.1));
    h.push_back(make_pair("woman.n.01", 0.15));
    h.push_back(make_pair("person.n.01", 0.25));
    h.push_back(make_pair("cat.n.01", 0.18));
    h.push_back(make_pair("dog.n.01", 0.22));

    DataBase *db = CheckDB();
    db->CreateWordnetOntology(h);    
    
#ifdef HAVE_WN_H
    WriteLog(err);

    if (args.size()<1)
      return ShowError(err+"at least one argument is needed");

    for (auto i=args.begin(); i!=args.end(); i++) {
      string str = *i;
      IndexPtr xx = getindex((char*)str.c_str(), NOUN);

      cout << ">>> " << *i << " " << (xx?xx->wd:"NULL") << " : " << endl;
      if (xx)
	str = xx->wd;
      
      SynsetPtr ss = findtheinfo_ds((char*)str.c_str(),
				    NOUN, HYPERPTR, ALLSENSES);
      size_t pno = 1;
      for (auto p=ss; p; p=p->nextss, pno++) {
	size_t sno = 1;
	for (auto s=p; s; s=s->ptrlist, sno++) {
	  cout << pno << "." << sno << " : ";
	  for (int i=0; i!=s->wcount; i++) {
	    string word = s->words[i];
	    cout << word << " ";
	  }
	  cout << endl;
	}
      }
      free_syns(ss);
    }

#ifdef HAVE_WNSIM_H
    //if (args.size()>=2) {
    if (args.size()>=1) {
      WNSim wnsim(Picsom()->RootDir("linux64/dict", true));
      if (wnsim.LoadingWN()==0) {
	cerr << "ERROR: Unable to load WordNet." << endl;
	return false;
      }

      if (true) {
	for (size_t ai=0; ai<args.size()-1; ai++) {
	  _myshortest dis;
	  string t1=args[ai], t2=args[ai+1];
	  int lcs;
	  string msg;
	  string pos;
	  float score;

	  //wnsim.print_vector_string(lexicon[t1]);
	  //wnsim.print_vector_string(lexicon[t2]);
	  score=wnsim.WSM(t1,t2,dis,lcs,pos,msg);
	  if (dis.length==-1) {
	    cout << t1 << "\t" << t2 << "\t" << "No connection" << endl;
	    if (!msg.empty())
	      cout << msg << endl;
	  }
	  else {
	    //cout << t1 << "\t" << t2 << "\t" << dis.length << "\t" << dis.n1 << "\t" << dis.n2 << "\t" << lcs << endl;
	    cout << "Word pair: (" << t1 << "," << t2 << "), POS=" << pos << endl;
	    cout << "\tShortest length: " << dis.length << endl;
	    cout << "\tn1: " << dis.n1 << endl;
	    cout << "\tn2: " << dis.n2 << endl;
	    cout << "\tLCS depth: " << lcs << endl;
	    if( lcs >= 0 ) {
	      cout << "\tSynset of the LCS: ";
	      wnsim.print_vector_string((wnsim.getNode(dis.lcs,pos)).s_words);
	    }
	    cout << "\tSimilarity score: " << score << endl;
	  }
	}
      }

      if (true) {
	string t1=args[0];
	float score = 0.0;
	for (size_t i=1; i<args.size(); i++) {
	  string concepts = args[i];
	  int lcs;
	  _myshortest dis;
	  string msg;
	  string pos;
	  cout << "Word pair: (" << t1 << "," << concepts << "), POS=" << pos << endl;
	  if (concepts.find_first_of("_") != concepts.npos ){
	    vector<string> words = SplitInSomething("_", false, concepts);
	    size_t i = 0 ;
	    while( i < words.size()){
	      score=score + wnsim.WSM(t1,words[i],dis,lcs,pos,msg);
	      i++;
	    }
	    cout << "\tSimilarity score: " << score/i << endl;	
	  }else if(concepts.find_first_of("-") != concepts.npos ){
	    vector<string> words = SplitInSomething("-", false, concepts);
	    size_t i = 0 ;
	    while( i < words.size()){
	      score=score + wnsim.WSM(t1,words[i],dis,lcs,pos,msg);
	      i++;
	    }                        
	    cout << "\tSimilarity score: " << score/i << endl;

	  }else{

	    score=wnsim.WSM(t1,concepts,dis,lcs,pos,msg);
	    cout << "\tSimilarity score: " << score << endl;

	  }	
	} 
      }
    }
#endif // HAVE_WNSIM_H
    return true;

#else
    return ShowError(err+"WordNet not available, nargs="+ToStr(args));
#endif // HAVE_WN_H
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSparqlTest(const vector<string>&
						       args) {
    string err = "AnalyseSparqlTest() : ";
    WriteLog(err);

    if (args.size()<1)
      return ShowError(err+"at least one argument is needed");

    vector<string> xargs(args.begin()+1, args.end());

    list<vector<string> > res
      = GetDataBase()->LinkedDataQuery("sparql", args[0],
				       xargs);

    cout << "returned :" << endl;
    for (auto i=res.begin(); i!=res.end(); i++) {
      for (auto j=i->begin(); j!=i->end(); j++)
	cout << "[" << *j << "] ";
      cout << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseRdfTest(const vector<string>&
						    args) {
    string err = "AnalyseRdfTest() : ";
    WriteLog(err);

    for (auto r=args.begin(); r!=args.end(); r++) {
      list<vector<string> > res = GetDataBase()->LinkedDataQuery("rdf", *r);

      cout << endl << "[" << *r << "] returned :" << endl;
      for (auto i=res.begin(); i!=res.end(); i++) {
	for (auto j=i->begin(); j!=i->end(); j++)
	  cout << "[" << *j << "] ";
	cout << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseOpenCvTest(const vector<string>&
						       args) {
    string err = "AnalyseOpenCvTest() : ";

    WriteLog(err+ToStr(args.size())+" arguments");

#if defined(HAVE_OPENCV2_CORE_CUDA_HPP) && defined(PICSOM_USE_OPENCV)
    int ncuda = cv::cuda::getCudaEnabledDeviceCount();
    if (ncuda==0) {
      WriteLog("no CUDA support in OpenCV library");
      return true;
    }
    if (ncuda==-1) {
      WriteLog("no CUDA devices found");
      return true;
    }
    WriteLog(ToStr(ncuda)+" CUDA devices found");

    return true;
#else
    bool dummy = args.size(); dummy = !dummy;
    return ShowError(err+"either HAVE_OPENCV2_CORE_GPUMAT_HPP "
		     "or PICSOM_USE_OPENCV not defined");
#endif // HAVE_OPENCV2_CORE_CUDA_HPP && PICSOM_USE_OPENCV
  }

  /////////////////////////////////////////////////////////////////////////////

  namespace cuda {
    extern vector<string> test(const vector<string>&);
    extern vector<string> try_vecAdd(const vector<string>&);
  }

  Analysis::analyse_result Analysis::AnalyseCudaTest(const vector<string>&
						     args) {
    string err = "AnalyseCudaTest() : ";

    WriteLog(err+ToStr(args.size())+" arguments");

    // obs! uncomment only if cuda-Analysis.o linked...
    // vector<string> a = cuda::test(args);
    // vector<string> b = cuda::try_vecAdd(args);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalysePythonTest(const vector<string>&){
    string msg = "AnalysePythonTest() : ";

#ifdef PY_VERSION

    // http://www.codeproject.com/Articles/11805/Embedding-Python-in-C-C-Part-I

    string pd = Picsom()->UserHomeDir()+"/picsom/python";
    
    PyObject *path = PySys_GetObject((char*)"path");
    PyObject *dir  = PyString_FromString_x(pd.c_str());
    if (PyList_Insert(path, 0, dir))
      return ShowError(msg+"PyList_Insert() failed");

    PyObject *pName = PyString_FromString_x("picsom_bin_data");
    PyObject *pModule = PyImport_Import(pName);
    PyObject *pDict = PyModule_GetDict(pModule);
    PyObject *pClass = PyDict_GetItemString(pDict, "picsom_bin_data");
    
    if (!PyCallable_Check(pClass)) {
      PyErr_Print();
      return ShowError(msg+"PyCallable_Check");
    }

    string ff = Picsom()->Path()+
      "/databases/trecvid2018/features/sun-397-c_plpl_g_cls3pool_d_aA3.bin";
    PyObject *pArg = PyString_FromString_x(ff.c_str());
    if (!pArg) {
      if (PyErr_Occurred())
	PyErr_Print();
      return ShowError(msg+"A");
    }

    PyObject *pArgs = PyTuple_New(1);
    PyTuple_SetItem(pArgs, 0, pArg);

    PyObject *pInstance = PyObject_CallObject(pClass, pArgs); 
    PyObject *pValue = NULL;
    pValue = PyObject_CallMethod(pInstance, (char*)"str", NULL);
    Py_DECREF(pValue);
    pValue = PyObject_CallMethod(pInstance, (char*)"format_str", NULL);
    printf("Data type: %s\n", PyString_AsString_x(pValue));
    Py_DECREF(pValue);
    pValue = PyObject_CallMethod(pInstance, (char*)"vdim", NULL);
    printf("Data dimension: %ld\n", PyInt_AsLong_x(pValue));
    Py_DECREF(pValue);
    pValue = PyObject_CallMethod(pInstance, (char*)"nobjects", NULL);
    printf("Data count: %ld\n", PyInt_AsLong_x(pValue));
    Py_DECREF(pValue);

    pArg = PyInt_FromLong_x(0);
    if (!pArg) {
      if (PyErr_Occurred())
	PyErr_Print();
      return ShowError(msg+"B");
    }

    pValue = PyObject_CallMethod(pInstance, (char*)"get_float", (char*)"(i)", 5794);
    if (PyErr_Occurred()) {
      PyErr_Print();
      return ShowError(msg+"C");
    }
    if (!PyList_Check(pValue)) {
       PyErr_Print();
      return ShowError(msg+"D");
    }
    size_t d = PyList_Size(pValue);
    printf("Read vector dim.: %ld\n", d);
    for (size_t i=0; i<10 && i<d; i++) {
      PyObject *c = PyList_GetItem(pValue, i);
      if (!PyFloat_Check(c)) {
	PyErr_Print();
	return ShowError(msg+"E");
      }
      printf("%g ", PyFloat_AsDouble(c));
      Py_DECREF(c);
    }
    printf("\n");

    //printf("Data count: %ld\n", PyInt_AsLong(pValue));
    Py_DECREF(pValue);
    
    return true;

#else
    // bool dummy = args.size(); dummy = !dummy;
    return ShowError(msg+"PY_VERSION not defined");
#endif // PY_VERSION
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseTensorFlowTest(const vector<string>&
						     args) {
    string err = "AnalyseTensorFlowTest() : ";

    WriteLog(err+ToStr(args.size())+" arguments");

    // https://medium.com/jim-fleming/loading-a-tensorflow-graph-with-the-c-api-4caaff88463f#.luojlif3i

    string binproto = "../tensorflow/models/graph.pb";
    // string binproto = "tf-test.pb";

#ifdef TF_VERSION_STRING
    using namespace tensorflow;
    Env *env = Env::Default();
    vector<string> schemes;
    Status status = env->GetRegisteredFileSystemSchemes(&schemes);
    cout << "status=" << status << endl;
    cout << "#schemes=" << schemes.size() << endl;
    for (auto i=schemes.begin(); i!=schemes.end(); i++)
      cout << "  " << *i << endl;

    SessionOptions sesopt = SessionOptions();
    cout << "A [" << sesopt.target << "]" << endl;
    // obs! the following doesn't work:
    sesopt.target = "/gpu:0";

    // E tensorflow/core/common_runtime/session.cc:69] Not found:
    // No session factory registered for the given session options:
    // {target: "/gpu:0" config: log_device_placement: true}
    // Registered factories are {GRPC_SESSION, DIRECT_SESSION}.

    // obs! could this be of help: ./tensorflow/core/common_runtime/device.h
    // I tensorflow/core/common_runtime/gpu/gpu_init.cc:102] Found device 0 with properties: 

    cout << "B [" << sesopt.target << "]" << endl;

    cout << sesopt.config.log_device_placement() << endl;
    sesopt.config.set_log_device_placement(true);
    cout << sesopt.config.log_device_placement() << endl;

    Session *session;
    status = NewSession(sesopt, &session);
    if (!status.ok()) {
      cout << status << endl;
      return false;
    }
    // session->log_device_placement = true;

    cout << "session created" << endl;

    GraphDef graph_def;
    status = ReadBinaryProto(env, binproto, &graph_def);
    if (!status.ok()) {
      cout << status << endl;
      return false;
    }

    status = session->Create(graph_def);
    if (!status.ok()) {
      cout << status << endl;
      return false;
    }

    Tensor a(DT_FLOAT, TensorShape());
    a.scalar<float>()() = 3.0; 

    Tensor b(DT_FLOAT, TensorShape());
    b.scalar<float>()() = 2.0; 

    vector<pair<string, Tensor>> inputs = {
      { "a", a },
      { "b", b },
    };

    // The session will initialize the outputs
    vector<Tensor> outputs;

    // Run the session, evaluating our "c" operation from the graph
    status = session->Run(inputs, {"c"}, {}, &outputs);
    if (!status.ok()) {
      cout << status << endl;
      return false;
    }

    // Grab the first output (we only evaluated one graph node: "c")
    // and convert the node to a scalar representation.
    auto output_c = outputs[0].scalar<float>();
  
    // (There are similar methods for vectors and matrices here:
    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/public/tensor.h)

    // Print the results
    cout << outputs[0].DebugString() << endl; // Tensor<type: float shape: [] values: 30>
    cout << output_c() << endl; // 30

    // Free any resources used by the session
    session->Close();

    return true;

#else
    return ShowError(err+"TF_VERSION_STRING not defined");
#endif // TF_VERSION_STRING
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseJaulaTest(const vector<string>&
						     args) {
    string err = "AnalyseJaulaTest() : ";

    WriteLog(err);

#if defined(HAVE_JAULA_H) && defined(PICSOM_USE_JAULA)
    WriteLog(err+"JAULA rules");

    for (size_t i=0; i<args.size(); i++) {
      cout << "Starting with <" << args[i] << ">" << endl;

      ifstream istr(args[i]);
      JAULA::Value_Complex *doc = JAULA::Parser::parseStream(istr);
      cout << doc->size() << " " << (int)doc->getType()
	   << endl;
      if (doc->getType()==JAULA::Value::TYPE_OBJECT) {
	const JAULA::Value_Object& o
	  = *dynamic_cast<JAULA::Value_Object*>(doc);
	auto& m = o.getData();
	cout << m.size() << endl;
	for (auto j=m.begin(); j!=m.end(); j++)
	  cout << j->first << endl;
	auto p = m.find("images");
	if (p!=m.end()) {
	  const JAULA::Value_Array& a
	    = *dynamic_cast<JAULA::Value_Array*>(p->second);
	  auto& l = a.getData();
	  for (auto k=l.begin(); k!=l.end(); k++) {
	    const JAULA::Value_Object& img
	      = *dynamic_cast<JAULA::Value_Object*>(*k);
	    const JAULA::Value_String& s
	      = *dynamic_cast<JAULA::Value_String*>(img.getData().at("id"));
	    cout << s.getData() << endl;
	  }
	}
      }

      //auto l = (*doc).getData();
      // for (auto a=l.begin(); a!=l.end(); a++)
      // 	cout << (*a)
      delete doc;
    }

    return true;
#else
    return ShowError(err+"PICSOM_USE_JAULA not defined, nargs="+ToStr(args));
#endif // PICSOM_USE_JAULA && HAVE_JAULA_H
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseObjectSetTest(const vector<string>& args) {
    string err = "AnalysObjectSetTest() : ";

    if (args.size()!=1)
      return ShowError(err+"exactly one argument expected");

    bool test_set   = args[0].find("set")!=string::npos;
    bool test_deque = args[0].find("deque")!=string::npos;
    bool test_map   = args[0].find("map")!=string::npos;
    bool test_batch = args[0].find("batch")!=string::npos;
    bool test_unord = args[0].find("unord")!=string::npos;
    bool test_hash  = args[0].find("hash")!=string::npos;
    bool test_buck  = args[0].find("buck")!=string::npos;
    bool test_fail  = false;

    // resembles trecvid2013med

    size_t n = 20000000;
    size_t f = 131;

    object_set oset;
    deque<object_info> deque;
    map<string,object_info*> map;
    unordered_map<string,object_info*> unord_map;

    list<pair<string,object_info*> > map_list;
    set<size_t> buck;

    target_type tt = target_no_target;
    struct timespec now = TimeNow();
    for (size_t i=0; i<n; i++) {
      // string lab = "00000000"+ToStr(i/f);
      // lab.erase(0, lab.size()-8);
      // if (i%f)
      // 	lab += ":s"+ToStr(i%f-1);

      char lab[100];
      sprintf(lab, "%08d", int(i/f));
      if (i%f)
	sprintf(lab+strlen(lab), ":s%d", int(i%f-1));
      
      if (verbose>1)
	cout << "#" << i << " " << lab << endl;

      if (test_set) {
	oset.add(NULL, lab, tt);
	if (test_fail)
	  oset.add(NULL, lab, tt);
      }
      if (test_deque)
	deque.push_back(object_info(NULL, deque.size(), lab, tt));
      if (test_map)
	map.insert(make_pair(lab, (object_info*)NULL));
      if (test_unord)
	unord_map.insert(make_pair(lab, (object_info*)NULL));
      if (test_batch)
	map_list.push_back(make_pair(lab, (object_info*)NULL));
      if (test_hash || test_buck) {
	size_t h = unord_map.hash_function()(string(lab));
	if (test_buck)
	  buck.insert(h);
      }
    }

    if (test_batch) {
      WriteLog(" ... now starting batch insert");
      map.insert(map_list.begin(), map_list.end());
    }

    struct timespec end = TimeNow();
    float secf = TimeDiff(end, now);
    WriteLog("Testing "+string(test_set?"object_set::add() ":"")
	     +(test_deque?"deque::push_back() ":"")
	     +(test_map?"map::insert() ":"")
	     +(test_hash?"hash ":"")
	     +(test_buck?"buck ":"")
	     +(test_unord?"unordered_map::insert() ":"")
	     +(test_batch?"map::insert() batch ":"")
	     +ToStr(n)+" objects took "+ToStr(secf)+" seconds, "
	     +ToStr(n/secf)+"/s");

    if (buck.size())
      WriteLog(ToStr(buck.size())+" unique hash values found");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseErfData(const vector<string>&
                                                    /*args*/) {
    string msg = "AnalyseErfData() : ";

    WriteLog("AnalyseErfData");

    if (!query)
      return ShowError(msg+"query not set");

    if (!query->ErfShowDataAndRecurse())
      return ShowError(msg+"ErfShowDataAndRecurse() failed");

    DataBase *db = CheckDB();
    ground_truth pos = PositiveGT();
    db->GroundTruthSummaryTable(pos);

    size_t n_speech = 0, n_menu = 0;
    size_t n_tot = 0, n_is_corr = 0, n_end_corr_or = 0, n_end_corr_last = 0;
    size_t n_tag = 0, n_retag = 0, n_corr_tag = 0, n_incorr_tag = 0;
    size_t n_try = 0, n_succ = 0;

    size_t round = 0;
    for (Query *q=query; q && round<5; round++) {
      cout << "query=" << q->Identity() << endl;

      for (size_t i=0; i<q->NnewObjects(); i++) {
	const Object& o = q->NewObject(i);
	if (!o.Retained())
	  continue;
	cout << "   " << o.Label();
	n_tot++;

	bool is_corr = pos[o.Index()]==1;
	n_is_corr += is_corr;
	if (pos.size())
	  cout << " " << pos.label() << "=" << is_corr;

	string ss;
	const map<string,string>& smap = q->ErfDataSpeechString();
	const map<string,string>& tmap = q->ErfDataTagString();
	map<string,string>::const_iterator si = smap.find(o.Label());
	map<string,string>::const_iterator ti = tmap.find(o.Label());
	if (si==smap.end() && ti==tmap.end())
	  return ShowError(msg+"neither speechstring nor tagstring found");

	if (ti!=tmap.end() && ti->second!="") {
	  n_menu++;
	  ss = ti->second;
	}
	if (si!=smap.end() && si->second!="") {
	  n_speech++;
	  ss = si->second;
	}

	bool end_corr_or   = is_corr;
	bool end_corr_last = is_corr;

	for (;;) {
	  size_t p = ss.find('+');
	  if (p==string::npos)
	    break;
	  ss[p] = ' ';
	}

	vector<string> sv = SplitInSpaces(ss);

	if (sv.size())
	  n_tag++;
	if (sv.size()>1)
	  n_retag++;

	if (sv.size()) {
	  if (is_corr)
	    n_corr_tag++;
	  else
	    n_incorr_tag++;
	}

	n_try += sv.size();

	for (size_t j=0; j<sv.size(); j++) {
	  string a = sv[j];
	  for (size_t k=0; k<a.size(); k++)
	    if (a[k]>='A' && a[k]<='Z')
	      a[k] = char(a[k]+32);
	  for (;;) {
	    size_t p = a.find('-');
	    if (p==string::npos)
	      break;
	    a.erase(p, 1);
	  }
	  string aone = a+"#1";
	  ground_truth gta = GTExpr(aone);
	  bool to_corr = gta[o.Index()]==1;
	  cout << " " << a << "=" << to_corr;
	  end_corr_last = to_corr;
	  end_corr_or  |= to_corr;
	  n_succ += to_corr;
	}
	n_end_corr_last += end_corr_last;
	n_end_corr_or   += end_corr_or;

	cout << " -> " << end_corr_or << "/" << end_corr_last << endl;
      }
      cout << endl;

      if (!q->Nchildren())
	break;
      size_t c = q->Nchildren()-1;
      q = q->Child(c);
    }

    if (round!=5)
      return ShowError(msg+"query "+query->Identity()+" didn't have 5 rounds");

    if (n_speech && n_menu)
      return ShowError(msg+"speechstring and tagstring mixed");
      
    string ttype = n_speech ? "speech " : n_menu ? "menu   " : "unknown";

    string xxxlabel = pos.label();
    while (xxxlabel.size()<11)
      xxxlabel += ' ';

    string n_tag_str   = ToStr(n_tag);
    while (n_tag_str.size()<2)
      n_tag_str.insert(0, " ");

    string n_retag_str = ToStr(n_retag);
    while (n_retag_str.size()<2)
      n_retag_str.insert(0, " ");

    string n_corr_tag_str = ToStr(n_corr_tag);
    while (n_corr_tag_str.size()<2)
      n_corr_tag_str.insert(0, " ");

    string n_incorr_tag_str = ToStr(n_incorr_tag);
    while (n_incorr_tag_str.size()<2)
      n_incorr_tag_str.insert(0, " ");

    string n_try_str = ToStr(n_try);
    while (n_try_str.size()<2)
      n_try_str.insert(0, " ");

    string n_succ_str = ToStr(n_succ);
    while (n_succ_str.size()<2)
      n_succ_str.insert(0, " ");

    string qident = query->Identity();
    while (qident.size()<24)
      qident += " ";

    cout << "TAGS: " << qident << " " << ttype << " " << xxxlabel
	 << " " << n_tot << " " << n_is_corr // << " " << n_end_corr_last
	 << " " << n_tag_str << " " << n_retag_str
	 << " " << n_corr_tag_str << " " << n_incorr_tag_str
      	 << " " << n_try_str << " " << n_succ_str
	 << " " << n_end_corr_or << endl << endl;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseExtractRawFeatures(const vector<string>& arg) {
    string msg = " Analysis::AnalyseExtractRawFeatures() : ";

    WriteLog("AnalyseExtractRawFeatures");

    if (Nindices()!=1)
      return ShowError(msg+"exactly one feature/index should be specified");

    if (filename=="")
      return ShowError(msg+"filename should be specified");

    if (arg.size()!=1)
      return ShowError(msg+"vectorlength argument should be given");

    size_t vl = atoi(arg[0].c_str());
    if (vl==0)
      return ShowError(msg+"vectorlength==0");

    VectorIndex& feat = CheckQuery()->vectorIndex(0);

    ground_truth gt = QueryRestrictionGT();
    vector<size_t> vidx = gt.indices(1);
    if (vidx.size()==0)
      return ShowError(msg+"empty set by queryrestriction");

    Unlink(filename);
    bin_data bin(filename, true, bin_data::header::format_float,
		 4*8*vl, vl);

    WriteLog("Starting to extract raw \""+feat.Name()+"\" features from "
	     +ToStr(vidx.size())+" objects");

    list<incore_feature_t> incore;
    set<string> done;
    XmlDom xml;
    feat.CalculateFeatures(vidx, incore, done, xml, &bin);
    
    WriteLog("Extracted and stored "+ToStr(bin.nobjects())+" raw \""
	     +feat.Name()+"\" features in <"+bin.filename()+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseExtractLfwFaces(const vector<string>& args) {
    string msg = " Analysis::AnalyseExtractLfwFaces() : ";

    WriteLog("AnalyseExtractLfwFaces");

    DataBase *db = GetDataBase();
    
    for (auto i=args.begin(); i!=args.end(); i++) {
      string lorig = *i, l = lorig;
      size_t p = l.find('_');
      if (p==string::npos)
	return ShowError(msg+"no _ found in \""+l+"\"");

      string f = l.substr(p+1);
      l.erase(p);

      p = l.find(':');
      if (p==string::npos)
	return ShowError(msg+"no : found in \""+lorig+"\"");
      
      string m = l.substr(0, p);
      l.erase(0, p+1);

      int idx = db->LabelIndex(l);
      string sf = db->SolveSegmentFilePath(idx, m, true);
      if (sf=="")
	return ShowError(msg+"segment file for <"+lorig+"> not found");

      segmentfile seg("", sf);
      imagedata img = db->ImageData(db->LabelIndex(l));
      imagedata piece = db->ExtractLfwFace(img, seg, 0, f);
      if (piece.empty())
	return ShowError(msg+"empty image for \""+lorig+"\"");

      imagefile::write(piece, lorig+".png");      
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseDisplay(const vector<string>&
						    args) {
    string msg = "AnalyseDisplay() : ";

    bool show_info = true, show_auxid = true;
    bool use_virtual_image_method = false;
    bool loop_video = true;
    float fontsize = 15;
    
    WriteLog("AnalyseDisplay");

    map<target_type,string> prog;
    // prog[target_image] = "eog";
    // prog[target_image] = "display";
    prog[target_image]    = "*picsom::imagefile*";
    prog[target_imageset] = "*picsom::imagefile*";
    if (!loop_video)
      prog[target_video]  = "mplayer -use-filename-title";
    else
      prog[target_video]  = "mplayer -use-filename-title -loop 0";

    DataBase *db = GetDataBase();

    ground_truth gt(db->Size());
    for (size_t i=0; i<args.size(); i++) {
      ground_truth gti = db->GroundTruthExpression(args[i]);
      gt = gt.TernaryOR(gti);
    }
    vector<size_t> gto = gt.indices(1);

    for (size_t oi=0; oi<gto.size(); oi++) {
      size_t o = gto[oi];
      cout << o << ": " << db->ObjectDump(o) << endl;
      cout << "    ismissing=" << db->IsMissingObject(o)
	   << " videoclip="    << db->IsVideoClip(o)
	   << " audioclip="    << db->IsAudioClip(o)
	   << " videoframe="   << db->IsVideoFrame(o)
	   << " imagesegment=" << db->IsImageSegment_new(o)
	   <<  endl;
      
      string f;

      if (use_virtual_image_method && db->IsImageSegment_new(o)) {
	const string& label = db->Label(o);
	int pidx = db->ParentObjectByPruning(label);
	map<string,string> m = db->ReadOriginsInfoSql(pidx);
	string spec = m["width"]+"x"+m["height"];
	imagedata imgd = db->CreateVirtualImage(o, spec);
	cout << imgd.info() << endl;
	f = db->TempFile("segmimg/"+label+".png");
	imagefile::write(imgd, f);

      } else {

	try {
	  vector<size_t> idxv { o };
	  list<string> l = db->ObjectPathsEvenExtract(idxv, true);
	  if (l.size()==1)
	    f = l.front();

	} catch (const string& err) {
	  return ShowError(msg+err);
	}
      }

      if (f=="") {
	ShowError(msg+"failed to extract object file for <"+Label(o)+">");
	continue;
      }

      for (auto i=prog.begin(); i!=prog.end(); i++)
	if (db->ObjectsTargetTypeContains(o, i->first)) {
	  if (i->second=="*picsom::imagefile*") {
	    try {
	      imagefile imgf(f);
	      cout << imgf.info() << endl;
	      for (int frame=0; frame<imgf.nframes(); frame++) {
		imagedata img = imgf.frame(frame), out;
		if (show_info) {
		  string text = db->Label(o)+" #"+ToStr(o);
		  if (show_auxid) {
		    map<string,string> oi = db->ReadOriginsInfoSql(o);
		    string auxid = oi["auxid"];
		    if (auxid!="")
		      text += " "+auxid;
		  }
		  if (imgf.nframes()>1)
		    text += " frame "+ToStr(frame)+"/"+ToStr(imgf.nframes());
		  
		  imagedata txt = imagefile::render_text(text, fontsize);
		  txt.force_three_channel();
		  txt.convert(imagedata::pixeldata_float);
		  out = imagedata(img.width(), img.height()+txt.height()+4,
				  img.count(), img.type());
		  out.copyAsSubimage(txt, 5, 2);
		  out.copyAsSubimage(img, 0, txt.height()+4);
		} else
		  out = img;
		
		char key = 'x';
		imagefile::display(out, &key);
		cout << "KEY " << key << " " << db->Label(o) << endl;
		if (key=='q' || key=='x' || key == '\e')
		  break;
	      }
	      
	    } catch (const string& etxt) {
	      return ShowError(msg+"reading and displaying <"+f+
			       "> failed: "+etxt);
	    }
	  } else {
	    string cmd = i->second+" "+f;
	    Picsom()->ExecuteSystem(cmd, true, true, true);
	  }
	  break;
	}
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseExtractMedia(const vector<string>&
							 args) {
    string msg = "AnalyseExtractMedia() : ";

    bool try_one_call = true;

    WriteLog("AnalyseExtractMedia");
    // ReadFiles(false);
    DataBase *db = GetDataBase();

    ground_truth gt(db->Size());
    map<size_t,vector<size_t> > bb;

    if (args.size()==0)
      gt = QueryRestrictionGT();
    else {
      if (args.size()==1 && args[0]=="-") {
	WriteLog("Starting to read objects + optional bounding boxes "
		 "from standard input");
	size_t n_lines = 0, n_duplicate = 0;
	for (;;) {
	  string line;
	  getline(cin, line);
	  if (!cin)
	    break;
	  vector<string> v = SplitInSpaces(line);
	  if (v.size()!=1 && v.size()!=5)
	    return ShowError(msg+"# words != 1|5 in\""+line+"\"");
	  size_t o = db->LabelIndex(v[0]);
	  n_lines++;
	  if (gt[o]==1)
	    n_duplicate++;
	  gt[o] = 1;
	  v.erase(v.begin());
	  vector<size_t> vi;
	  for (size_t i=0; i<v.size(); i++)
	    vi.push_back(atoi(v[i].c_str()));
	  if (vi.size()==4)
	    bb[o] = vi;
	}
	WriteLog("Read "+ToStr(n_lines)+" lines of which "+ToStr(n_duplicate)
		 +" were duplicates");	

      } else
	for (size_t i=0; i<args.size(); i++) {
	  ground_truth gta = db->GroundTruthExpression(args[i]);
	  gt = gt.TernaryOR(gta);
	  // gt[db->LabelIndex(args[i])] = 1;
	}
    }

    vector<size_t> gto = gt.indices(1);
    WriteLog("Starting to extract "+ToStr(gto.size())+" objects");
    size_t n_not_missing = 0, n_existed = 0, n_tar = 0, n_videoframe = 0;
    size_t n_bb = 0;

    vector<size_t> one_call;

    for (size_t oi=0; oi<gto.size(); oi++) {
      size_t o = gto[oi];
      cout << o << ": " << db->ObjectDump(o) << endl;
      cout << "    ismissing=" << db->IsMissingObject(o)
	   << " videoclip="    << db->IsVideoClip(o)
	   << " audioclip="    << db->IsAudioClip(o)
	   << " videoframe="   << db->IsVideoFrame(o)
	   << " imagesegment=" << db->IsImageSegment_new(o)
	   << " imagefromcontainer=" << db->IsImageFromContainer(o)
	   <<  endl;

      map<string,string> m = db->ReadOriginsInfo(o, false, true);
      string d = m["filename"];
      if (d=="")
	d = db->Label(o)+".jpeg";
	
      if (!db->IsMissingObject(o)) {
	n_not_missing++;
	// not missing...

      } else if (FileSize(d)>0) {
	WriteLog("File <"+d+"> already exists");
	n_existed++;

      } else if (db->IsImageFromContainer(o)) {
	string s = db->ObjectPathEvenExtract(o);
	CopyFile(s, d);

	WriteLog("Extracted <"+d+"> from a container");
	n_tar++;

	if (bb.find(o)!=bb.end()) {
	  const vector<size_t>& vi = bb[o];
	  imagedata img = imagefile(s).frame(0);
	  size_t tlx = vi[0];
	  size_t tly = vi[1];
	  size_t brx = vi[2];
	  size_t bry = vi[3];
	  if (brx>=img.width())
	    brx = img.width()-1;
	  if (bry>=img.height())
	    bry = img.height()-1;

	  imagecolor<float> red("red"); 
	  for (size_t x=tlx; x<=brx; x++) {
	    img.set(x, tly, red);
	    img.set(x, bry, red);
	  }
	  for (size_t y=tly; y<=bry; y++) {
	    img.set(tlx, y, red);
	    img.set(brx, y, red);
	  }
	  string dbb = db->Label(o)+"-bb.jpeg";
	  imagefile::write(img, dbb);

	  WriteLog("Created <"+dbb+"> to show the bounding box");
	  n_bb++;
	}

      } else {
	target_type dt = db->ObjectsTargetType(o);
	dt = PicSOM::TargetTypeMasked(dt, true);

	/// obs! until 2016-12-13 this was unconditional...
	/// but it didn't work for exrating frames from videos
	if (dt==target_video)
	  db->ExtractMediaClip(o, dt, true);

	if (try_one_call)
	  one_call.push_back(o);

	if (!try_one_call && filename!="") {
	  string ext = "foo";
	  if (dt==target_image)
	    ext = "jpeg";
	  string fname = filename+Label(o)+"."+ext;
	  string opath = db->ObjectPathEvenExtract(o);
	  if (verbose>1)
	    cout << "... extracted in <"+opath+">" << endl;
	  if (!CopyFile(opath, fname))
	    ShowError(msg+"failed to copy <"+opath+"> to <"+fname+">");
	  else {
	    WriteLog("Extracted media file <"+fname+">");
	    n_videoframe++;
	  }
	}
      }
    }
    
    if (one_call.size()) {
      size_t j = 0;
      list<string> pl = db->ObjectPathsEvenExtract(one_call);
      for (auto i=pl.begin(); i!=pl.end(); i++, j++) {
	size_t o = one_call[j];
	target_type dt = db->ObjectsTargetType(o);
	dt = PicSOM::TargetTypeMasked(dt, true);
	string ext = "foo";
	if (dt==target_image)
	  ext = "jpeg";

	if (verbose>1)
	  cout << "... #" << o << " <" << db->Label(o)
	       << "> extracted in <"+*i+">" << endl;
	string fname = filename+Label(o)+"."+ext;
	if (!CopyFile(*i, fname))
	  ShowError(msg+"failed to copy <"+*i+"> to <"+fname+">");
	else {
	  WriteLog("Extracted media file <"+fname+">");
	  n_videoframe++;
	}
      }
    }
  
    WriteLog("Done with "+ToStr(n_not_missing)+" not missing, "+
	     ToStr(n_existed)+" existed, "+ToStr(n_tar)+" from tar, "+
	     ToStr(n_videoframe)+" from video, "+ToStr(n_bb)+
	     " bounding boxes");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseExtractVideoThumbnails(const vector<string>& argv) {
    string msg = "AnalyseExtractVideoThumbnails() : ";

    WriteLog("AnalyseExtractVideoThumbnails");
    DataBase *db = GetDataBase();

    ground_truth gt(db->Size());
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }

    gt = gt.TernaryAND(QueryRestrictionGT());
    vector<size_t> vidx = gt.indices(1);

    for (size_t i=0; i<vidx.size(); i++) {
      size_t vvidx = vidx[i];
      // cout << "  #" << vvidx << " <" << db->Label(vidx[i]) << "> "; 
      pair<string,string> tnpathotyp = db->ThumbnailPath(vvidx, true);
      string path = tnpathotyp.first, mime = tnpathotyp.second;
      // cout << path << " " << FileSize(path) << endl;
      if (FileSize(path)>0)
	WriteLog("Thumbnail <"+db->ShortFileName(path)+"> exists");
      else {
	size_t w = 0, h = 0;
	size_t p = path.find("/tn-");
	if (p==string::npos)
	  return ShowError(msg+"'/tn-' not found in \""+path+"\"");
	w = atoi(path.substr(p+4).c_str());
	p = path.find('x', p+4);
	if (p==string::npos)
	  return ShowError(msg+"'x' not found in \""+path+"\"");
	h = atoi(path.substr(p+1).c_str());

	auto fl = db->VideoOrSegmentFramesOrdered(vvidx);
	if (fl.size()==0)
	  return ShowError(msg+"no frames in #"+ToStr(vvidx));
	size_t fidx = fl[fl.size()/2].first;
	if (!db->ObjectsTargetTypeContains(fidx, target_image))
	  return ShowError(msg+"not an image #"+ToStr(fidx));

	string fpath = db->ObjectPathEvenExtract(fidx);
	if (fpath=="")
	  return ShowError(msg+"empty path for #"+ToStr(fidx));
	
	if (FileSize(fpath)<0)
	  return ShowError(msg+"empty image for #"+ToStr(fidx));

	p = path.rfind('/');
	if (p!=string::npos &&
	    !Picsom()->MkDirHier(path.substr(0, p), 02775))
	  return ShowError(msg+"failed to create dir for <"+path+">");

	imagedata img = imagefile(fpath).frame(0);
	scalinginfo si(img.width(), img.height(), w, h);
	si.stretch(true);
	img.rescale(si);
	imagefile::write(img, path);
	if (FileSize(path)<1)
	  return ShowError(msg+"writing <"+path+"> failed");

	WriteLog("Extracted <"+db->ShortFileName(path)+">");
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseCheckSums(const vector<string>&
						      args) {
    string msg = "AnalyseCheckSums() : ";

    WriteLog("AnalyseCheckSums");

    if (args.size()!=1)
      return ShowError(msg+"one argument should be given");

    ifstream is(args[0]);
    if (!is)
      return ShowError(msg+"one argument should be given");

    map<string,string> ref;
    set<string> lab;

    for (;;) {
      string line;
      getline(is, line);
      if (!is)
	break;
      vector<string> c = SplitInCommas(line);
      if (c.size()!=5)
	return ShowError(msg+"number of columns != 5 in ["+line+"]");
	  
      size_t p = c[0].find('"');
      string label = "00"+c[0].substr(p+1, 6);
      string md5 = c[3].substr(1, 32);

      if (ref.find(label)!=ref.end() && ref[label]!=md5)
	return ShowError(msg+"multiple md5sums for <"+label+"> : "+ ref[label]
			 +" "+md5);
      ref[label] = md5;
      lab.insert(label);
    }

    DataBase *db = CheckDB();

    size_t ok = 0, mismatch = 0, notfound = 0;
    const ground_truth& gt = QueryRestrictionGT();
    vector<size_t> idxs = gt.indices(1);
    for (size_t i=0; i<idxs.size(); i++) {
      map<string,string> m = db->ReadOriginsInfo(idxs[i], false, true);
      const string& label = Label(idxs[i]);
      const string& checksum = m["checksum"];
      cout << "#" << idxs[i] << " <" << label << "> " << checksum;

      if (ref.find(label)!=ref.end()) {
	cout << " " << ref[label];
	if (ref[label]==checksum) {
	  cout << " OK";
	  ok++;
	} else {
	  cout << " MISMATCH";
	  mismatch++;
	}
	lab.erase(label);

      } else {
	cout << " NOT FOUND";
	notfound++;
      }
      cout << endl;
    }

    cout << "total=" << ok+mismatch+notfound << " ok=" << ok
	 << " mismatch=" << mismatch << " notfound=" << notfound << endl;

    if (lab.size()) {
      cout << endl << "extra labels: (" << lab.size() << ")" << endl;
      for (auto i=lab.begin(); i!=lab.end(); i++)
	cout << *i << endl;
      cout << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseNextFreeLabel(const
							  vector<string>&) {
    WriteLog("AnalyseNextFreeLabel");

    cout << CheckDB()->NextFreeLabel() << endl;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseObjectInfo(const vector<string>&
						       args) {
    WriteLog("AnalyseObjectInfo");

    bool show_also_negative_keywords = false;

    DataBase *db = GetDataBase();
    bool show_dim = query->Nindices()==1 && (verbose&255)==8 &&
      Picsom()->Quiet();
    bool use_textindexretrieve = true, use_textindexline = true;
    
    bool ok = true;
    for (size_t i=0; ok && i<args.size(); i++) {
      ground_truth gt = GTExpr(args[i]);
      vector<size_t> idx = gt.indices(1);
      if (verbose&1)
	cout << args[i] << " evaluates to " << idx.size() << " objects: "
	     << endl;
      for (size_t j=0; ok && j<idx.size(); j++) {
	if (verbose&1024)
	  db->ObjectPathEvenExtract(idx[j]);

	map<string,string> m = db->ReadOriginsInfo(idx[j], false, false);
	string data = db->SqlObjects() ? db->SqlObjectData(idx[j]) : "";
	if (verbose&1)
	  cout << " index="      << idx[j]
	       << " label="      << db->Label(idx[j])
	       << " target="     << db->ObjectsTargetTypeString(idx[j])
	       << " auxid="      << m["auxid"]
	       << " format="     << m["format"]
	     //<< " mime="       << m["mime"]
	       << " name="       << m["name"]
	       << " file="       << m["file"]
	       << " url="        << m["url"]
	       << " page="       << m["page"]
	       << " pageurl="    << m["pageurl"] << endl
	       << "  colors="    << m["colors"]
	       << " width="      << m["width"]
	       << " height="     << m["height"]
	       << " frames="     << m["frames"]
	       << " framerate="  << m["framerate"]
	       << " dimensions=" << m["dimensions"]
	       << " subrange="   << m["subrange"]
	       << " checksum="   << m["checksum"]
	       << " md5="        << m["md5"]
	       << " size="       << m["size"]
	       << " bytes="      << m["bytes"]
	       << " data.size="  << data.size()
	       << endl;
	
	if (verbose&512) {
	  cout << "#" << idx[j] << " <" << db->Label(idx[j]) << ">";
	  for (auto e=labelextras.begin(); e!=labelextras.end(); e++)
	    if (m[*e]!="")
	      cout << " " << *e << "=[" << m[*e] << "]";	    
	  cout << endl;
	}

	if (verbose&64)
	  cout << "  " << db->ObjectDump(idx[j]) << endl;

	if (verbose&256) {
	  cout << "  is:";
	  if (db->IsMissingObject(idx[j]))
	    cout << " missing";
	  if (db->IsVideoClip(idx[j]))
	    cout << " videoclip";
	  if (db->IsAudioClip(idx[j]))
	    cout << " audioclip";
	  if (db->IsVideoFrame(idx[j]))
	    cout << " videoframe";
	  if (db->IsImageFromContainer(idx[j]))
	    cout << " imagefromcontainer";
	  if (db->IsImageSegment_new(idx[j]))
	    cout << " imagesegment";
	  
	  if (db->ObjectsTargetTypeContains(idx[j], target_video))
	    cout << " fps=" << db->VideoFrameRate(idx[j]);

	  if (db->IsVideoClip(idx[j]) || db->IsVideoFrame(idx[j])) {
	    auto psd = db->ParentStartDuration(idx[j], target_video);
	    cout << " parent=" << psd.first
		 << " start="  << psd.second.first
		 << " dur="    << psd.second.second;

	  } else if (db->ObjectsTargetTypeContains(idx[j], target_video))
	    cout << " dur="    << db->VideoDuration(idx[j]);

	  if (db->ObjectsTargetTypeContains(idx[j], target_video)) {
	    auto r = db->VideoOrSegmentFirstAndLastFrame(idx[j], true);
	    auto v = db->VideoOrSegmentFirstAndLastFrame(idx[j], false);
	    cout << " nframes="
		 << db->VideoOrSegmentFramesOrdered(idx[j], true).size()
		 << "/"
		 << db->VideoOrSegmentFramesOrdered(idx[j], false).size()
		 << " [" << r.first.second << ".." << r.second.second << "]"
		 << "/[" << v.first.second << ".." << v.second.second << "]";
	  }

	  if (verbose&1024)
	    cout << " <" << db->ObjectPathEvenExtract(idx[j]) << ">";
	  cout << endl;
	}

	if (verbose&2) {
	  vector<string> detectionx = ExpandDetectionsWithClasses(detections,
								  classname);
	  // if (detectionx.size()==0)
	  //   return ShowError("ExpandDetectionsWithClasses() failed");

	  string detstr = CommaJoin(detectionx);
	  bool dummy = true;
	  map<string,vector<float> >
	    dets = db->RetrieveDetectionData(idx[j], detstr, true, dummy);
	  cout << "  detections:" << endl;
	  for (auto d=dets.begin(); d!=dets.end(); d++)
	    cout << "    " << d->first << "=" << ToStr(d->second) << endl;
	}

	if (verbose&12) {
	  if (verbose&4)
	    cout << "  features:" << endl;
	  for (size_t k=0; k<db->Nindices(); k++) {
	    string iname = db->IndexName(k);

	    bool found = false;
	    for (size_t z=0; !found && z<query->Nindices(); z++)
	      if ((query->IsVectorIndex(z) || query->IsTsSom(z)) &&
		  query->vectorIndex(z).IndexName()==iname)
		found = true;

	    if (!found && query->Nindices())
	      continue;

	    // cout << k << " " << iname << endl;
	    if (db->UseBinFeaturesRead()) {
	      // obs! commented out 2014-10-21 because after that
	      //      query->Nindices()==1 ???
	      // int dummy = 1;
	      // query->Interpret("indices", iname, dummy, NULL);
	      VectorIndex *vidx = dynamic_cast<VectorIndex*>(db->GetIndex(k));
	      const string augm;
	      if (vidx) 
		vidx->BinDataOpen(false, db->Size(), false, augm);
	    }
	    FloatVector *v = db->FeatureData(iname, idx[j], false);
	    if (!v)
	      continue;
	    if (verbose&4)
	      cout << "    k=" << k << " " << iname << " dim=" << v->Length()
		   << endl;
	    if (verbose&8) {
	      if (show_dim)
		cout << v->Length() << endl;
	      show_dim = false;
	      if (verbose&4)
		cout << "      ";
	      for (int l=0; l<v->Length(); l++)
		cout << (l?" ":"") << v->Get(l);
	      string lab = v->Label();
	      if (verbose&256)
		lab = m["url"];
	      cout << " " << lab << endl;
	    }
		
	    delete v;
	  }
	}

	if (verbose&128) {
	  cout << "  keywords:" << endl;
	  keyword_list kwl = db->FindKeywords(idx[j], true, true);
	  for (auto k=kwl.begin(); k!=kwl.end(); k++)
	    if (k->second!=-1 || show_also_negative_keywords)
	      cout << "    " << k->first << "=" << k->second << endl;
	}

	if (verbose&16) {
	  const string& lab = Label(idx[j]);
	  string p = db->ObjectPathEvenExtract(idx[j]);
	  cout << "  #" << idx[j] << " <"<< lab << "> <" << p << ">" << endl;
	  ok = ok && p!="";
	}

	if (verbose&32) {
	  list<string> tilist;
	  string qtiname = query->TextIndex();
	  if (qtiname!="")
	    tilist.push_back(qtiname);
	  else
	    tilist = db->TextIndices();
	  for (auto in=tilist.begin(); in!=tilist.end(); in++) {
	    if (use_textindexretrieve) {
	      list<pair<string,string> > td = db->TextIndexRetrieve(idx[j], *in);
	      if (td.empty())
		cout << "  " << *in << " : EMPTY" << endl;
	      for (auto ti=td.begin(); ti!=td.end(); ti++)
		if (ti->first!="label" || ti->second!=db->Label(idx[j]))
		  cout << "  " << *in << " : " << ti->first
		       << " = \"" << ti->second << "\"" << endl;
	    }
	    if (use_textindexline) {
	      textline_t tl = db->TextIndexLine(*in, "text", idx[j]);
	      cout << "  " << tl.txt_display(true) << endl;
	    }
	  }
	}
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseBMUcoord(const vector<string>&
                                                     args) {
    string err = "AnalyseBMUcoord() : ";

    if (resultname=="")
      return ShowError(err+"resultname needs to be specified");

    WriteLog("AnalyseBMUcoord");

    for (size_t i=0; i<Nfeatures(); i++) {
      TsSom(i).ReadMapFile();
      TsSom(i).ReadDivisionFile();
    }

    size_t vlen = Nfeatures()*2;

    bool values = false;
    if (!args.empty() && args[0]=="(values)") {
      values = true;
      vlen = 0;
      for (size_t i=0; i<Nfeatures(); i++)
        vlen += TsSom(i).VectorLength();
    }

    DataBase *db = GetDataBase();
    
    ofstream os(resultname.c_str());

    string atxt = args.empty() ? "()" : args[0];

    os << "#" << endl
       << "# output from AnalyseBMUcoord" << atxt << endl
       << "#" << endl;
    for (size_t j=0; j<Nfeatures(); j++) {
      const TSSOM& tssom = TsSom(j);
      simple::PointOf<int> wh = tssom.Map(tssom.Nlevels()-1).Size();
      os << "#   " << tssom.Name() << " " << wh.X() << "x" << wh.Y()
         << " " << tssom.VectorLength() << "-dim" << endl;
    }
    os << "#" << endl << vlen << endl;

    ground_truth gt = DataBaseRestrictionGT();

    size_t n = 0;
    bool ok = true;
    for (size_t i=0; ok && os && i<DataBaseSize(); i++) {
      if (!db->ObjectsTargetTypeContains(i, Target()))
        continue;

      if (gt[i]!=1)
        continue;

      vector<int>   bmu;
      vector<float> val;

      for (size_t j=0; j<Nfeatures(); j++) {
        const TSSOM& tssom   = TsSom(j);
        const IntVector& div = tssom.Division(tssom.Nlevels()-1, 0);
        int unit = div[i];
        if (unit<0)
          break;

        if (!values) {
	  simple::PointOf<int> xy = tssom.Map(tssom.Nlevels()-1).ToPoint(unit);
          bmu.push_back(xy.X());
          bmu.push_back(xy.Y());

        } else {
          const FloatVector& vec = *tssom.Map(tssom.Nlevels()-1).Unit(unit);
          val.insert(val.end(), &vec[0], &vec[0]+vec.Length());
        }
      }

      if (!values) {
        if (bmu.size()!=vlen)
          continue;

        for (size_t j=0; j<bmu.size(); j++)
          os << bmu[j] << " ";

      } else {
        if (val.size()!=vlen)
          continue;
        
        for (size_t j=0; j<val.size(); j++)
          os << val[j] << " ";
      }

      os << Label(i) << endl;
      
      n++;
    }

    if (ok && os)
      WriteLog("Wrote "+ToStr(n)+" "+ToStr(vlen)+"-dimensional BMU "+
               (values?"value":"coordinate")+" vectors in <"+resultname+">");
    else
      return ShowError(err+"failed to write in <"+resultname+">");

    return ok && os;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseVideoAnnotate(const vector<string>&
                                                          args) {
    bool suvi = false;

    string err = "AnalyseVideoAnnotate() : ";

    if (args.empty())
      return ShowError(err+"arguments should be given");

    WriteLog("AnalyseVideoAnnotate");
    ReadFiles();
    DataBase *db = GetDataBase();
    
    bool show = verbose>3;
    if (verbose>2) {
      videofile::debug(99);
      videofile::keep_tmp_files(true);
    }

    ground_truth_set gt_set = db->GroundTruthExpressionListNew(classname);

    bool ok = true;
    for (size_t v=0; ok && v<args.size(); v++) {
      const string& vlab = args[v];
      string vfile = db->ObjectTypeAndPath(vlab, target_video);
      if (vfile=="") {
        ok = ShowError(err+"label <"+vlab+"> is not an existing video file");
        break;
      }

      int idx = db->LabelIndex(vlab);
      string sfile = db->SolveSegmentFilePath(idx, segmentspec, true);

      segmentfile segm(vfile, sfile, NULL, NULL, NULL, true, true, false);
      
      size_t nframes = segm.getNumFrames();
      WriteLog("Video file <"+ShortFileName(vfile)+"> contains "+
               ToStr(nframes)+" frames");

      video_frange_list_t frange = ReadRangeSegments(segm, "frange");
      video_frange_list_t::const_iterator frange_it = frange.begin();

      if (!frange.empty())
        WriteLog("Segmentation file <"+ShortFileName(sfile)+"> contains "+
                 ToStr(frange.size())+" frame ranges");

      CreateIndexData(false);

      string vidoutname = imagefilename+vlab+".mpg";
      videofile videout(vidoutname, true);

      size_t h = 80, dx = 4;
      bool inf_mem = true;

      if (suvi) {
        h = 336;
        inf_mem = false;
      }

      ListOf<ListOf<simple::FloatMatrix> > mat_memory;
      for (size_t i=0; i<Nfeatures(); i++) {
        int bot = TsSom(i).Nlevels()-1;
        const vector<float>& hv = query->DivHistoryVector(i, bot);
        size_t meml = inf_mem ? 1 : hv.size();
        mat_memory.Append(new ListOf<simple::FloatMatrix>());
        for (size_t j=0; j<meml; j++)
          mat_memory.Peek()->Append(new
				    simple::FloatMatrix(Map(i, bot).Height(),
							Map(i, bot).Width()));
      }

      size_t step = db->FrameStep(), nf = 0;
      for (size_t f=0; f<nframes; f+=step) {
        int index = SolveFrameIndex(vlab, f);

        if (verbose>1)
          cout << "Starting to process frame=" << f << "/" << nframes
               << " vlab=" << vlab << " index=" << index
               << " of " << vfile << endl;

        imagedata in = *segm.imageFrame(f);
        in.convert(imagedata::pixeldata_uchar);
        in.force_three_channel();

        imagedata out(in.width(), in.height()+h,
                      3, imagedata::pixeldata_uchar);

        out.copyAsSubimage(in, 0, 0);

        query->DeleteSeen();
        query->MarkAsSeenEither(index, +1.0, true);
        query->PlaceSeenOnMap();
        query->Convolve();

        bool frange_change = false;
        while (frange_it!=frange.end() && f>frange_it->end-1) {
          frange_it++;
          frange_change=true;
        }

        bool in_frange = frange_it!=frange.end() && f>=frange_it->begin;
        if (in_frange && frange_change)
          for (size_t i=0; i<Nfeatures(); i++)
            for (size_t j=0; j<(size_t)mat_memory[i].Nitems(); j++)
              mat_memory[i][j].Zero();

        size_t x = 0;
        for (size_t i=0; i<Nfeatures(); i++) {
          TSSOM& tssom = TsSom(i);
	  int bot = tssom.Nlevels()-1;
          const simple::FloatMatrix& mat = query->Convolved(i, bot, 0);
          simple::FloatMatrix sum(mat);

          if (!inf_mem) {
            mat_memory[i].Insert(0, new simple::FloatMatrix(mat));
            mat_memory[i].Pop();

            sum.Zero();
            const vector<float>& hv = query->DivHistoryVector(i, bot);
            if (hv.size()!=(size_t)mat_memory[i].Nitems())
              ShowError(err+"hv.size()!=(size_t)mat_memory[i].Nitems()");
            for (size_t j=0; j<hv.size(); j++)
              sum += mat_memory[i][j]*hv[j];
          }

          const imagedata *bg = NULL;
          const map<string,imagedata>& bgm = tssom.BackGround();
          if (!bgm.empty())
            bg = &bgm.begin()->second;

          imagedata map = query->CreateMapImage(sum, bg);
          size_t w = int(float(h)*map.width()/map.height());
          if (x+w>out.width())
            break;

          scalinginfo scl(map.width(), map.height(), h, w);
          map.rescale(scl);
          out.copyAsSubimage(map, x, in.height());
          x += w+dx;
        }
        
        if (x<out.width()) {
          imagedata white(1, 1, 3, imagedata::pixeldata_uchar);
          vector<unsigned char> wv(3);
          wv[0] = wv[1] = wv[2] = 255;
          white.set(0, 0, wv);
          scalinginfo si(1, 1, out.width()-x, h);
          white.rescale(si);
          out.copyAsSubimage(white, x, in.height());

          string text = "#"+ToStr(f);

          //if (in_frange)
          //  text += " "+frange_it->type;

          imagedata txt = imagefile::render_text(text);
          txt.force_three_channel();
          out.copyAsSubimage(txt, x+5, in.height()+5);

          string classtext = "";
          for (size_t s=0; s<gt_set.size(); s++)
            if (gt_set[s][index]==1)
              classtext += gt_set[s].label() + ",";

          if (classtext != "") {
            classtext = classtext.substr(0,classtext.length()-1);
            imagedata txt2 = imagefile::render_text(classtext);
            txt2.force_three_channel();
            out.copyAsSubimage(txt2, x+5, in.height()+txt.height()+10);
          }
        }

        if (show)
          imagefile::display(out);

        videout.add_frame(out);
        nf++;

        Picsom()->PossiblyShowDebugInformation();
      }

      videout.write(segm.videoFPS());

      WriteLog("Successfully wrote "+ToStr(nf)+" video frames in <"+
               vidoutname+">");
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSubtitles(const vector<string>&
						      args) {
    string err = "AnalyseSubtitles() : ";

    if (args.empty())
      return ShowError(err+"arguments should be given");

    WriteLog("AnalyseSubtitles");

    ReadFiles();
    DataBase *db = GetDataBase();

    string spec, type = "ass";
    if (segmentspec!="")
      spec = "segm="+segmentspec;
    if (detections.size())
      spec += string(spec!=""?";":"")+"detections="+CommaJoin(detections);
    if (lscommap!="")
      spec += string(spec!=""?";":"")+"lscom="+lscommap;
    spec += string(spec!=""?";":"")+"thr="+ToStr(threshold);


    bool ok = true;
    size_t v = 0;
    for (; ok && v<args.size(); v++) {
      const string& a = args[v];
      if (a=="ass" || a=="vtt") {
	type = a;
	continue;
      }
      if (a.find("showprob=")==0 || a.find("showsegm=")==0) {
	spec += string(spec!=""?";":"")+a;
	continue;
      }
      
      break;
    }

    ground_truth gt(db->Size());
    for (; ok && v<args.size(); v++) {
      ground_truth gta = db->GroundTruthExpression(args[v], target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }

    vector<size_t> vidx = gt.indices(1);
    for (auto vi=vidx.begin(); ok && vi!=vidx.end(); vi++)
      ok = db->GenerateSubtitles(*vi, type, spec,
				 db->Label(*vi)+filename+"."+type);

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSubtitlesOld(const vector<string>&
							 args) {
    string err = "AnalyseSubtitles() : ";

    bool debug1 = verbose>1, debug2 = verbose>2, debug3 = verbose>3;

    if (args.empty())
      return ShowError(err+"arguments should be given");

    WriteLog("AnalyseSubtitles");

    // if (segmentspec=="")
    //   return ShowError(err+"segmentspec should be set");

    string segmentspec_was = segmentspec;
    vector<string> sspecs = SplitInCommas(segmentspec);

    ReadFiles();
    DataBase *db = GetDataBase();

    bool ok = true;
    for (size_t v=0; ok && v<args.size(); v++) {
      const string& vlab = args[v];
      string vfile = db->ObjectTypeAndPath(vlab, target_video);
      if (vfile=="") {
        ok = ShowError(err+"label <"+vlab+"> is not an existing video file");
        break;
      }
      string vfile_x = vfile;
      vfile = "";
      
      const object_info *oi = CheckDB()->FindObject(vlab);
      oi->dump();
      
      WriteLog("Object <"+vlab+"> has "+
	       ToStr(oi->children.size())+" children (before)");
      CheckDB()->MakeSubObjectIndex();
      WriteLog("Object <"+vlab+"> has "+
	       ToStr(oi->children.size())+" children (after)");

      string fname = vlab+".ass";
      ofstream os(fname.c_str());
      os << "[Script Info]" << endl
	 << "Title:" << endl
	 << "Original Script:" << endl
	 << "Original Translation:" << endl
	 << "Original Editing:" << endl
	 << "Original Timing:" << endl
	 << "Original Script Checking:" << endl
	 << "ScriptType: v4.00+" << endl
	 << "Collisions: Normal" << endl
	 << "PlayResY: 1024" << endl
	 << "PlayDepth: 0" << endl
	 << "Timer: 100,0000" << endl
	 << "[V4+ Styles]" << endl
	 << "Format:"
	 << " Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,"
	 << " OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,"
	 << " ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,"
	 << " Alignment, MarginL, MarginR, MarginV, Encoding" << endl;

      string s1 = ",DejaVu Sans,70,";
      string s2 = ",&H00B4FCFC,&H00000000,&H00000000,"
	"0,0,0,0,100,100,0.00,0.00,1,2.50,0.00,";
      string s4 = ",&H00B4FCFC,&H000000FF,&H00000000,"
	"0,0,0,0,100,100,0.00,0.00,1,2.50,0.00,";
      string s3 = ",50,50,50,0";
      os << "Style: subtitle" << s1 << "&H00FFFFFF" << s2 << 2 << s3 << endl;
      os << "Style: concepts" << s1 << "&H0000C000" << s2 << 7 << s3 << endl;
      os << "Style: personte" << s1 << "&H00C00000" << s2 << 6 << s3 << endl;
      os << "Style: personfa" << s1 << "&H00C000C0" << s2 << 6 << s3 << endl;
      os << "Style: personvo" << s1 << "&H00C000C0" << s2 << 4 << s3 << endl;
      os << "Style: facebox"  << s1 << "&HFF000000" << s4 << 7 << s3 << endl;
      os << "Style: link"     << s1 << "&H000000FF" << s2 << 4 << s3 << endl;
      os << "[Events]" << endl;
      os << "Format: Layer, Start, End, Style, Name,"
	" MarginL, MarginR, MarginV,Effect, Text" << endl;

      for (size_t si=0; si<sspecs.size(); si++) {
	segmentspec = sspecs[si];

	if (segmentspec=="links") {
	  float duration = 5;

	  string lfile = CheckDB()->SolveObjectPath(vlab);
	  size_t p = lfile.rfind('.');
	  if (p==string::npos)
	    lfile = "";
	  else {
	    lfile.erase(p);
	    p = lfile.rfind('/');
	    if (p==string::npos)
	      lfile = "";
	    else {
	      string s = lfile.substr(p);
	      lfile += ".d"+s+".links";
	    }
	  }
	  if (FileExists(lfile)) {
	    WriteLog("Processing LINKS file <"+ShortFileName(lfile)+">");
	    list<textline_t> aline = CheckDB()->ReadOSRS(lfile);
	    for (auto i=aline.begin(); i!=aline.end(); i++) {
	      string txt = i->txt_val[0].first;

	      os << "Dialogue: 0," << DataBase::ASStimeStr(i->start) << ","
		 << DataBase::ASStimeStr(i->start+duration)
		 << ",link,foo,000,000,000,," << txt << endl;
	    }
	  }
	  continue;
	}

	if (CheckDB()->IsMetaClassFile(segmentspec)) {
	  WriteLog("Processing METACLASSFILE file <"+
		   ShortFileName(segmentspec)+">");
	  
	  list<textline_t> asrcooked;
	  ground_truth_set clist;
	  if (detections.size()==0)
	    clist = CheckDB()->GroundTruthExpressionListNew(segmentspec);
	  else {
	    list<string> ls = CheckDB()->SplitClassNames(segmentspec);
	    for (auto i=ls.begin(); i!=ls.end(); i++) {
	      ground_truth gt;
	      gt.label(*i);
	      clist.insert(gt);
	    }
	  }

	  // svm::ColorSIFTds-soft90-1x1-2x2::EXP_CHI2::tv12#lscom570.bin
	  // -> detections=svm::ColorSIFTds-soft90-1x1-2x2::EXP_CHI2::tv12
	  
	  float thr = threshold;
	  // if (thr==0)
	  //   thr = 0.95;

	  bool use_sec = false; // obs!
	  float fps = 25;       // obs!

	  for (size_t f_or_sec=0; f_or_sec<1000000; f_or_sec++) { // obs!
	    string label = vlab+":"+(use_sec?"s":"")+ToStr(f_or_sec);
	    int idx = CheckDB()->LabelIndexGentle(label, false);
	    if (debug1)
	      cout << label << " #" << idx;

	    if (idx<0) {
	      if (debug1)
		cout << endl;
	      break; // was continue;
	    }

	    string txt;
	    map<float,string> valtxt;
	    for (size_t a=0; a<clist.size(); a++) {
	      if (clist[a].index_ok(idx) && clist[a][idx]==1)
		txt += (txt==""?"":" ")+clist[a].label();

	      if (detections.size()==1) {
		string detname = detections.front();
		detname += "#"+clist[a].label();

		bool dummy = true;
		map<string,vector<float> > dets
		  = CheckDB()->RetrieveDetectionData(idx, detname, true, dummy);

		if (dets.size()==1) {
		  if (dets.begin()->second.size()!=1)
		    return ShowError(err+"dets.begin()->second.size()!=1");
		    
		  string labo = clist[a].label(), lab = labo;

		  float val = dets.begin()->second[0];
		  if (debug3)
		    cout << " " << labo << "=" << val;

		  if (val>thr) {
		    if (lab.substr(0, 5)=="lscom") {
		      lab = CheckDB()->LscomName(lab, true, "trecvid2011");
		      pair<string,string> lp = DataBase::SplitLscomName(lab);
		      lab = lp.first;
		    }
		    if (lab.size()==9 && lab[0]=='n' &&
			lab.find_first_not_of("0123456789", 1)==string::npos) {
		      lab = CheckDB()->ImageNetName(lab, true);
		      vector<string> labv = CheckDB()->SplitImageNetName(lab);
		      lab = labv[0];
		    }
		
		    if (debug2)
		      cout << " *" << labo << "/" << lab << "=" << val << "*";

		    string txt = lab;
		    char valbuf[100];
		    sprintf(valbuf, " (%1.3f)", val);
		    txt += valbuf;
		    valtxt.insert(make_pair(val, txt));
		  }
		}
	      }
	    }

	    for (auto i=valtxt.rbegin(); i!=valtxt.rend(); i++)
	      txt += (txt==""?"":" ")+i->second;

	    if (txt!="") {
	      textline_t aline;
	      aline.start = f_or_sec/(use_sec?1:fps);
	      aline.end   = (f_or_sec+1)/(use_sec?1:fps);
	      aline.add(txt, 0);
	      asrcooked.push_back(aline);

	      if (debug1 && !debug2)
		cout << " " << txt.substr(0, 50);
	    }

	    if (debug1)
	      cout << endl;
	  }

	  for (auto i=asrcooked.begin(); i!=asrcooked.end(); i++) {
	    string txt = i->txt_val[0].first;

	    os << "Dialogue: 0," << DataBase::ASStimeStr(i->start) << ","
	       << DataBase::ASStimeStr(i->end)
	       << ",concepts,foo,000,000,000,," << txt << endl;
	  }
	  continue;
	}

	if (segmentspec=="dia") {
	  string diafile = vfile_x;
	  size_t p = diafile.rfind('.');
	  size_t q = diafile.rfind('/', p);
	  diafile.erase(p+1);
	  diafile += "d"+diafile.substr(q, p-q+1)+"dia";
	  list<textline_t> dia = CheckDB()->ReadOSRS(diafile);
	  WriteLog("Processing DIA file <"+ShortFileName(diafile)+">");
	  for (auto i=dia.begin(); i!=dia.end(); i++) {
	    string txt = i->txt_val[0].first; // , t = txt.substr(0, 1);
	    // if (t[0]>='a' && t[0]<='z')
	    //   txt[0] = t[0]-32;
	    // txt += ".";
	    
	    os << "Dialogue: 0," << DataBase::ASStimeStr(i->start) << ","
	       << DataBase::ASStimeStr(i->end)
	       << ",personvo,foo,000,000,000,," << txt << endl;
	  }
	  continue;
	}

	if (segmentspec=="asr") {
	  string asrfile;
	  list<textline_t> asrcooked = CheckDB()->OSRScooked(vfile_x, asrfile);
	  if (asrfile!="") {
	    WriteLog("Processing OSRS file <"+ShortFileName(asrfile)+">");
	    for (auto i=asrcooked.begin(); i!=asrcooked.end(); i++) {
	      string txt = i->txt_val[0].first; // , t = txt.substr(0, 1);
	      // if (t[0]>='a' && t[0]<='z')
	      //   txt[0] = t[0]-32;
	      // txt += ".";

	      os << "Dialogue: 0," << DataBase::ASStimeStr(i->start) << ","
		 << DataBase::ASStimeStr(i->end)
		 << ",subtitle,foo,000,000,000,," << txt << endl;
	    }
	  }
	  continue;
	}

	int idx = db->LabelIndex(vlab);
	string sfile = db->SolveSegmentFilePath(idx, segmentspec, true);
	if (sfile=="")
	  return ShowError(err+"segmentfile ["+segmentspec+"] for <"+
			   vlab+"> not found");
	
	WriteLog("Opening segmentfile <"+ShortFileName(sfile)+">");

	segmentfile segm(vfile, sfile, NULL, NULL, NULL, true, true, false);

	size_t nframes = segm.getNumFrames();
	SegmentationResultList *results = segm.readFileResultsFromXML("","");
	set<int> flist = segm.listProcessedFrames();

	WriteLog("Video file <"+ShortFileName(vfile_x)+"> contains "+
		 ToStr(nframes)+" frames of which "+ToStr(flist.size())+
		 " have been processed with <"+segmentspec+">");

	for (set<int>::const_iterator it=flist.begin(); it!=flist.end(); it++) {
	  int f = *it;
	  string fs = segm.FrameSpec(f);
	  if (debug1)
	    cout << "FRAME [" << f << "] \"" << fs << "\" RESULTS of <"
		 << segmentspec << "> :" << endl;
	  results = segm.readFrameResultsFromXML(f, "", "");

	  string cons;
	  for (SegmentationResultList::const_iterator it=results->begin();
	       it!=results->end(); it++) {
	    if (debug1) {
	      cout << "  NAME:  "   << it->name 	<< endl;
	      cout << "  TYPE:  "   << it->type 	<< endl;
	      cout << "  VALUE: "   << it->value	<< endl;
	      cout << "  METHODID:" << it->methodid << endl;
	      cout << "  RESULTID:" << it->resultid << endl << endl;
	    }

	    if (it->type=="detection") {
	      cons += (cons!=""?" ":"")+it->value;
	      continue;
	    }

	    if (it->type!="box" || it->name.substr(0, 4)!="face" ||
		fs.substr(0, 2)!=":s")
	      continue;

	    double sec0 = atof(fs.substr(2).c_str()), sec1 = sec0+0.99;

	    float mul = 1024.0/segm.getHeight();
	    vector<string> vs = SplitInSpaces(it->value);
	    vector<int> v(vs.size());
	    for (size_t z=0; z<v.size(); z++)
	      v[z] = (int)floor(mul*atoi(vs[z].c_str())+0.5);

	    // http://en.wikipedia.org/wiki/SubStation_Alpha
	    // http://aegisub.cellosoft.com/docs/ASS_Tagsnmen
	  
	    os << "Dialogue: 1," << DataBase::ASStimeStr(sec0) << ","
	       << DataBase::ASStimeStr(sec1) << ",facebox,foo,000,000,000,,"
	       << "{\\pos(0,0)\\p1}m " << v[0] << " " << v[1]
	       << " l " << v[2] << " " << v[1] << " " << v[2] << " " << v[3]
	       << " " << v[0] << " " << v[3] << "{\\p0}" << endl;

	    if (debug2) {
	      os << "Dialogue: 1," << DataBase::ASStimeStr(sec0) << ","
		 << DataBase::ASStimeStr(sec1) << ",facebox,foo,000,000,000,,"
		 << "{\\pos(0,0)\\p1}m 0 0 l 100 0 100 100 0 100{\\p0}" 
		 << endl;
	      os << "Dialogue: 1," << DataBase::ASStimeStr(sec0) << ","
		 << DataBase::ASStimeStr(sec1) << ",facebox,foo,000,000,000,,"
		 << "{\\pos(0,0)\\p1}m 200 200 l 300 200 300 300 200 300{\\p0}"
		 << endl;
	    }
	  }

	  if (cons!="" && fs.substr(0, 2)==":s") {
	    double sec0 = atof(fs.substr(2).c_str()), sec1 = sec0+0.99;
	    os << "Dialogue: 1," << DataBase::ASStimeStr(sec0) << ","
	       << DataBase::ASStimeStr(sec1) << ",concepts,foo,000,000,000,,"
	       << "Shot x: " << cons
	       << endl;
	  }
	}
      }
    }

    segmentspec = segmentspec_was;

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseElanize(const vector<string>&
						    args) {
    string err = "AnalyseElanize() : ";

    bool debug = true;

    bool ignore_detector_name = true;
    bool txtlines_show_prob   = true;

    if (args.empty())
      return ShowError(err+"arguments should be given");

    WriteLog("AnalyseElanize");

    string cmd = commands_str+" - "+ToStr(rest_argv_str);

    string segmentspec_was = segmentspec;
    vector<string> sspecs = SplitInCommas(segmentspec);

    ReadFiles();
    DataBase *db = GetDataBase();

    target_type tt = query->Target();

    vector<pair<string,string> > det_exp_tier, det_exp_csv;
    for (auto i=detections.begin(); i!=detections.end(); i++) {
      string d = *i, t;
      if (d.find("TIER:")==0) {
	t = "tier";
	d.erase(0, 5);
      }
      if (d.find("CSV:")==0) {
	t = "csv";
	d.erase(0, 4);
      }
      if (t=="")
	return ShowError(err+"detections should be either TIER: or CSV:");

      bool ismeta = false;
      size_t p = d.find('#');
      if (p!=string::npos) {
	string cname = d.substr(p+1);
	if (db->IsMetaClassFile(cname)) {
	  ismeta = true;
	  list<string> cls = db->SplitClassNames(cname);
	  for (auto j=cls.begin(); j!=cls.end(); j++)
	    (t=="tier"?det_exp_tier:det_exp_csv).
	      push_back(make_pair(d.substr(0, p+1)+*j, ""));
	}
      }
      if (!ismeta)
	(t=="tier"?det_exp_tier:det_exp_csv).push_back(make_pair(d, ""));
    }

    for (auto i=det_exp_tier.begin(); i!=det_exp_tier.end(); i++) {
      string dd = i->first;

      if (ignore_detector_name) {
	size_t p = dd.find('#');
	if (p!=string::npos)
	  dd.erase(0, p+1);
      }

      if (dd.find("lscom")==0) {
	string l_str = db->LscomName(dd, true, "trecvid2011");
	pair<string, string> l_pair = DataBase::SplitLscomName(l_str);
	dd = l_pair.first;
      }
      // replace ImageNet nxxxxxxxx too ???

      i->second = dd;
    }
    for (auto i=det_exp_csv.begin(); i!=det_exp_csv.end(); i++) {
      string dd = i->first;

      if (ignore_detector_name) {
	size_t p = dd.find('#');
	if (p!=string::npos)
	  dd.erase(0, p+1);
      }

      if (dd.find("lscom")==0) {
	string l_str = db->LscomName(dd, true, "trecvid2011");
	pair<string, string> l_pair = DataBase::SplitLscomName(l_str);
	dd = l_pair.first;
      }
      // replace ImageNet nxxxxxxxx too ???

      i->second = dd;
    }

    ground_truth gtargs(db->Size());
    for (auto a=args.begin(); a!=args.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gtargs = gtargs.TernaryOR(gta);
    }

    vector<size_t> argsidx = gtargs.indices(1);

    bool ok = true;
    for (auto argsi=argsidx.begin(); ok && argsi!=argsidx.end(); argsi++) {
      const string& vlab = db->Label(*argsi);
      string vfile = db->ObjectTypeAndPath(vlab, tt);
      if (vfile=="") {
        ok = ShowError(err+"label <"+vlab+"> is not an existing media file");
        break;
      }
      string vfile_x = vfile;
      vfile = "";

      string objdir = vfile_x;
      size_t sp = objdir.rfind('/');
      if (sp!=string::npos)
	objdir.erase(sp+1);

      string odir = outdir=="" ? objdir : OutDirEvenDot();
      string original  = CheckDB()->SolveObjectPath(vlab);
      string base_url_raw = original;
      size_t ps = base_url_raw.rfind('/'), pd = base_url_raw.rfind('.');
      if (ps==string::npos || pd==string::npos || pd<ps)
	return ShowError(err+"failed with media filename");
      base_url_raw.erase(pd);

      if (base_url_raw.find(objdir)==0)
	base_url_raw.replace(0, objdir.size(), odir);

      base_url_raw += filename;
      string base_url_elan = base_url_raw+"-elan";

      string eafname = base_url_raw+".eaf", pfsxname = base_url_raw+".pfsx";
      
      string video_url = base_url_elan+".mov";
      if (!elanconvert) {
	video_url = original;
	size_t ps = video_url.rfind('/');
	if (ps!=string::npos)
	  video_url.erase(0, ps+1);
      }

      const object_info *oi = CheckDB()->FindObject(vlab);
      oi->dump();
      size_t idx = CheckDB()->LabelIndex(vlab);
      const string& label = CheckDB()->Label(idx);
      
      WriteLog("Object <"+vlab+"> has "+
	       ToStr(oi->children.size())+" children (before)");
      CheckDB()->MakeSubObjectIndex();
      WriteLog("Object <"+vlab+"> has "+
	       ToStr(oi->children.size())+" children (after)");

      if (elanconvert && (elanoverwrite || !FileExists(video_url))) {
	string ffmpeg = Picsom()->FindExecutable("", "ffmpeg", "");
	string vcodec = "copy";
	string acodec = "mp2";
	vector<string> cmd1 { ffmpeg, "-y", "-i", original, "-vcodec", vcodec,
	    "-acodec", acodec, video_url, "1>/dev/null", "2>&1" };
	vector<string> cmd2 { ffmpeg, "-y", "-i", original, "-vcodec", vcodec,
	    "-an", video_url, "1>/dev/null", "2>&1" };
	Picsom()->ExecuteSystem(cmd1, true, true, true);
      }

      string audio_url = base_url_elan+".wav";
      if (elanconvert && (elanoverwrite || !FileExists(audio_url))) {
	string ffmpeg = Picsom()->FindExecutable("", "ffmpeg", "");
	string acodec = "pcm_alaw";
	vector<string> cmd { ffmpeg, "-y", "-i", original, "-vn",
	    "-acodec", acodec, audio_url, "1>/dev/null", "2>&1" };
	Picsom()->ExecuteSystem(cmd, true, true, true);
      }

      if (!elanconvert && !FileExists(video_url)) {
	vector<string> cmdv { "ln", "-s", original, video_url };
	Picsom()->ExecuteSystem(cmdv, true, true, true);
      }

      string csv_url    = base_url_elan+".csv";
      string tsconf_url = base_url_raw+"_tsconf.xml";

      videofile vf(video_url);
      double fps = vf.get_frame_rate(), nsec = vf.get_length();
      WriteLog("Object <"+vlab+"> is reported to be "+ToStr(nsec)
	       +" seconds and "+ToStr(fps)+" frames per second");

      vector<string> segs;
      for (size_t si=0; si<sspecs.size(); si++)
	if (sspecs[si].find("sb")==0)  // e.g. sbs, sbd, sbx, sby, ...
	  segs.push_back(sspecs[si]);

      CreateElanCsvConfPfsx((size_t)oi->index, fps, segs, det_exp_csv,
			    csv_url, tsconf_url, pfsxname);

      string relative_video_url = video_url;
      size_t p = relative_video_url.rfind('/');
      if (p!=string::npos && p>0)
	relative_video_url.erase(0, p+1);
      relative_video_url = "./"+relative_video_url;

      string relative_audio_url = audio_url;
      p = relative_audio_url.rfind('/');
      if (p!=string::npos && p>0)
	relative_audio_url.erase(0, p);
      relative_audio_url = "."+relative_audio_url;

      string relative_csv_url = csv_url;
      p = relative_csv_url.rfind('/');
      if (p!=string::npos && p>0)
	relative_csv_url.erase(0, p);
      relative_csv_url = "."+relative_csv_url;

      string relative_tsconf_url = tsconf_url;
      p = relative_tsconf_url.rfind('/');
      if (p!=string::npos && p>0)
	relative_tsconf_url.erase(0, p);
      relative_tsconf_url = "."+relative_tsconf_url;

      XmlDom eaf = XmlDom::Doc();
      XmlDom docu = eaf.Root("ANNOTATION_DOCUMENT");
      docu.Prop("AUTHOR", "PicSOM automagically generated with \""+cmd+
		"\" for "+Picsom()->UserName()+ " @ "+Picsom()->HostName(true));
      docu.Prop("DATE", XSdateTime(TimeNow()));
      docu.Prop("FORMAT", "2.7");
      docu.Prop("VERSION", "2.7");
      docu.Prop("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
      docu.Prop("xsi:noNamespaceSchemaLocation",
		"http://www.mpi.nl/tools/elan/EAFv2.7.xsd");
      XmlDom head = docu.Element("HEADER");
      head.Prop("MEDIA_FILE", "");
      head.Prop("TIME_UNITS", "milliseconds");

      XmlDom medi = head.Element("MEDIA_DESCRIPTOR");
      medi.Prop("MEDIA_URL", "file://"+video_url);
      medi.Prop("MIME_TYPE", "video/mpeg");
      medi.Prop("RELATIVE_MEDIA_URL", "file://"+relative_video_url);
      if (FileSize(audio_url)>0) {
	medi = head.Element("MEDIA_DESCRIPTOR");
	medi.Prop("MEDIA_URL", "file://"+audio_url);
	medi.Prop("MIME_TYPE", "audio/x-wav");
	medi.Prop("RELATIVE_MEDIA_URL", "file://"+relative_audio_url);
	medi.Prop("EXTRACTED_FROM", "file://"+video_url);
      }

      XmlDom link = head.Element("LINKED_FILE_DESCRIPTOR");
      link.Prop("ASSOCIATED_WITH", "file://"+video_url);
      link.Prop("MIME_TYPE", "unknown"); // obs?
      link.Prop("LINK_URL", "file://"+csv_url);
      link.Prop("RELATIVE_LINK_URL", "file://"+relative_csv_url);
      link = head.Element("LINKED_FILE_DESCRIPTOR");
      link.Prop("ASSOCIATED_WITH", "file://"+video_url);
      link.Prop("MIME_TYPE", "text/xml");
      link.Prop("LINK_URL", "file://"+tsconf_url);
      link.Prop("RELATIVE_LINK_URL", "file://"+relative_tsconf_url);

      XmlDom prop = head.Element("PROPERTY", "0");
      prop.Prop("NAME", "lastUsedAnnotationId");
      XmlDom time = docu.Element("TIME_ORDER");
      XmlDom ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("GRAPHIC_REFERENCES", "false");
      ling.Prop("LINGUISTIC_TYPE_ID", "default-lt");
      ling.Prop("TIME_ALIGNABLE", "true");
      ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("CONSTRAINTS", "Time_Subdivision"); // Included_In
      ling.Prop("GRAPHIC_REFERENCES", "true");
      ling.Prop("LINGUISTIC_TYPE_ID", "face_t");
      ling.Prop("TIME_ALIGNABLE", "true");
      ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("CONSTRAINTS", "Time_Subdivision"); // Included_In
      ling.Prop("GRAPHIC_REFERENCES", "true");
      ling.Prop("LINGUISTIC_TYPE_ID", "voice_t");
      ling.Prop("TIME_ALIGNABLE", "true");
      ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("CONSTRAINTS", "Time_Subdivision"); // Included_In
      ling.Prop("GRAPHIC_REFERENCES", "true");
      ling.Prop("LINGUISTIC_TYPE_ID", "ocr_t");
      ling.Prop("TIME_ALIGNABLE", "true");
      ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("CONSTRAINTS", "Time_Subdivision"); // Included_In
      ling.Prop("GRAPHIC_REFERENCES", "true");
      ling.Prop("LINGUISTIC_TYPE_ID", "concept_t");
      ling.Prop("TIME_ALIGNABLE", "true");
      ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("CONSTRAINTS", "Time_Subdivision"); // Included_In
      ling.Prop("GRAPHIC_REFERENCES", "true");
      ling.Prop("LINGUISTIC_TYPE_ID", "shot_t");
      ling.Prop("TIME_ALIGNABLE", "true");
      ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("CONSTRAINTS", "Time_Subdivision"); // Included_In
      ling.Prop("GRAPHIC_REFERENCES", "true");
      ling.Prop("LINGUISTIC_TYPE_ID", "keyframe_t");
      ling.Prop("TIME_ALIGNABLE", "true");
      ling = docu.Element("LINGUISTIC_TYPE");
      ling.Prop("CONSTRAINTS", "Time_Subdivision"); // Included_In
      ling.Prop("GRAPHIC_REFERENCES", "true");
      ling.Prop("LINGUISTIC_TYPE_ID", "tsegm_t");
      ling.Prop("TIME_ALIGNABLE", "true");
      XmlDom loca = docu.Element("LOCALE");
      loca.Prop("COUNTRY_CODE", "US");
      loca.Prop("LANGUAGE_CODE", "en");
      XmlDom cons = docu.Element("CONSTRAINT");
      cons.Prop("DESCRIPTION", "Time subdivision of parent annotation's time"
		" interval, no time gaps allowed within this interval");
      cons.Prop("STEREOTYPE", "Time_Subdivision");
      cons = docu.Element("CONSTRAINT");
      cons.Prop("DESCRIPTION", "Symbolic subdivision of a parent annotation. "
		"Annotations refering to the same parent are ordered");
      cons.Prop("STEREOTYPE", "Symbolic_Subdivision");
      cons = docu.Element("CONSTRAINT");
      cons.Prop("DESCRIPTION", "1-1 association with a parent annotation");
      cons.Prop("STEREOTYPE", "Symbolic_Association");
      cons = docu.Element("CONSTRAINT");
      cons.Prop("DESCRIPTION", "Time alignable annotations within the parent"
		" annotation's time interval, gaps are allowed");
      cons.Prop("STEREOTYPE", "Included_In");

      map<string,list<pair<double,string> > > ocr;
      map<string,list<textline_t> > voices;
      map<string,list<int> > faces;
      map<string,list<pair<pair<float,float>,string> > > concepts;
      map<string,video_frange_list_t> shots, keyframes, tsegms;

      int tsno = 0, ano = 0;

      string trange_tier_from, trange_text_from;

      for (size_t si=0; si<sspecs.size(); si++) {
	segmentspec = sspecs[si];
	if (segmentspec=="")
	  break;

	if (segmentspec=="asr") {
	  list<textline_t> asrraw = CheckDB()->ASRlinesOrCombine(idx, true);
	  for (auto i=asrraw.begin(); i!=asrraw.end(); i++) 
	    voices["speech"].push_back(*i);

	  continue;
	}

	if (segmentspec.find("ocr:")==0) {
	  segmentspec.erase(0, 4);
	  list<pair<double,string> > ocrl
	    = CheckDB()->OCRlinesOrCombine(idx, segmentspec, true);
	  for (auto i=ocrl.begin(); i!=ocrl.end(); i++)
	    ocr[segmentspec].push_back(*i);

	  continue;
	}

	size_t y = segmentspec.find('/');
	if (y!=string::npos) {
	  string sx = segmentspec.substr(y+1);
	  segmentspec.erase(y);
	  if (sx=="class") {
	    trange_tier_from = "type";
	    trange_text_from = "name";

	  } else if (sx=="text") {
	    trange_tier_from = "namebase";
	    trange_text_from = "type";

	  } else if (sx=="textnum") {
	    trange_tier_from = "name";
	    trange_text_from = "type";

	  } else if (sx=="segm") {
	    trange_tier_from = "namebase";
	    trange_text_from = "name";

	  } else if (sx=="segmnum") {
	    trange_tier_from = "name";
	    trange_text_from = "name";

	  } else
	    return ShowError(err+"trange segment specifier /"+sx+
			     " not understood");
	}

	vector<size_t> segidx;
	for (size_t ti=0; ti<1000000; ti++) {
	  // obs! "t" hard-coded...
	  string slab = segmentspec+":"+label+":t"+ToStr(ti);
	  int sidx = db->LabelIndexGentle(slab, false);
	  if (sidx<0)
	    break;
	  segidx.push_back(sidx);
	}

	if (segidx.size()) {
	  string tsegid = segmentspec;
	  video_frange_list_t& tsegmx = tsegms[tsegid];
	  for (auto si=segidx.begin(); si!=segidx.end(); si++) {
	    cout << *si << endl;
	    auto psd = db->ParentStartDuration(*si, target_video);
	    float beg = psd.second.first, dur = psd.second.second;
	    video_frange segtxt(db, *si, beg, beg+dur, "trangetext",
				segmentspec, db->Label(*si));

	    tsegmx.push_back(segtxt);
	  }
	  continue;
	}

	if (segmentspec.find("text|")==0) {
	  vector<string> sp = SplitInSomething("|", false, segmentspec);
	  if (sp.size()!=3)
	    return ShowError(err+"sp.size()!=3 for <"+segmentspec+">");
	  string textindex = sp[1], field = "text", tsift = sp[2];
	  string tsext = textindex;

	  double timeshift = tsift!="" ? atof(tsift.c_str()) : 0;

	  list<textline_t> txtlines;
	  if (db->HasTextIndex(textindex)) {	
	    map<size_t,size_t> i2sm; // image_to_segm_middle
	    ground_truth gto(db->Size());
	    gto[*argsi] = 1;
	    object_info *oi = db->FindObject(*argsi);
	    if (oi)
	      for (auto i=oi->children.begin(); i!=oi->children.end(); i++)
		if (db->ObjectsTargetTypeContains(*i, target_videosegment)) {
		  auto mid = db->VideoOrSegmentMiddleFrame(*i);
		  cout << "#" << *i << " : middle=#" << mid.first << " frame="
		       << mid.second << endl;		    
		  i2sm[mid.first] = *i;
		  gto[mid.first]  = 1;
		}
	     
	    ground_truth gtx = gto.TernaryAND(QueryRestrictionGT());
	    txtlines = db->TextIndexLines(textindex, "text", gtx);
	    for (auto i=txtlines.begin(); i!=txtlines.end(); i++) {
	      cout << "A : " << i->txt_display(true) << endl;
	      if (i->start==-1 && i2sm.find(i->idx)!=i2sm.end()) {
		auto psd = db->ParentStartDuration(i2sm[i->idx], target_videofile);
		i->start = psd.second.first;
		i->end   = i->start+psd.second.second;
	      }
	      cout << "B : " << i->txt_display(true) << endl;
	    }
	    
	  } else {
	    bool raw = textindex=="raw";
	    tsext = raw ? field : textindex;
	    string tf = db->ObjectTextFileSubdirPath(idx, "", tsext);
	    if (!FileExists(tf))
	      return ShowError(err+"<"+sp[1]+"> is neither a textindex nor "
			       "a timestamped line file");
	    string asrfile;
	    txtlines = raw ? db->OSRScooked(tf, asrfile) : db->ReadOSRS(tf);
	  }
	  
	  for (auto ai=txtlines.begin(); ai!=txtlines.end(); ai++) {
	    // should this be inside ReadOSRS()?
	    string text = ai->txt_val[0].first;
	    if (!txtlines_show_prob) {
	      size_t p = text.rfind(" (");
	      if (p!=string::npos) {
		size_t q = text.find_first_not_of("0123456789.+-e", p+2);
		if (q==text.size()-1 && text[q]==')')
		  text.erase(p);
	      }
	    } else if (ai->txt_val[0].second) {
	      // now assume that the probablities are not there already
	      text += " ("+ToStr(ai->txt_val[0].second)+")";
	    }

	    textline_t aline(*ai);
	    aline.set(text, 0);         // was add() until 2018-05-04
	    aline.start += timeshift;
	    aline.end   += timeshift;
	    voices[tsext].push_back(aline);

	    cout << text << endl;
	  }

	  continue;
	}	

	string sfile = db->SolveSegmentFilePath(idx, segmentspec, true);
	if (sfile=="")
	  return ShowError(err+"segmentfile ["+segmentspec+"] for <"+
			   vlab+"> not found");
	
	WriteLog("Opening segmentfile <"+ShortFileName(sfile)+">");

	segmentfile segm(vfile, sfile, NULL, NULL, NULL, true, true, false);

	video_frange_list_t franges = ReadRangeSegments(segm, "frange");
	WriteLog("  "+ToStr(franges.size())+" frange results found");
	video_frange_list_t& shotsx = shots[segmentspec+":shot"];
	shotsx.insert(shotsx.end(), franges.begin(), franges.end());

	video_frange_list_t kfs = ReadKeyFrames(segm);
	WriteLog("  "+ToStr(kfs.size())+" keyframe results found");
	video_frange_list_t& kfsx = keyframes[segmentspec+":kf"];
	kfsx.insert(kfsx.end(), kfs.begin(), kfs.end());

	video_frange_list_t tranges = ReadRangeSegments(segm, "trange");
	WriteLog("  "+ToStr(tranges.size())+" trange results found");
	video_frange_list_t trangetxt = ReadRangeSegments(segm, "trangetext");
	WriteLog("  "+ToStr(trangetxt.size())+" trangetext results found");
	tranges.insert(tranges.end(), trangetxt.begin(), trangetxt.end());

	for (auto q=tranges.begin(); q!=tranges.end(); q++) {
	  string tier_name = "xxx";
	  if (trange_tier_from=="type")
	    tier_name = q->type;
	  if (trange_tier_from.find("name")==0) {
	    tier_name = q->name;
	    if (trange_tier_from.find("base")!=string::npos) {
	      while (true) {
		size_t l = tier_name.size();
		if (!l)
		  break;
		char s = tier_name[l-1];
		if ((s<'0' || s>'9') && s!='_')
		  break;
		tier_name.erase(l-1);
	      }
	    }
	  }
	  // string tsegid = segmentspec+":"+tier_name;
	  // as of 2014-08-20 we assume segmentspec:
	  // is already included in tier_name
	  string tsegid = tier_name; 
	  if (debug)
	    cout << tsegid << " (" << q->name << "/" << q->type << ") : "
		 << q->str() << endl;
	  video_frange_list_t& tsegmx = tsegms[tsegid];
	  tsegmx.push_back(*q);
	}

	size_t nframes = segm.getNumFrames();
	SegmentationResultList *results = segm.readFileResultsFromXML("","");
	set<int> flist = segm.listProcessedFrames();

	WriteLog("Media file <"+ShortFileName(vfile_x)+"> contains "+
		 ToStr(nframes)+" frames of which "+ToStr(flist.size())+
		 " have been processed with <"+segmentspec+">");

	for (set<int>::const_iterator it=flist.begin(); it!=flist.end(); it++) {
	  int f = *it;
	  string fs = segm.FrameSpec(f);
	  results = segm.readFrameResultsFromXML(f, "", "");
	  if (debug && results->size())
	    cout << "FRAME [" << f << "] \"" << fs << "\" RESULTS of <"
		 << segmentspec << "> :" << endl;

	  string cons;
	  for (SegmentationResultList::const_iterator it=results->begin();
	       it!=results->end(); it++) {
	    if (debug) {
	      cout << "  NAME:  "   << it->name 	<< endl;
	      cout << "  TYPE:  "   << it->type 	<< endl;
	      cout << "  VALUE: "   << it->value	<< endl;
	      cout << "  METHODID:" << it->methodid << endl;
	      cout << "  RESULTID:" << it->resultid << endl << endl;
	    }

	    if (it->type=="detection") {
	      cons += (cons!=""?" ":"")+it->value;
	      continue;
	    }

	    if (it->type!="box" || it->name.substr(0, 4)!="face" ||
		fs.substr(0, 2)!=":s")
	      continue;

	    faces[it->name].push_back(atoi(fs.substr(2).c_str()));
	  }

	  if (cons!="" && fs.substr(0, 2)==":s") {
	    float t = atof(fs.substr(2).c_str());
	    concepts[""].push_back(make_pair(make_pair(t, t+1), cons));
	  }
	}
      }

      for (auto d=det_exp_tier.begin(); d!=det_exp_tier.end(); d++) {
	cout << "detection " << d->first << " " << d->second << endl;

	list<pair<pair<float,float>,string> >& detlist = concepts[d->second];

	float maxval = 0;
	const vector<int> och = oi->children;

	string subo = d->first;
	vector<string> subol;
	size_t p = subo.find('/');
	if (p!=string::npos) {
	  subol = SplitInSomething(":", false, subo.substr(p+1));
	  subo.erase(p);
	}
	if (subo=="subobjects") {
	  size_t li = 0;
	  for (size_t fi=0; fi<och.size(); fi++) {
	    if (!db->ObjectsTargetTypeContains(och[fi], target_video))
	      continue;
	    
	    auto psd = db->ParentStartDuration(och[fi], target_videosegment);
	    pair<double,double> startend = psd.second;
	    startend.second += startend.first;

	    string slabel = db->Label(och[fi]);
	    if (subol.size())
	      slabel = li<subol.size() ? subol[li] : "???";
	    li++;

	    cout << slabel << " " << psd.second.first << " "
		 << psd.second.second << " " << startend.second
		 << endl;

	    detlist.push_back(make_pair(startend, slabel));
	  }
	  continue;
	}

	for (size_t fi=0; fi<och.size(); fi++) {
	  if (!db->ObjectsTargetTypeContains(och[fi], target_image))
	    continue;
	  
	  const string& flabel = db->Label(och[fi]);

	  bool dummy = true;
	  map<string,vector<float> >
	    dets = db->RetrieveDetectionData(och[fi], d->first, true, dummy);

	  float val = dets.begin()->second[0];

	  cout << d->first << " " << och[fi] << " " << flabel
	       << " : " << val << endl;

	  if (val<=0)
	    continue;

	  size_t fno = 0, p = flabel.rfind(':');
	  if (p!=string::npos)
	    fno = (size_t)atoi(flabel.substr(p+1).c_str());

	  double dt = 1/fps, time = fno*dt;
	  
	  // if (time>20)
	  //   continue;

	  bool add = detlist.empty() ||
	    fabs(detlist.back().first.second-time)>dt/2;

	  if (add)
	    maxval = val;
	  if (val>maxval)
	    maxval = val;

	  if (add)
	    detlist.push_back(make_pair(make_pair(time, time+dt), d->first));
	  else
	    detlist.back().first.second = time+dt;
	  detlist.back().second = ToStr(maxval);
	}
      }

      for (auto fp = shots.begin(); fp!=shots.end(); fp++) {
	XmlDom tier = docu.Element("TIER");
	tier.Prop("DEFAULT_LOCALE", "en");
	tier.Prop("LINGUISTIC_TYPE_REF", "shot_t");
	tier.Prop("TIER_ID", fp->first);
	
	for (auto sp = fp->second.begin(); sp!=fp->second.end(); sp++) {
	  string ts0 = "ts"+ToStr(tsno++), ts1 = "ts"+ToStr(tsno++);
	  string a0 = "a"+ToStr(ano++);

	  double sec0 = sp->begin/fps, sec1 = sp->end/fps;
	  XmlDom slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts0);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec0)));
	  slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts1);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec1)));

	  XmlDom anno = tier.Element("ANNOTATION");
	  XmlDom alan = anno.Element("ALIGNABLE_ANNOTATION");
	  alan.Prop("ANNOTATION_ID",  a0);
	  alan.Prop("TIME_SLOT_REF1", ts0);
	  alan.Prop("TIME_SLOT_REF2", ts1);
	  alan.Element("ANNOTATION_VALUE", sp->name);
	}
      }

      for (auto fp = keyframes.begin(); fp!=keyframes.end(); fp++)
	if (fp->second.size()) {
	  XmlDom tier = docu.Element("TIER");
	  tier.Prop("DEFAULT_LOCALE", "en");
	  tier.Prop("LINGUISTIC_TYPE_REF", "keyframe_t");
	  tier.Prop("TIER_ID", fp->first);

	  for (auto sp = fp->second.begin(); sp!=fp->second.end(); sp++) {
	    string ts0 = "ts"+ToStr(tsno++), ts1 = "ts"+ToStr(tsno++);
	    string a0 = "a"+ToStr(ano++);

	    double sec0 = sp->begin/fps, sec1 = sec0+1/fps;
	    XmlDom slot = time.Element("TIME_SLOT");
	    slot.Prop("TIME_SLOT_ID", ts0);
	    slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec0)));
	    slot = time.Element("TIME_SLOT");
	    slot.Prop("TIME_SLOT_ID", ts1);
	    slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec1)));

	    XmlDom anno = tier.Element("ANNOTATION");
	    XmlDom alan = anno.Element("ALIGNABLE_ANNOTATION");
	    alan.Prop("ANNOTATION_ID",  a0);
	    alan.Prop("TIME_SLOT_REF1", ts0);
	    alan.Prop("TIME_SLOT_REF2", ts1);
	    alan.Element("ANNOTATION_VALUE", sp->name);
	  }
	}

      for (auto fp = tsegms.begin(); fp!=tsegms.end(); fp++) {
	XmlDom tier = docu.Element("TIER");
	tier.Prop("DEFAULT_LOCALE", "en");
	tier.Prop("LINGUISTIC_TYPE_REF", "tsegm_t");
	tier.Prop("TIER_ID", fp->first);
	
	for (auto sp = fp->second.begin(); sp!=fp->second.end(); sp++) {
	  string ann = "zzz";
	  if (sp->type=="trangetext")
	    ann = sp->text;
	  else if (trange_text_from=="name")
	    ann = sp->name;
	  else if (trange_text_from=="type")
	    ann = sp->type;

	  if (debug)
	    cout << fp->first << " (" << sp->name << "/" << sp->type
		 << ") : " << ann << " " << sp->begin_t << " " << sp->end_t
		 << endl;

	  string ts0 = "ts"+ToStr(tsno++), ts1 = "ts"+ToStr(tsno++);
	  string a0 = "a"+ToStr(ano++);

	  double sec0 = sp->begin_t, sec1 = sp->end_t;
	  XmlDom slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts0);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec0)));
	  slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts1);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec1)));

	  XmlDom anno = tier.Element("ANNOTATION");
	  XmlDom alan = anno.Element("ALIGNABLE_ANNOTATION");
	  alan.Prop("ANNOTATION_ID",  a0);
	  alan.Prop("TIME_SLOT_REF1", ts0);
	  alan.Prop("TIME_SLOT_REF2", ts1);
	  alan.Element("ANNOTATION_VALUE", ann);
	}
      }

      for (auto fp = voices.begin(); fp!=voices.end(); fp++) {
	XmlDom tier = docu.Element("TIER");
	tier.Prop("DEFAULT_LOCALE", "en");
	tier.Prop("LINGUISTIC_TYPE_REF", "voice_t");
	tier.Prop("TIER_ID", fp->first);

	for (auto sp = fp->second.begin(); sp!=fp->second.end(); sp++) {
	  string ts0 = "ts"+ToStr(tsno++), ts1 = "ts"+ToStr(tsno++);
	  string a0 = "a"+ToStr(ano++);

	  double sec0 = sp->start, sec1 = sp->end;
	  XmlDom slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts0);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec0)));
	  slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts1);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec1)));

	  XmlDom anno = tier.Element("ANNOTATION");
	  XmlDom alan = anno.Element("ALIGNABLE_ANNOTATION");
	  alan.Prop("ANNOTATION_ID",  a0);
	  alan.Prop("TIME_SLOT_REF1", ts0);
	  alan.Prop("TIME_SLOT_REF2", ts1);
	  alan.Element("ANNOTATION_VALUE", sp->txt_val[0].first);
	}
      }

      for (auto fp = ocr.begin(); fp!=ocr.end(); fp++) {
	XmlDom tier = docu.Element("TIER");
	tier.Prop("DEFAULT_LOCALE", "en");
	tier.Prop("LINGUISTIC_TYPE_REF", "ocr_t");
	tier.Prop("TIER_ID", fp->first);

	for (auto sp = fp->second.begin(); sp!=fp->second.end(); sp++) {
	  string ts0 = "ts"+ToStr(tsno++), ts1 = "ts"+ToStr(tsno++);
	  string a0 = "a"+ToStr(ano++);

	  double sec = sp->first, sec0 = sec-0.5, sec1 = sec+0.5;
	  if (sec0<0)
	    sec0 = 0;
	  XmlDom slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts0);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec0)));
	  slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts1);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec1)));

	  XmlDom anno = tier.Element("ANNOTATION");
	  XmlDom alan = anno.Element("ALIGNABLE_ANNOTATION");
	  alan.Prop("ANNOTATION_ID",  a0);
	  alan.Prop("TIME_SLOT_REF1", ts0);
	  alan.Prop("TIME_SLOT_REF2", ts1);
	  alan.Element("ANNOTATION_VALUE", sp->second);
	}
      }

      for (auto fp = faces.begin(); fp!=faces.end(); fp++) {
	XmlDom tier = docu.Element("TIER");
	tier.Prop("DEFAULT_LOCALE", "en");
	tier.Prop("LINGUISTIC_TYPE_REF", "face_t");
	tier.Prop("TIER_ID", fp->first);

	for (auto sp = fp->second.begin(); sp!=fp->second.end(); sp++) {
	  string ts0 = "ts"+ToStr(tsno++), ts1 = "ts"+ToStr(tsno++);
	  string a0 = "a"+ToStr(ano++);

	  double sec0 = *sp, sec1 = sec0+1;
	  XmlDom slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts0);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec0)));
	  slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts1);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec1)));

	  XmlDom anno = tier.Element("ANNOTATION");
	  XmlDom alan = anno.Element("ALIGNABLE_ANNOTATION");
	  alan.Prop("ANNOTATION_ID",  a0);
	  alan.Prop("TIME_SLOT_REF1", ts0);
	  alan.Prop("TIME_SLOT_REF2", ts1);
	  alan.Element("ANNOTATION_VALUE", fp->first);
	}
      }

      for (auto fp = concepts.begin(); fp!=concepts.end(); fp++) {
	XmlDom tier = docu.Element("TIER");
	tier.Prop("DEFAULT_LOCALE", "en");
	tier.Prop("LINGUISTIC_TYPE_REF", "concept_t");
	if (fp->first=="")
	  tier.Prop("TIER_ID", "concepts");
	else
	  tier.Prop("TIER_ID", fp->first);

	for (auto sp = fp->second.begin(); sp!=fp->second.end(); sp++) {
	  string ts0 = "ts"+ToStr(tsno++), ts1 = "ts"+ToStr(tsno++);
	  string a0 = "a"+ToStr(ano++);

	  double sec0 = sp->first.first, sec1 = sp->first.second;
	  XmlDom slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts0);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec0)));
	  slot = time.Element("TIME_SLOT");
	  slot.Prop("TIME_SLOT_ID", ts1);
	  slot.Prop("TIME_VALUE", ToStr((int)floor(1000*sec1)));

	  XmlDom anno = tier.Element("ANNOTATION");
	  XmlDom alan = anno.Element("ALIGNABLE_ANNOTATION");
	  alan.Prop("ANNOTATION_ID",  a0);
	  alan.Prop("TIME_SLOT_REF1", ts0);
	  alan.Prop("TIME_SLOT_REF2", ts1);
	  alan.Element("ANNOTATION_VALUE", sp->second);
	}
      }

      if (!eaf.Write(eafname))
	return ShowError(err+"failed to write ELAN file <"+eafname+">");
      
      WriteLog("Successfully elanized to <"+db->ShortFileName(eafname)+
	       "> and <"+db->ShortFileName(pfsxname)+">");
    }

    segmentspec = segmentspec_was;

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::CreateElanCsvConfPfsx(size_t idx, float fps,
				       const vector<string>& seg,
				       const vector<pair<string,string> >& det,
				       const string& csvf,
				       const string& conf,
				       const string& pfsx) {

    string err = "Analysis::CreateElanCsvConfPfsx() : ";

    DataBase *db = CheckDB();

    string objdatbase = db->SolveObjectPath(db->Label(idx));
    size_t ps = objdatbase.rfind('/'), pd = objdatbase.rfind('.');
    if (ps==string::npos || pd==string::npos || pd<ps)
      return ShowError(err+"failed with media filename");

    objdatbase.erase(pd);

    ofstream out(csvf.c_str());

    vector<FloatVectorSet> vecsets;
    vector<map<string,size_t> > vecsets_bylabel;

    for (size_t j=0; j<seg.size(); j++) {
      string datfile = objdatbase;

      datfile += "-"+seg[j]+":summary.dat";
      datfile.insert(ps+1, "features/");

      WriteLog(err+"reading dat file <"+db->ShortFileName(datfile)+">");
   
      vecsets.push_back(FloatVectorSet());
      vecsets.back().Read(datfile);
      vecsets_bylabel.push_back(vecsets.back().LabelToIndexMap());
    }

    ReadFiles(false);

    for (size_t j=0; j<Nindices(); j++) {
      // string datfile = datbase;
      // datfile += "-"+TsSom(j).Name()+".dat";
      // datfile.insert(ps+1, "features/");
      // WriteLog(err+"reading dat file <"+db->ShortFileName(datfile)+">");
      // vecsets.push_back(FloatVectorSet());
      // vecsets.back().Read(datfile);

      const FloatVectorSet& dat = TsSom(j).Data();
      if (dat.Nitems()==0)
	return ShowError(err+"feature #"+ToStr(j)+" is empty file???");
      // cout << dat.Nitems() << endl;
      vecsets.push_back(dat);
      vecsets_bylabel.push_back(vecsets.back().LabelToIndexMap());
   }

    const object_info *oi = db->FindObject(db->Label(idx));
    const vector<int>& och = oi->children;

    set<size_t> frames;
    FloatVectorSet fset(det.size());
    vector<float> detmax(det.size());

    for (size_t fi=0; fi<och.size(); fi++) {
      if (!db->ObjectsTargetTypeContains(och[fi], target_image))
	continue;
      
      const string& l = db->Label(och[fi]);
      size_t p = l.find(':');
      if (p!=string::npos)
	frames.insert(atoi(l.substr(p+1).c_str()));

      if (det.size()) {
	FloatVector dv(det.size(), NULL, l.c_str());
	size_t dvi = 0;
	for (auto d=det.begin(); d!=det.end(); d++, dvi++) {
	  bool dummy = true;
	  map<string,vector<float> >
	    dets = db->RetrieveDetectionData(och[fi], d->first, true, dummy);
	  dv[dvi] = dets.begin()->second[0];
	  
	  if (dv[dvi]>detmax[dvi])
	    detmax[dvi] = dv[dvi];

	  if (fi==0) {
	    simple::VectorComponent c;
	    c.name = d->second;
	    fset.AppendComponentDescription(c);
	  }
	}
	fset.AppendCopy(dv);
      }
    }
    if (fset.Nitems()) {
      vecsets.push_back(fset);
      vecsets_bylabel.push_back(vecsets.back().LabelToIndexMap());
    }
    // cout << frames.size() << endl;

    if (vecsets.size()) {
      if (frames.size()) {
	size_t last = *frames.rbegin();
	for (size_t i=0; i<last; i++)
	  frames.insert(i);
      }

      bool first = true;
      for (auto si=frames.begin(); si!=frames.end(); si++) {
	if (first) {
	  out << "s,frame";
	  for (size_t k=0; k<vecsets.size(); k++) {
	    const vector<simple::VectorComponent>& c =
	      vecsets[k].ComponentDescriptions();
	    for (int j=0; j<vecsets[k].VectorLength(); j++)
	      out << "," << ((int)c.size()==vecsets[k].VectorLength()?
			     c[j].name:"v"+ToStr(k)+":"+ToStr(j));
	  }
	  out << endl;
	  first = false;
	}

	char time[100];
	sprintf(time, "%.3f", *si/fps);
	out << time << "," << *si;

	string label = db->Label(idx)+":"+ToStr(*si);

	for (size_t k=0; k<vecsets.size(); k++) {
	  FloatVector *v = vecsets[k].Get(vecsets_bylabel[k][label]);
	  for (int j=0; j<vecsets[k].VectorLength(); j++)
	    out << "," << (v?(*v)[j]:0.0);
	}
	out << endl;
      }
    }

    vector<string> vname { "frame-diff", "feat-diff", "motion" };
    vector<float>  max   {     200.0,       100.0,      10.0   };

    XmlDom xml = XmlDom::Doc();
    XmlDom timeseries = xml.Root("timeseries");
    timeseries.Prop("date", "2012-06-06T12:30:48+02:00");
    timeseries.Prop("version", "1.0");
    XmlDom tracksource = timeseries.Element("tracksource");
    tracksource.Prop("sample-type", "Continuous Rate");
    tracksource.Prop("source-url", "file://"+csvf);
    tracksource.Prop("time-column", "0");
    XmlDom property = tracksource.Element("property");
    property.Prop("key", "provider");
    property.Prop("value", "mpi.eudico.client.annotator."
		  "timeseries.csv.CSVServiceProvider");

    for (size_t j=0; j<seg.size(); j++)
      for (size_t i=0; i<3; i++) {
	XmlDom track = tracksource.Element("track");
	track.Prop("derivative", "0");
	track.Prop("name", seg[j]+":"+vname[i]);
	XmlDom property = track.Element("property");
	property.Prop("key", "detect-range");
	property.Prop("value", "true");
	XmlDom sample_position = track.Element("sample-position");
	XmlDom pos = sample_position.Element("pos");
	pos.Prop("col", ToStr(2+3*j+i));
	pos.Prop("row", "0");
	track.Element("description", "Description of "+vname[i]);
	track.Element("units");
	track.Element("color", "0,255,0");
	XmlDom range = track.Element("range");
	range.Prop("max", ToStr(max[i]));
	range.Prop("min", "0.00");
      }

    vector<float> maxl { 0.5, 0.3, 0.1, 0.05, 0.03, 0.01, 0.005, 0.003, 0.001 };
    size_t col = 2+3*seg.size();
    for (size_t j=0; j<Nindices(); j++) {
      const FloatVectorSet& data = TsSom(j).Data();
      FloatVector maxv = data.MaximumComponents();
      for (size_t i=0; i<(size_t)data.VectorLength(); i++) {
	string fn = TsSom(j).Name();
	if (data.VectorLength()>1)
	  fn += "["+ToStr(i)+"]";
	XmlDom track = tracksource.Element("track");
	track.Prop("derivative", "0");
	track.Prop("name", fn);
	XmlDom property = track.Element("property");
	property.Prop("key", "detect-range");
	property.Prop("value", "true");
	XmlDom sample_position = track.Element("sample-position");
	XmlDom pos = sample_position.Element("pos");
	pos.Prop("col", ToStr(col++));
	pos.Prop("row", "0");
	track.Element("description", "Description of "+fn);
	track.Element("units");
	track.Element("color", "0,255,255");
	XmlDom range = track.Element("range");
	float max = maxv[i];
	for (auto m=maxl.begin(); m!=maxl.end(); m++)
	  if (maxv[i]<*m)
	    max = *m;
	range.Prop("max", ToStr(max));
	range.Prop("min", "0.00");
      }
    }

    size_t ndet = 0, max_ndet = 10;
    for (auto j=det.begin(); j!=det.end() && ndet<max_ndet; j++, ndet++) {
      XmlDom track = tracksource.Element("track");
      track.Prop("derivative", "0");
      track.Prop("name", j->second);
      XmlDom property = track.Element("property");
      property.Prop("key", "detect-range");
      property.Prop("value", "true");
      XmlDom sample_position = track.Element("sample-position");
      XmlDom pos = sample_position.Element("pos");
      pos.Prop("col", ToStr(col++));
      pos.Prop("row", "0");
      track.Element("description", "Description of "+j->second);
      track.Element("units");
      track.Element("color", "0,0,255");
      XmlDom range = track.Element("range");
      float max = NiceUpperLimit(detmax[ndet]);
      range.Prop("max", ToStr(max));
      range.Prop("min", "0.00");
    }

    xml.Write(conf);    

    XmlDom pxml = XmlDom::Doc();
    XmlDom preferences = pxml.Root("preferences");
    preferences.Prop("version", "1.1");
    preferences.Prop("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
    preferences.Prop("xsi:noNamespaceSchemaLocation",
		     "http://www.mpi.nl/tools/elan/Prefs_v1.1.xsd");
    XmlDom prefList = preferences.Element("prefList");
    prefList.Prop("key", "MultiTierViewer.TierOrder");
    prefList.Element("String", "msr:kf");
    prefList.Element("String", "msr:shot");
    for (size_t si=0; si<seg.size(); si++)
      prefList.Element("String", seg[si]+":shot");

    ElanPfsxAdd(preferences, "LayoutManager.CurrentMode", "Int", "1");
    ElanPfsxAdd(preferences, "LayoutManager.VisibleMultiTierViewer",
		"String", "mpi.eudico.client.annotator.viewer.TimeLineViewer");
    ElanPfsxAdd(preferences, "MultiTierViewer.ActiveTierName",
		"String", "msr:shot");

    ElanPfsxAdd(preferences, "MediaTime",          "Long", "0");
    ElanPfsxAdd(preferences, "SelectionBeginTime", "Long", "0");
    ElanPfsxAdd(preferences, "SelectionEndTime",   "Long", "0");
    ElanPfsxAdd(preferences, "TimeScaleBeginTime", "Long", "0");

    size_t tot = col-2;
    ElanPfsxAdd(preferences, "TimeSeriesViewer.NumberOfPanels", "Int",
		ToStr(tot));

    for (size_t j=0; j<seg.size(); j++)
      for (size_t i=0; i<3; i++) {
	prefList = preferences.Element("prefList");
	prefList.Prop("key", "TimeSeriesViewer.Panel-"+ToStr(tot--));
	prefList.Element("String", seg[j]+":"+vname[i]);
      }

    for (size_t j=0; j<Nindices(); j++) {
      const FloatVectorSet& data = TsSom(j).Data();
      for (size_t i=0; i<(size_t)data.VectorLength(); i++) {
	string fn = TsSom(j).Name();
	if (data.VectorLength()>1)
	  fn += "["+ToStr(i)+"]";
	prefList = preferences.Element("prefList");
	prefList.Prop("key", "TimeSeriesViewer.Panel-"+ToStr(tot--));
	prefList.Element("String", fn);
      }
    }

    ndet = 0;
    for (auto j=det.begin(); j!=det.end() && ndet<max_ndet; j++, ndet++) {
      prefList = preferences.Element("prefList");
      prefList.Prop("key", "TimeSeriesViewer.Panel-"+ToStr(tot--));
      prefList.Element("String", j->second);
    }

    pxml.Write(pfsx);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::ElanPfsxAdd(XmlDom& p, const string& key,
			     const string& type, const string& val) {
    XmlDom pref = p.Element("pref");
    pref.Prop("key", key);
    pref.Element(type, val);
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseVideoTimeline(const vector<string>&
                                                          args) {
    string err = "AnalyseVideoTimeline() : ";

    if (args.empty())
      return ShowError(err+"arguments should be given");

    WriteLog("AnalyseVideoTimeline");
    ReadFiles();
    DataBase *db = GetDataBase();
    
    // bool show = verbose>3;
    if (verbose>2) {
      videofile::debug(99);
      videofile::keep_tmp_files(true);
    }

    // ground_truth_set gt_set = db->GroundTruthExpressionListNew(classname);

    bool ok = true;
    for (size_t v=0; ok && v<args.size(); v++) {
      const string& vlab = args[v];
      string vfile = db->ObjectTypeAndPath(vlab, target_video);
      if (vfile=="") {
        ok = ShowError(err+"label <"+vlab+"> is not an existing video file");
        break;
      }

      vfile = "";

      int idx = db->LabelIndex(vlab);
      string sfile = db->SolveSegmentFilePath(idx, segmentspec, true);

      segmentfile segm(vfile, sfile, NULL, NULL, NULL, true, true, false);
      
      size_t nframes = segm.getNumFrames();
      WriteLog("Video file <"+ShortFileName(vfile)+"> contains "+
               ToStr(nframes)+" frames");

      const object_info *oi = CheckDB()->FindObject(vlab);
      oi->dump();
      
      WriteLog("Object <"+vlab+"> has "+
	       ToStr(oi->children.size())+" children (before)");
      CheckDB()->MakeSubObjectIndex();
      WriteLog("Object <"+vlab+"> has "+
	       ToStr(oi->children.size())+" children (after)");

      video_frange_list_t frange = ReadRangeSegments(segm, "frange");
      video_frange_list_t::const_iterator frange_it = frange.begin();

      size_t begin = 0, end = 0;
      if (!frange.empty()) {
        WriteLog("Segmentation file <"+ShortFileName(sfile)+"> contains "+
                 ToStr(frange.size())+" frame ranges");
	for (video_frange_list_t::const_iterator i=frange_it;
	     i!=frange.end(); i++) {
	  cout << i->str() << endl;

	  if (i==frange_it)
	    begin = i->begin;

	  if (i->end>end)
	    end = i->end;
	}
      }
      cout << "begin=" << begin << " end=" << end << endl;

      size_t tlwidth = 586;

      if (false) {
	imagedata tl(tlwidth, 1, 1, imagedata::pixeldata_uchar);
	for (size_t x=0; x<tlwidth; x++)
	  tl.set(x, 0, (unsigned char)(x?255:0));

	for (video_frange_list_t::const_iterator i=frange_it;
	     i!=frange.end(); i++) {
	  size_t x = (size_t)floor(float(i->end-begin)/
				   (end-begin)*(tlwidth-1)+0.5);
	  tl.set(x, 0, (unsigned char)0);
	}
	imagefile::write(tl, imagefilename+"-"+vlab+"-tl.png", "image/png");
      }

      size_t smin = 1, smax = 592;
      size_t ns = 30, tnw = 32, tnh = 3*tnw/4;

      if (false) {
	imagedata tn(ns*(tnw+1)-1, tnh, 3, imagedata::pixeldata_uchar);
	for (size_t x=0; x<ns; x++) {
	  size_t s = smin+floor(float(smax-smin)*(x+0.5)/ns);
	  string slab = vlab+":s"+ToStr(s);
	  cout << "x=" << x << " s=" << s << " slab=" << slab << endl;
	  imagedata img = CheckDB()->ImageData(CheckDB()->LabelIndex(slab));
	  scalinginfo scale(img.width(), img.height(), tnw, tnh);  
	  img.rescale(scale, 1);
	  img.convert(imagedata::pixeldata_uchar);
	  img.force_three_channel();
	  tn.copyAsSubimage(img, x*(tnw+1), 0);
	}
	imagefile::write(tn, imagefilename+"-"+vlab+"-tnbar.png", "image/png");
      }

      map<string,string> name2face, face2name, face2name_unique;

      list<string> namel = GetDataBase()->SplitClassNames("name:All");
      ground_truth nameall(GetDataBase()->Size());
      map<string,ground_truth> namegt;
      for (list<string>::const_iterator n=namel.begin(); n!=namel.end(); n++) {
	ground_truth gt = db->GroundTruthExpression(*n);
	namegt[*n] = gt;
	cout << "name=" << *n << " " << gt.positives() << endl;
	nameall = nameall.TernaryOR(gt);
	name2face[*n] = "";
      }

      vector<unsigned char> white(3), grey(3), red(3);
      white[0] = white[1] = white[2] = 255;
      grey[0] = grey[1] = grey[2] = 128;
      red[0] = 255; red[1] = red[2] = 0;

      ground_truth faceall(GetDataBase()->Size());
      map<string,ground_truth> facegt;

      list<string> classl = GetDataBase()->SplitClassNames(classname);
      for (list<string>::const_iterator c=classl.begin();
	   c!=classl.end(); c++) {
	face2name[*c] = "";

	ground_truth gt = db->GroundTruthExpression(*c);
	cout << "class=" << *c << " " << gt.positives() << endl;

	facegt[*c] = gt;
	faceall = faceall.TernaryOR(gt);

	imagedata cltl(tlwidth, 1, 3, imagedata::pixeldata_uchar);
	for (size_t x=0; x<tlwidth; x++)
	  cltl.set(x, 0, white);

	for (size_t i=0; i<gt.size(); i++)
	  if (gt[i]==1) {
	    const string& lab = db->Label(i);
	    size_t p = lab.find(":s");
	    if (p==string::npos)
	      cout << ":s not found in <" << lab << "> idx=" << i << endl;
	    else {
	      size_t s = atoi(lab.substr(p+2).c_str());
	      size_t x = (size_t)floor(float(s-smin)/
				       (smax-smin)*(tlwidth-1)+0.5);
	      cout << "lab=<" << lab << "> s=" << s
		   << " x=" << x << " idx=" << i;
	      bool hit = false;
	      if (nameall[i]==1) {
		hit = true;
		cout << " HIT";
		for (list<string>::const_iterator n=namel.begin();
		     n!=namel.end(); n++) {
		  ground_truth gt = namegt[*n];
		  if (gt[i]==1) {
		    cout << " " << *c << " matches " << *n;
		    if (name2face[*n]!="")
		      name2face[*n] += " ";
		    name2face[*n] += *c;
		    if (face2name[*c]!="")
		      face2name[*c] += " ";
		    face2name[*c] += *n;
		    if (face2name_unique[*c]=="")
		    face2name_unique[*c] = *n;
		  }
		}
	      }

	      cout << endl;
	      cltl.set(x, 0, hit?red:grey);
	    }
	  }

	imagefile::write(cltl, imagefilename+"-"+vlab+"-"+*c+".png",
			 "image/png");
      }

      imagedata cltl(tlwidth, 1, 3, imagedata::pixeldata_uchar);
      for (size_t x=0; x<tlwidth; x++)
	cltl.set(x, 0, white);

      for (size_t i=0; i<nameall.size(); i++)
	if (nameall[i]==1) {
	  const string& lab = db->Label(i);
	  size_t p = lab.find(":s");
	  size_t s = atoi(lab.substr(p+2).c_str());
	  size_t x = (size_t)floor(float(s-smin)/(smax-smin)*(tlwidth-1)+0.5);
	  cltl.set(x, 0, faceall[i]?red:grey);
	}

      imagefile::write(cltl, imagefilename+"-"+vlab+"-names.png", "image/png");

      for (map<string,string>::const_iterator i=name2face.begin();
	   i!=name2face.end(); i++)
	cout << i->first << " => " << i->second << endl;

      for (map<string,string>::const_iterator i=face2name.begin();
	   i!=face2name.end(); i++)
	cout << i->first << " => " << i->second << endl;

      list<string> asrl = GetDataBase()->SplitClassNames("asr:All");
      ground_truth asrall(GetDataBase()->Size());
      map<string,ground_truth> asrgt;
      for (list<string>::const_iterator n=asrl.begin(); n!=asrl.end(); n++) {
	ground_truth gt = db->GroundTruthExpression(*n);
	asrgt[*n] = gt;
	cout << "asr name=" << *n << " " << gt.positives() << endl;
	asrall = asrall.TernaryOR(gt);
      }

      for (size_t x=0; x<tlwidth; x++)
	cltl.set(x, 0, white);

      for (size_t i=0; i<asrall.size(); i++)
	if (asrall[i]==1) {
	  const string& lab = db->Label(i);
	  size_t p = lab.find(":s");
	  size_t s = atoi(lab.substr(p+2).c_str());
	  size_t x = (size_t)floor(float(s-smin)/(smax-smin)*(tlwidth-1)+0.5);
	  cltl.set(x, 0, faceall[i]?red:grey);
	}
      imagefile::write(cltl, imagefilename+"-"+vlab+"-asr.png", "image/png");

      // this logic should be in AnalyseSubtitles()...
      ofstream os((vlab+"-faces.ass").c_str());

      for (list<string>::const_iterator c=classl.begin();
	   c!=classl.end(); c++) {
	ground_truth gt = facegt[*c];
	for (size_t i=0; i<gt.size(); i++)
	  if (gt[i]==1 || (nameall[i]&&c==classl.begin())) {
	    if (nameall[i]&&c!=classl.begin())
	      continue;

	    const string& lab = db->Label(i);
	    size_t p = lab.find(":s");
	    double s0 = atoi(lab.substr(p+2).c_str());
	    s0 -= 2;
	    double s1 = s0+0.99;

	    string t0 = DataBase::ASStimeStr(s0), t1 = DataBase::ASStimeStr(s1);

	    string st = nameall[i] ? "personte" : "personfa";

	    string n = "???";
	    if (gt[i]==1) {
	      n = face2name_unique[*c];

	    } else {
	      for (map<string,ground_truth>::const_iterator x=namegt.begin();
		   x!=namegt.end(); x++)
		if (x->second[i]==1) {
		  n = x->first;
		  break;
		}
	    }

	    if (n.find("name:")==0)
	      n.erase(0, 5);

	    size_t z = n.find('-');
	    if (z!=string::npos)
	      n[z] = ' ';

	    os << "Dialogue: 0," << t0 << "," << t1 << "," << st
	       << ",foo,000,000,000,," << n << endl;
	  }	
      }
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  int Analysis::SolveFrameIndex(const string& videolabel, 
                                const size_t framenumber, 
                                const bool forceold) const {

    int idx = -1;
    bool idxok = false;

    if (!forceold) {
      const vector<int>& sub =
	GetDataBase()->SubObjects(LabelIndex(videolabel));
      if (sub.size()>framenumber) {
        idx = sub[framenumber];

        if (GetDataBase()->ObjectsTargetType(idx)&target_image) 
          idxok = true;
      }
    }

    if (!idxok) { // the old way, used e.g. with BBC rushes
      string label = videolabel+":"+ToStr(framenumber);
      idx = LabelIndex(label);
    }

    return idx;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::video_frange_list_t 
  Analysis::ReadRangeSegments(const segmentfile& segm, const string& t) const {
    string msg = "Analysis::ReadRangeSegments() : ";
    if (t!="frange" && t!="trange" && t!="trangetext")
      ShowError(msg+"should be either frange or trange or trangetext, "
		"was \""+t+"\"");

    video_frange_list_t frange;

    SegmentationResultList *r = segm.readFileResultsFromXML("", t, true);
    if (!r)
      return frange;

    for (SegmentationResultList::const_iterator ri=r->begin();
         ri!=r->end(); ri++) {
      if (verbose>3)
        cout << "[" << ri->type << "][" << ri->name << "]["
             << ri->value << "]" << endl;

      if (t=="frange") {
	size_t start, end;
	string text;
	stringstream ss(ri->value);
	ss >> start >> end;
	getline(ss, text);
	while (text[0]==' ')
	  text.erase(0, 1);

	const DataBase *db = NULL; // obs!
	size_t idx = (size_t)-1; // obs!
	frange.push_back(video_frange(db, idx, start, end+1,
				      ri->type, ri->name, text));

      } else if (t=="trange" || t=="trangetext") {
	cout << ri->trange_text << endl;

	const DataBase *db = NULL; // obs!
	size_t idx = (size_t)-1; // obs!
	frange.push_back(video_frange(db, idx, ri->trange_start, ri->trange_end,
				      ri->type, ri->name, ri->trange_text));
      }
    }

    delete r;          

    return frange;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::video_frange_list_t Analysis::ReadKeyFrames(const segmentfile&
							segm) const {
    video_frange_list_t frange;

    SegmentationResultList *r = segm.readFileResultsFromXML("", "keyframe",
                                                            true);
    if (!r)
      return frange;

    for (SegmentationResultList::const_iterator ri=r->begin();
         ri!=r->end(); ri++) {
      if (verbose>3)
        cout << "[" << ri->name << "][" << ri->type << "]["
             << ri->value << "]" << endl;
      size_t start, end;
      string text;
      stringstream ss(ri->value);
      ss >> start >> end >> text;

      const DataBase *db = NULL; // obs!
      size_t idx = (size_t)-1; // obs!
      frange.push_back(video_frange(db, idx, start, end+1,
				    ri->type, ri->name, text));
    }

    delete r;          

    return frange;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::WriteFrameRanges(const video_frange_list_t& frange,
                                  const string& opath) const {
    AddDescription *ad = NULL;
    segmentfile *image = NULL;
    if (!OpenAddDescription(ad, image, opath))
      return ShowError("WriteFrameRanges() : OpenAddDescription() failed");

    for (video_frange_list_t::const_iterator i=frange.begin();
         i!=frange.end(); i++)
      ad->addPendingAnnotation(i->name, "frange", i->value());

    return CloseSegmentation(ad, image);
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseInsertFrames(const vector<string>&) {
    string err = "AnalyseInsertFrames() : ";

    WriteLog("AnalyseInsertFrames");
    DataBase *db = GetDataBase();

    const ground_truth& gt = QueryRestrictionGT();
    vector<size_t> idxs = gt.indices(1);
    
    for (size_t ii=0; ii<idxs.size(); ii++) {
      size_t pidx = idxs[ii];

      if (!db->ObjectsTargetTypeContains(pidx, target_video))
	continue;

      db->FindObject(pidx)->dump();
      map<string,string> o = db->ReadOriginsInfo(pidx, false, true);
      // cout << "  " << o["frames"] << endl;
      string dim = o["dimensions"];
      size_t p = dim.find('x');
      if (p!=string::npos) {
	p = dim.find('x', p+1);
	if (p!=string::npos)
	  dim.erase(p);
      }

      size_t nf = atoi(o["frames"].c_str());
      for (size_t f=0; f<nf; f++) {
	string l = db->Label(pidx)+":"+ToStr(f);
	if (db->LabelIndexGentle(l, false)>=0)
	  return ShowError(err+"label <"+l+"> already exists");

	target_type tt = target_image;
	if (!db->AddLabelAndParents(l, tt, false))
	  return ShowError(err+"AddLabelAndParents() failed for <"+l+">");
	size_t idx = db->LabelIndex(l);

	string jpeg = l+".jpeg";
	string mime = "image/jpeg";
	string tar  = db->Label(pidx)+".tar["+jpeg+"]";

	map<string,string> oi = o;
	oi["dimensions"] = dim;
	int nframes = 0;
	float framerate = 0.0;
	XmlDom xml;
	if (!db->InsertOriginsInfo(idx, false, "", jpeg, mime, tar, "-",
				   "", oi, "-", tt, nframes, framerate, xml))
	  return ShowError(err+"InsertOriginsInfo() failed for <"+l+">");
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseExtractKeyFrames(const vector<string>& args) {
    string err = "AnalyseExtractKeyFrames() : ";

    bool use_subdir = false, check_frames = true, use_cacheing = false;
    string ext = ".jpeg", mime = "image/jpeg";

    if (!args.empty())
      return ShowError(err+"arguments should NOT be given, "
		       "use queryrestriction");
    
    WriteLog("AnalyseExtractKeyFrames");
    ReadFiles();
    DataBase *db = GetDataBase();

    bool ok = true;

    const ground_truth& gt = QueryRestrictionGT();
    vector<size_t> idxs = gt.indices(1);

    for (size_t ii=0; ii<idxs.size(); ii++) {
      size_t idx = idxs[ii];

      if (!db->ObjectsTargetTypeContains(idx, target_video))
	continue;

      const string& vlab = db->Label(idx);
      string vfile = db->ObjectTypeAndPath(vlab, target_video);
      if (vfile=="")
        return ShowError(err+"label <"+vlab+"> is not an existing video file");

      string lab = vlab+":kf1";
      string subd = use_subdir ? db->LabelSubDir(lab) : "";
      string fn = db->SolveObjectPath(lab, subd, "", true)+ext;
      if (FileSize(fn)>0) {
        WriteLog("Keyframe image file <"+fn+"> already exists, skipping");
        continue;
      }

      WriteLog("Starting to extract keyframe <"+lab+">");      

      // imagefile::debug_impl(255);
      imagefile segmx(vfile);
      segmx.frame_cacheing(use_cacheing);
      imagefile *segmp = &segmx, *segmpx = NULL;

      imagedata firstframe;
      try {
	firstframe = segmx.frame(0);
      } catch (const string& etxt) {
	return ShowError(err+"reading first frame of <"+vfile+
			 "> failed: "+etxt);
      }

      int w = firstframe.width(), h = firstframe.height();
      size_t nframez = segmx.nframes();
      float fps      = segmx.video_fps();

      if (check_frames)
	for (size_t i=0; i<nframez; i++) {
	  imagedata dp = segmx.frame(i);
	  if (dp.isempty()) {
	    WriteLog("Video file <"+ShortFileName(vfile)+"> truncted from "+
		     ToStr(nframez)+" to "+ToStr(i)+" frames");
	    nframez = i;
	    segmp = segmpx = new imagefile(vfile);
	    segmpx->frame_cacheing(use_cacheing);
	  }
	}

      WriteLog("Video file <"+ShortFileName(vfile)+"> contains "+
               ToStr(nframez)+" frames @ "+ToStr(fps)+"fps, "+
               ToStr(nframez/fps)+" seconds");

      // *** Here goes algorithm to select key frame

      size_t step = db->FrameStep();
      size_t fmargin = db->Margin();

      // if video is longer than 15 secs, we look at only middle 1/3
      if (nframez > 15*fps) fmargin =  nframez/3;
      
      // margin should be at least as big as the step
      if (fmargin < step) fmargin = step;

      size_t midf = (size_t)floor(double(nframez)/2);

      /* loop 1:
       * calculate average image to v
       * and initialize framevals to distance from centre 
      */
      if (verbose>1)
        cout << "Calculating average image" << flush;
      map<size_t,float> framevals; 
      const int vsize = w*h*3;
      vector<float> vvec(vsize, 0.0);
      int numf=0;
      for (size_t f=fmargin; f<nframez-fmargin; f+=step) {
        framevals[f] = 1.0 - (float)abs((int)(midf-f))/midf;
        
        imagedata dp = segmp->frame(f);
	if (dp.isempty()) {
	  delete segmpx;
	  return ShowError(err+"Frame #"+ToStr(f)+" not available, "
			   "consider enabling check_frames");
	}

	try {
	  dp.convert(imagedata::pixeldata_float);
	} catch (const string& etxt) {
	  delete segmpx;
	  return ShowError(err+"convert() failed: "+etxt);
	}

	dp.normalize_01();

	vector<float> dv = dp.get_float();

	for (int i=0; i<vsize; i++)
	  vvec[i] += dv[i];
	numf++;

        if (verbose>1)
          cout << "." << flush;
      }
      if (verbose>1)
        cout << endl;

      // normalize average image
      for (int i=0; i<vsize; i++) 
        vvec[i] /= (float)numf;

      /* loop 2: 
       * calc. difference from average image v
       * calc. diff. to previous and next frame ("motion")
       * update kframe to index with maximum frameval
       */
      size_t kframe = midf;
      float maxval = -1.0;
      if (verbose>1)
        cout << "(dist from centre) "
             << " - (dist from average)"
             << " - (dist prev and next frame)"
             << " = frame value" << endl;

      for (size_t f=fmargin; f<nframez-fmargin; f+=step) {
        vector<float> prevv = segmp->frame(f-1).get_float();
        vector<float> dv    = segmp->frame(f  ).get_float();
        vector<float> nextv = segmp->frame(f+1).get_float();
        
	float diff=0.0, dist=0.0;
	if (dv.size() && prevv.size() && nextv.size())
	  for (int i=0; i<vsize; i++) {
	    // dist from average image
	    diff += fabs(vvec[i]-dv[i]);
	    // motion
	    float distp = fabs(dv[i]-prevv[i]);
	    float distn = fabs(dv[i]-nextv[i]);
	    dist += distp + distn;
	  }

        diff /= vsize;
        dist /= vsize*2;

        float distc=framevals[f];

        framevals[f] += - diff - dist;
        if (framevals[f] > maxval) {
          maxval = framevals[f];
          kframe = f;
        }
        if (verbose>1)
          cout << "[" << f << "]\t= " << distc 
               << " - " << diff 
               << " - " << dist
               << " = " << framevals[f] << endl;
      }

      // *** end of algorithm

      WriteLog("Selected key frame as frame #"+ToStr(kframe));

      imagedata imgd = segmp->frame(kframe);

      WriteLog("Writing key frame image <"+ShortFileName(fn)+">");
      Picsom()->MakeDirectory(fn,true);
      imagefile::write(imgd, fn, mime);

      if (addlabels) {
	int index = db->LabelIndexGentle(lab);
	if (index != -1) {
	  ok = ShowError(err+"Label <"+lab+"> already exists!");
	  continue;
	}
	index = db->AddOneLabel(lab, target_imagefile, true, false);
	if (index<0) {
	  ok = ShowError(err+"AddOneLabel("+lab+") failed");
	  continue;
	}
	WriteLog("Added label <"+lab+">");
      }

      delete segmpx;
    }
    
    db->CloseLabelsFile(false);

    return ok;
  }
  
  /////////////////////////////////////////////////////////////////////////////
  
  Analysis::analyse_result 
  Analysis::AnalyseFixOrigins(const vector<string>& /*args*/) {
    bool ok = true;
    DataBase *db = GetDataBase();
    ground_truth gt = DataBaseRestrictionGT();
    for (size_t i=0; ok && i<db->Size(); i++) {
      if (gt[i]!=1)
        continue;
      ok = db->FixUnknownOrigins(i);
    }
    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseVideoShotSequence(const vector<string>& args) {
    string err = "AnalyseVideoShotSequence() : ";

    if (args.empty())
      return ShowError(err+"arguments should be given");

    float maxd = 800;

    WriteLog("AnalyseVideoShotsequence");
    ReadFiles();

    DataBase *db = CheckDB();

    size_t vidx = db->LabelIndex(args[0]);
    if (vidx==(size_t)-1)
      return ShowError(err+"label index failed for <"+args[0]+">");

    const object_info *oi = db->FindObject(vidx);
    vector<size_t> ch;
    for (size_t i=0; i<oi->children.size(); i++) {
      size_t cidx = oi->children[i];
      if (db->ObjectsTargetTypeContains(cidx, target_videosegment))
	ch.push_back(cidx);
    }

    const string& featname = CheckQuery()->vectorIndex(0).IndexName();
    if (db->UseBinFeaturesRead())
      for (size_t k=0; k<db->Nindices(); k++)
	if (db->IndexName(k)==featname) {
	  VectorIndex *vidx = dynamic_cast<VectorIndex*>(db->GetIndex(k));
	  const string augm;
	  if (vidx) 
	    vidx->BinDataOpen(false, db->Size(), false, augm);
	  break;
	}

    vector<size_t> c = ch;
    vector<set<size_t> > memb(c.size());
    for (size_t i=0; i<c.size(); i++)
      memb[i].insert(i);
     
    list<vector<float> > set;
    cox::matrix<float> diff(c.size(), c.size());
    for (size_t i=0; i<c.size(); i++) {
      FloatVector *vi = db->FeatureData(featname, c[i], false);
      if (!vi) {
	oi =  db->FindObject(c[i]);
	if (oi->children.size())
	  vi = db->FeatureData(featname, oi->children[0], false);
      }
      if (!vi)
	return ShowError(err+"feature <"+featname+"> data for <"
			 +db->Label(c[i])+"> not found");
      for (size_t j=i; j<c.size(); j++) {
	float dd = 0;
	if (j!=i) {
	  FloatVector *vj = db->FeatureData(featname, c[j], false);
	  if (!vj) {
	    oi =  db->FindObject(c[j]);
	    if (oi->children.size())
	      vj = db->FeatureData(featname, oi->children[0], false);
	  }
	  if (!vj)
	    return ShowError(err+"feature <"+featname+"> data for <"
			     +db->Label(c[j])+"> not found");
	  dd = vi->DistanceSquaredEuclidean(*vj);
	  delete vj;
	}
	diff(i, j) = diff(j, i) = dd;
      }
      vector<float> v((float*)*vi, *vi+vi->Length());
      set.push_back(v);
      delete vi;
    }

    auto mean_cov = cox::stat::mean_covariance(set);
    const vector<float>& mean = mean_cov.first;
    const matrix<float>& cov  = mean_cov.second;

    list<vector<float> > pset;

    if (0) {
      auto eigvec_val = cov.eigenvectors(2);
      const list<vector<float> >& eigvec = eigvec_val.first;
      const vector<float>&        eigval = eigvec_val.second;

      matrix<float> base(eigvec.begin(), eigvec.end());
      subspace<float> ss(mean, base, eigval);

      for (auto i=set.begin(); i!=set.end(); i++)
	pset.push_back(ss.projection_coeff(*i));
    }

    const float mfloat = numeric_limits<float>::max();
    matrix<float> diffx = diff;

    for (size_t r=0;; r++) {
      cout << "Starting round " << r << " with " << c.size()
	   << " clusters" << endl;
      for (size_t i=0; i<memb.size(); i++) {
	cout << i << " :";
	for (auto j=memb[i].begin(); j!=memb[i].end(); j++)
	  cout << " " << *j;
	cout << endl;
      }

      cout << "XXX";
      for (size_t i=0; i<c.size(); i++)
	for (size_t j=0; j<memb.size(); j++)
	  if (memb[j].find(i)!=memb[j].end()) {
	    cout << ":" << j;
	    break;
	  }
      cout << endl;

      diffx.show();

      float mind = mfloat;
      pair<size_t,size_t> minp;
      for (size_t i=0; i<diffx.rows(); i++)
	for (size_t j=i+1; j<diffx.rows(); j++)
	  if (diffx(i, j)<mind) {
	    bool pair_ok = true;
	    for (auto a=memb[i].begin(); pair_ok && a!=memb[i].end(); a++)
	      for (auto b=memb[j].begin(); pair_ok && b!=memb[j].end(); b++)
		if (*a==*b+1 || *b==*a+1)
		  pair_ok = false;
	 
	    if (pair_ok) {
	      mind = diffx(i,j);
	      minp = make_pair(i, j);
	    }
	  }
      if (mind==mfloat || mind>maxd)
	break;
      
      cout << "XXy " << mind << endl;

      cout << "combining clusters" << endl;
      cout << "  " << minp.first << " :";
      for (auto j=memb[minp.first].begin(); j!=memb[minp.first].end(); j++)
	cout << " " << *j;
      cout << endl;
      cout << "  " << minp.second << " :";
      for (auto j=memb[minp.second].begin(); j!=memb[minp.second].end(); j++)
	cout << " " << *j;
      cout << endl;

      for (auto j=memb[minp.second].begin(); j!=memb[minp.second].end(); j++)
	memb[minp.first].insert(*j);
      memb.erase(memb.begin()+minp.second);

      for (size_t i=0; i<diffx.rows(); i++)
	if (i!=minp.first) {
	  float a = diffx(i, minp.first);
	  float b = diffx(i, minp.second);
	  float c = a<b ? a : b;
	  diffx(i, minp.first) = diffx(minp.first, i) = c;
	}

      for (size_t i=minp.second; i<diffx.rows()-1; i++)
	for (size_t j=0; j<diffx.rows(); j++)
	  diffx(i, j) = diffx(j, i) = diffx(i+1, j);
      diffx.remove_row(diffx.rows()-1);
      diffx.remove_column(diffx.columns()-1);
    }

    vector<size_t> symb;
    for (size_t i=0; i<c.size(); i++)
      for (size_t j=0; j<memb.size(); j++)
	if (memb[j].find(i)!=memb[j].end()) {
	  symb.push_back(j);
	  break;
	}

    map<string,size_t> tuples;
    for (size_t i=0; i<c.size()-1; i++) {
      string s = ToStr(symb[i])+"-"+ToStr(symb[i+1]);
      tuples[s]++;
    }
    float entropy = 0;
    for (auto i=tuples.begin(); i!=tuples.end(); i++) {
      float p = i->second/(c.size()-1.0);
      entropy -= p*log(p);
    }
    entropy /= log(2);

    cout << "XXr " << float(memb.size())/c.size() << endl;
    cout << "XXh " << entropy << endl;
    
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseVideoSummary(const vector<string>& 
                                                         args) {
    string err = "AnalyseVideoSummary() : ";

    if (args.empty())
      return ShowError(err+"arguments should be given");

    WriteLog("AnalyseVideoSummary");
    ReadFiles();
    
    if (verbose>2) {
      videofile::debug(99);
      videofile::keep_tmp_files(true);
    }

    DataBase *db = GetDataBase();
    ground_truth_set gt_set = db->GroundTruthExpressionListNew(classname);

    bool ok = true;
    for (size_t v=0; ok && v<args.size(); v++) {
      const string& vlab = args[v];
      string vfile = db->ObjectTypeAndPath(vlab, target_video);
      if (vfile=="") {
        ok = ShowError(err+"label <"+vlab+"> is not an existing video file");
        break;
      }

      size_t step = db->FrameStep();
      float clip_min_sec = summarycliplength; // 2.0; //0.64; //1.0; 
      float shot_min_sec = 3*clip_min_sec; //10.0; // 3.0;

      string mstr;
      ground_truth_list gtl;
      list<string> extra;
      AddExtraVariableInfo(extra, "framestep",    ToStr(step));
      AddExtraVariableInfo(extra, "shot_min_sec", ToStr(shot_min_sec));
      AddExtraVariableInfo(extra, "clip_min_sec", ToStr(clip_min_sec));
      query->WriteAnalyseVariablesNew("VideoSummary", mstr, gtl, extra);

      int idx = db->LabelIndex(vlab);
      string sfile = db->SolveSegmentFilePath(idx, segmentspec, true);

      WriteLog("Initializing segmentfile");
      segmentfile segm(vfile, sfile, NULL, NULL, NULL, false, true, false);

      ground_truth rst = DataBaseRestrictionGT();

      WriteLog("Determining nframes and fps");      
      size_t nframes = rst.NumberOfEqual(1); //segm.getNumFrames();
      float  fps     = 25;    //segm.videoFPS();
      size_t clip_min_frames = (size_t)(fps*clip_min_sec);

      WriteLog("Processing video file <"+ShortFileName(vfile)+
	       "> with restriction <"+rst.label()+"> containing "+
               ToStr(nframes)+" frames @ "+ToStr(fps)+"fps, "+
               ToStr(nframes/fps)+" seconds");

      video_frange_list_t frange = ReadRangeSegments(segm, "frange");
      if (frange.empty())
        return ShowError(err+"frange empty");
        
      WriteLog("Segmentation file <"+ShortFileName(sfile)+"> contains "+
               ToStr(frange.size())+" frame ranges");

      CreateIndexData(false);

      //double sum_fraction = 0.02; // 2008: 0.02 ; 2007: 0.04
      size_t sum_nframes = (size_t)floor(summarylength*nframes);
      size_t sum_nclips  = (size_t)floor(sum_nframes/(fps*clip_min_sec));

      WriteLog("Summary will be at most "+ToStr(summarylength*100)+ 
               "% of the original length and will contain "+ToStr(sum_nframes)+
               " frames in "+ToStr(sum_nclips)+" clips");

      video_frange_list_t signature_bnd;
      FloatVectorSet      signature_vec;
      vector<int>         lengths;
      vector<float>       contents;

      size_t frange_it_no = 0;
      for (video_frange_list_t::const_iterator frange_it = frange.begin();
           frange_it!=frange.end(); frange_it++, frange_it_no++) {
        stringstream ss;
        ss << "frange #" << frange_it_no << " " << frange_it->str();
        string fstr = ss.str();

        if (verbose>1)
          cout << "Starting to process " << fstr;

	if (rst[frange_it->begin]!=1 || rst[frange_it->end-1]!=1) {
	  if (verbose>1)
            cout << " frame range not inside defined restriction" << endl;
          continue;
        }

        float nsecs = frange_it->nframes()/fps;
        if (nsecs<shot_min_sec) {
          if (verbose>1)
            cout << " " << frange_it->nframes()
                 << " frames is too short, skipping" << endl;
          continue;
        }
 
        if (verbose>1)
          cout << endl;

        float cl_faces=1.0, cl_speech=1.0, cl_motion=1.0,
          cl_colorbars=1.0, cl_black=1.0, cl_white=1.0;
        for (size_t f=frange_it->begin; f<frange_it->end-1; f++)
          for (size_t s=0; s<gt_set.size(); s++) {
            int index = SolveFrameIndex(vlab, f);
            if (gt_set[s][index]==1) {
              if      (gt_set[s].label().find("faces") != string::npos)
                cl_faces++;
              else if (gt_set[s].label().find("speech") != string::npos)
                cl_speech++;
              else if (gt_set[s].label().find("object-motion") != string::npos)
                cl_motion++;
               else if (gt_set[s].label().find("black-detect") != string::npos) 
                cl_black++;
               else if (gt_set[s].label().find("white-detect") != string::npos)
                cl_white++;
               else if (gt_set[s].label().find("colorbar2-detect") 
			!= string::npos)
                cl_colorbars++;
	    }
          }

        float cv = log(cl_faces)*10 + log(cl_speech)*1 + log(cl_motion)*1 +
          log(cl_black)*(-5) + log(cl_white)*(-5) + log(cl_colorbars)*(-10);
        cout << "CLASSES FOUND: " << (cl_faces>1.01?"faces ":"")
	     << (cl_speech>1.01?"speech ":"")
             << (cl_motion>1.01?"motion ":"") << (cl_black>1.01?"black ":"") 
             << (cl_white>1.01?"white ":"") 
	     << (cl_colorbars>1.01?"colorbars ":"")
             << ": value=" << cv << endl;        
        if (cv<0.0) {
          if (verbose>1)
            cout << " Overall frame contents negative: " << cv
                 << ", skipping" << endl;
          continue;
        }
        
        contents.push_back(cv);
        lengths.push_back((int)frange_it->nframes());

        FloatVector vec = FrameRangeSignature(*frange_it, vlab, step);
        if (verbose)
          cout << " " << fstr << " signature norm: " << vec.Norm() << endl;

        vec.Normalize();
        signature_vec.AppendCopy(vec);
        signature_bnd.push_back(*frange_it);
      }

      WriteLog(ToStr(signature_bnd.size())+" frame ranges inspected");

      video_frange_list_t select = SelectFrameRanges(signature_bnd,
                                                     signature_vec,
                                                     lengths, contents, 
                                                     sum_nclips);
      if (select.size() > sum_nclips) 
	ShowError("SelectFrameRanges() failed to reject enough clips: ", 
		  ToStr(select.size()), ">", ToStr(sum_nclips));

      video_frange_list_t clips;     
      ground_truth gt_maxp(db->Size(), -1); 
      size_t j = 0;
      cout << "SELECTED " << select.size() << " CLIPS:" << endl;
      for (video_frange_list_t::const_iterator i=select.begin();
           i!=select.end(); i++, j++) {

        size_t midp = (i->begin+i->end-1)/2;
        size_t cliphalf = size_t(clip_min_sec*fps/2);
        map <size_t,float> framevals;
        for (size_t f=i->begin+cliphalf; f<i->end-1-cliphalf; f++) {
          int a = abs((int)(midp-f));
          int b = (int)(midp-(i->begin));
          framevals[f] = 1.0 - (float)a/b;
        }
        
        for (size_t f=i->begin+cliphalf; f<i->end-1-cliphalf; f++)
          for (size_t s=0; s<gt_set.size(); s++) {
            int index = SolveFrameIndex(vlab, f);
            if (gt_set[s][index]==1) {
              float weight = 0.0;
              size_t radius = 0;

	      if        (gt_set[s].label().find("faces") != string::npos) {
                weight = 0.2; radius = 5;
	      } else if (gt_set[s].label().find("badframes") != string::npos) {
                weight = -0.5; radius = 2*clip_min_frames;
	      } else if (gt_set[s].label().find("staticframes") != string::npos) {
                weight = -0.1; radius = 2;
	      } else if (gt_set[s].label().find("motionframes") != string::npos) {
                weight = 0.1; radius = 2;
	      } else if (gt_set[s].label().find("speech") != string::npos) {
                weight = 0.05; radius = 2;
	      } else if (gt_set[s].label().find("object-motion") != string::npos) {
                weight = 0.05; radius = 2;
	      } else if (gt_set[s].label().find("camera-motion") != string::npos) {
                weight = 0.05; radius = 2;
	      } else if (gt_set[s].label().find("camera-zoom") != string::npos) {
                weight = 0.05; radius = 2;
	      } else if (gt_set[s].label().find("black-detect") != string::npos ||
			 gt_set[s].label().find("white-detect") != string::npos ||
			 gt_set[s].label().find("colorbar2-detect") != string::npos) {
                weight = -0.5; radius = 20;
	      } else if (gt_set[s].label().find("clapper2-detect") != string::npos) {
                weight = -0.5; radius = 20;                
              } else
		ShowError(err+"unrecognized class label: "+gt_set[s].label());
              
              if (verbose>3)
                cout << "FOUND class=" << gt_set[s].label() << ", weight=" << weight
                     << " at frame=" << f << ", vlab=" << vlab
                     << ", index=" << index << endl;
	      for (size_t ff=f-radius; ff<f+radius*2; ff++)
		framevals[ff] += (1.0 - (float)(abs((int)(f-ff))/radius))*weight;
            }
          }

        size_t maxp = midp;
        float maxval = -1.0;
        for (map<size_t,float>::const_iterator fi=framevals.begin();
             fi!=framevals.end(); fi++) {
          //          cout << fi->second << " ";
          if ((fi->second)>maxval) {
            maxval = (fi->second);
            maxp = (fi->first);
          }
        }
        //        cout << endl;

        int maxp_idx = SolveFrameIndex(vlab, maxp);
        if (maxp_idx!=-1)
          gt_maxp[maxp_idx] = 1;
        
        size_t begin = maxp-size_t(clip_min_sec*fps/2);
        size_t end   = begin+size_t(clip_min_sec*fps);

        cout << " " << i->str() << " midframe=" << midp << ", maxval=" << maxval
             << ", maxframe=" << maxp << " " << maxp/fps << " sec. => "
             << begin << " " << end << endl;

	size_t idx = (size_t)-1; // obs!
        video_frange clip(db, idx, begin, end, "shot", "tpart"+ToStr(j), "");
        clips.push_back(clip);
      }

      db->ConditionallyWriteClassFile(true, "gt-"+segmentspec+":"+vlab, gt_maxp,
                                      "AnalyseVideoSummary()", false);

      if (Picsom()->HasSegmentationInternal())
        WriteFrameRanges(clips, "vs-"+segmentspec+":"+vlab+".seg");
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  FloatVector Analysis::FrameRangeSignature(const video_frange& r,
                                            const string& vlab,
                                            size_t step) {
    ListOf<simple::FloatMatrix> mat;
    for (size_t i=0; i<Nfeatures(); i++) {
      int bot = TsSom(i).Nlevels()-1;
      mat.Append(new simple::FloatMatrix(Map(i, bot).Height(),
					 Map(i, bot).Width()));
    }

    string fstr = r.str();
    for (size_t f=r.begin+step/2; f<r.end; f+=step) {
      int index = SolveFrameIndex(vlab, f);

      if (verbose>2)
        cout << " starting to process frame=" << f << " of " << fstr << endl;

      query->DeleteSeen();
      query->MarkAsSeenEither(index, +1.0, true);
      query->PlaceSeenOnMap();
      query->Convolve();

      for (size_t i=0; i<Nfeatures(); i++) {
        TSSOM& tssom = TsSom(i);
        int bot = tssom.Nlevels()-1;
        const simple::FloatMatrix& m = query->Convolved(i, bot, 0);
        mat[i] += m;
      }
    }

    FloatVector vec;
    for (size_t i=0; i<Nfeatures(); i++) {
      float *v = mat[i].Concatenate();
      FloatVector vv(mat[i].Size(), v);
      delete v;
      vec.Append(vv);
    }

    return vec;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::video_frange_list_t
  Analysis::SelectFrameRanges(const video_frange_list_t& bnds,
                              const FloatVectorSet& vecs,
                              const vector<int>& /*len*/,
                              const vector<float>& /*con*/,
                              size_t nclips) const {
    video_frange_list_t l;

    if (bnds.size()!=(size_t)vecs.Nitems()) {
      ShowError("SelectFrameRanges() : bnds.size()!=vecs.Nitems()");
      return l;
    }

    double eps = 0.00001;

    simple::FloatMatrix dd = vecs.MutualDistances();
    float maxval = dd.Maximum();
    for (int i=0; i<dd.Columns(); i++)
      dd.Set(i, i, MAXFLOAT);
    float minval = dd.Minimum();
    if (verbose)
      cout << "MutualDistances: max=" << maxval << ", min=" << minval 
           << ", threshold=" << threshold << endl;

    int nrej = vecs.Nitems()-nclips;
//     if (nrej<=0)
//       return bnds;
    if (verbose)
      cout << nrej << " clips will be rejected based on nrej" << endl;

    vector<int> sel(bnds.size(), 1);
    int rej=0;
    while (dd.Minimum()<threshold || rej<nrej) {
      float min_d = MAXFLOAT;
      int   min_i = -1;
      for (int i=0; i<dd.Columns(); i++) {
        float d = dd.GetColumn(i)->Minimum();
        if (d<min_d) {
          min_d = d;
          min_i = i;
        }
      }
      if (maxval-min_d < eps) {
	if (verbose) {
	  cout << "minimum distance too close to max, stopping rejection with "
	       << rej << " clips rejected" << endl;
	}
	break;
      }

      sel[min_i] = 0; 

      if (verbose) {
        video_frange_list_t::const_iterator fri = bnds.begin();
        advance(fri, min_i);
        cout << "rejected clip #" << min_i << " " << fri->str()
             << " min_d=" << min_d << endl;
      }

      dd.GetColumn(min_i)->Set(maxval);
      for (int i=0; i<dd.Columns(); i++)
        dd.Set(min_i, i, maxval);

      rej++;
    }

    video_frange_list_t::const_iterator fri = bnds.begin();
    for (size_t i=0; i<sel.size(); i++, fri++)
      if (sel[i])
        l.push_back(*fri);

    return l;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseVideoCopyDetection(const vector<string>& args) {
    string err = "AnalyseVideoCopyDetection() : ";

    vector<string> myargs;
    
    if (args.empty()) { 
      if (vcd_argstart<0 || vcd_argstop<0)
        ShowError(err+"Argument list empty and argstart/argstop are not set.");
      for (int l=vcd_argstart; l<vcd_argstop+1; l++)
        myargs.push_back(ToStr(l));
    } else
      myargs = args;

    if (queryname=="") 
      ShowError(err+"queryname should be set");
    
    WriteLog("AnalyseVideoCopyDetection");
    ReadFiles();

    if (verbose>2) {
      videofile::debug(99);
      videofile::keep_tmp_files(true);
    }
    
    CreateIndexData(false);

    DataBase *db = GetDataBase();
    bool ok = true;
    string qfile = GetVideoFilename(queryname);
    videofile qvf(qfile);
    size_t step = db->FrameStep();      
    size_t qnframes = qvf.get_num_frames()-step;

    if (verbose>0) {
      list<string> extra;
      string mstr;
      ground_truth_list gtl;
      AddExtraVariableInfo(extra, "level",        ToStr(level));
      AddExtraVariableInfo(extra, "framestep",    ToStr(step));
      AddExtraVariableInfo(extra, "threshold",    ToStr(threshold));
      AddExtraVariableInfo(extra, "overlaps",     vcd_overlaps);
      AddExtraVariableInfo(extra, "fusionmethod", vcd_fusionmethod);
      query->WriteAnalyseVariablesNew("VideoCopyDetection", mstr, gtl, extra);

      cout << " Query video " << qfile << " : processing " 
           << qnframes << " frames" << endl;
    }

    if (trecvid!="")
      cout << TimeStamp() << " TRECVID Q: " << queryname << endl;

    FloatVectorSet query_signatures = 
      CreateFrameSignatures(queryname, qnframes-1, step);

    for (size_t v=0; ok && v<myargs.size(); v++) {
      const string& vlab = myargs[v];
      string vfile = GetVideoFilename(vlab);
      videofile vf(vfile);
      size_t nframes = vf.get_num_frames()-step;
      if (verbose>0)
        cout << " Test video " << vfile << " : processing "
             << nframes << " frames" << endl;

      if (trecvid!="")
        cout << TimeStamp() << " TRECVID T: " << vlab << " " << endl;
      
      FloatVectorSet test_signatures =
        CreateFrameSignatures(vlab, nframes-1, step);

      simple::FloatMatrix detmat;
      vector<string> ovrlps = SplitInCommas(vcd_overlaps);
      for (size_t o=0; o<ovrlps.size(); o++) {
        size_t ovrlp =  atoi(ovrlps[o].c_str());
        FrameSignatureDetection(test_signatures, query_signatures, 
                                detmat, ovrlp);
        //        FrameSignatureDetection(query_signatures, 
        //                        test_signatures, detmat, ovrlp);
      }

      if (verbose>0) {
        char gnuplotf[80];
        sprintf(gnuplotf, "vcd-results-%s-%s-%s.dat", vcd_fusionmethod.c_str(),
                queryname.c_str(), vlab.c_str());
        cout << "Writing Gnuplot file " << gnuplotf << endl;      
        detmat.WriteGnuPlot(gnuplotf);
      }
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////
      
  string Analysis::GetVideoFilename(const string& lab) {
    string err = "GetVideoFilename() : ";
    string vfilename = GetDataBase()->ObjectTypeAndPath(lab, target_video);
    if (vfilename=="")
      ShowError(err+"label <"+lab+"> is not an existing video file");
    return vfilename;
  }

  /////////////////////////////////////////////////////////////////////////////

  FloatVectorSet Analysis::CreateFrameSignatures(const string& lab,
                                                 size_t nframes, size_t step) {

    string err = "CreateFrameSignatures() : ";
    if (level>=0 && !TsSom(0).LevelOK(level))
      return ShowError(err+"level ", ToStr(level), " inexistent");

    FloatVectorSet signature;    

    for (size_t f=0; f<nframes; f+=step) {
      if (verbose>2)
        cout << " starting to process frame=" << f << " of " << lab << endl;

      int index = SolveFrameIndex(lab, f, true);
      query->DeleteSeen();
      query->MarkAsSeenEither(index, +1.0, true);
      query->PlaceSeenOnMap();
      query->Convolve();

      ListOf<simple::FloatMatrix> mat;
      for (size_t i=0; i<Nfeatures(); i++) {
        // TSSOM& tssom = TsSom(i);
        const simple::FloatMatrix& m = query->Convolved(i, level, 0);
        mat.AppendCopy(m);
      }
      
      FloatVector vec;
      for (size_t i=0; i<Nfeatures(); i++) {
        float *v = mat[i].Concatenate();
        FloatVector vv(mat[i].Size(), v);
        delete v;
        vec.Append(vv);
      }
  
      vec.Normalize();
      //vec.DisplayAll();
      //cout << endl;
      signature.AppendCopy(vec);
    }
    return signature;
  }

  /////////////////////////////////////////////////////////////////////////////

  void 
  Analysis::FrameSignatureDetection(const FloatVectorSet& query_signatures, 
				    const FloatVectorSet& test_signatures,
				    simple::FloatMatrix& resmat,
				    size_t overlap) { 
    string msg = "FrameSignatureDetection() : ";
    size_t querylength = query_signatures.Nitems();
    size_t testlength  = test_signatures.Nitems();
    size_t step = GetDataBase()->FrameStep();              
    if (verbose>0)
      cout << TimeStamp() << " starting FrameSignatureDetection(), querylength="
           << querylength << ", testlength=" << testlength << ", overlap="
           << overlap << endl;

    if (querylength>testlength)
      ShowError(msg+"querylength>testlength");

    if (overlap>querylength)
      overlap = querylength;

    if (verbose>0)
      if (resmat.Columns()==0) {
        FloatVector *x = new FloatVector();
        for (size_t i=0; i<testlength-querylength; i++)
          x->Append(i*step);
        resmat.AppendColumn(x);
      }    
    
    size_t ii=0,kkk=0;
    FloatVector *res = new FloatVector();
    float mindist2=MAXFLOAT;
    FloatVector mindistv;
    for (size_t i=0; i<testlength-querylength; i++) {
      size_t kk=0;
      float mindist1=MAXFLOAT;
      FloatVector distv;

      if (vcd_fusionmethod == "concat") 
        FrameSignatureDistanceConcat(query_signatures, test_signatures,
                                     //distv,
                                     overlap, i, mindist1, kk);
      else if (vcd_fusionmethod == "min") 
        FrameSignatureDistanceMin(query_signatures, test_signatures,
                                  distv, overlap, i, mindist1, kk);
      else 
        ShowError(msg+"unknown fusionmethod: ["+vcd_fusionmethod+"]");

      res->Append(mindist1);
      if (mindist1<mindist2) {
        mindist2 = mindist1;
        mindistv = distv;
        ii=i;
        kkk=kk;
      }
    }
    if (verbose>1) {
      cout << "Detection results: " << endl;
      res->DisplayAll();
      cout << endl;
      cout << "Distance values within best match: " << endl;
      mindistv.DisplayAll();
      cout << endl;
    }

    if (verbose>0)
      resmat.AppendColumn(res);

    if (trecvid!="" || verbose>1) {
      float resmean = res->Mean();
      float resstd = res->StandardDeviation();

      if (verbose>1)
        cout << "Mean=" << resmean << ", stdev=" << resstd << endl 
             << "Best match scored " << mindist2 << " (" << (resmean-mindist2)/resstd
             << " times stdev from mean), beginning at test video frame "
             << (ii+kkk)*step << ", query video frame " << kkk*step << endl;

      if (trecvid!="")
        cout << TimeStamp() << " TRECVID R: " << ii+kkk << " " << ii+kkk+overlap 
             << " " << 1-mindist2 << " " << kkk << endl;
    }
  } 

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::FrameSignatureDistanceConcat(const FloatVectorSet& query_signatures, 
                                              const FloatVectorSet& test_signatures,
                                              // FloatVector& dv,
                                              const size_t overlap, const size_t i,
                                              float& mindist1, size_t& kk) {
    size_t querylength = query_signatures.Nitems();

    float dist=0.0, firstdist=query_signatures[0].DistanceXX(test_signatures[i]);
    for (size_t j=0; j<overlap; j++)
      dist += query_signatures[j].DistanceXX(test_signatures[i+j]);

    for (size_t k=1; k<=querylength-overlap; k++) {
      dist -= firstdist;
      dist += query_signatures[k+overlap-1].DistanceXX(test_signatures[i+k+overlap-1]);
      firstdist = query_signatures[k].DistanceXX(test_signatures[i+k]);

      if (dist<mindist1) {
        mindist1 = dist;
        kk=k;
      }
    }

    mindist1 = mindist1/(sqrt(.02)*overlap);
  }

  /////////////////////////////////////////////////////////////////////////////

//   void Analysis::FrameSignatureDistanceConcat(const FloatVectorSet& query_signatures, 
//                                               const FloatVectorSet& test_signatures,
//                                               // FloatVector& dv,
//                                               const size_t overlap, const size_t i,
//                                               float& mindist1, size_t& kk) {
//     size_t querylength = query_signatures.Nitems();

//     for (size_t k=0; k<=querylength-overlap; k++) {
//       float dist=0.0;
//       for (size_t j=0; j<overlap; j++) {
//         //cout << "i="<<i<<",j="<<j<<endl; 
//         dist += query_signatures[j+k].DistanceXX(test_signatures[i+j+k]);
//       }
//       //      dv.Append(dist/(sqrt(2)*overlap));
//       if (dist<mindist1) {
//         mindist1 = dist;
//         kk=k;
//       }
//     }
//     mindist1 = mindist1/(sqrt(2)*overlap);
//   }

  /////////////////////////////////////////////////////////////////////////////


  void Analysis::FrameSignatureDistanceMin(const FloatVectorSet& query_signatures, 
                                           const FloatVectorSet& test_signatures,
                                           FloatVector& dv,
                                           const size_t overlap, const size_t i,
                                           float& mindist1, size_t& kk) {
    size_t querylength = query_signatures.Nitems();
    size_t nsigs=Nfeatures(), siglen=query_signatures[0].Length();
    siglen = siglen/nsigs;      

    for (size_t k=0; k<=querylength-overlap; k++) {
      float dist, mindist0 = MAXFLOAT;
      for (size_t l=0; l<nsigs; l++) {
        dist = 0.0;
        FloatVector dv;
        for (size_t j=0; j<overlap; j++) {
          //cout << "i="<<i<<",j="<<j<<endl; 
          FloatVector& orig_qsig = query_signatures[j+k];
          FloatVector& orig_tsig = test_signatures[i+j+k];
          FloatVector qsig(siglen);
          FloatVector tsig(siglen);
          for (size_t ii=0; ii<siglen; ii++) {
            qsig[ii] = orig_qsig[ii+l*siglen];
            tsig[ii] = orig_tsig[ii+l*siglen];
          }
          qsig.Normalize();
          tsig.Normalize();

          dist += qsig.DistanceXX(tsig);
        }
        if (dist<mindist0)
          mindist0 = dist;
      }
      dv.Append(mindist0/(sqrt(2.0)*overlap));
      if (mindist0<mindist1) {
        mindist1 = mindist0;
        kk=k;
      }
    }
    mindist1 = mindist1/(sqrt(2.0)*overlap);
  }

  /////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseTypes(const vector<string>& args) {
  WriteLog("AnalyseTypes");
  ReadFiles(false);

  DataBase *db = GetDataBase();

  const string all = "*";
  for (size_t i = 0; i<args.size() || (i==0 && args.size()==0); i++) {
    const string& c = i==0&&args.size()==0 ? all : args[i];

    // cout << "### " << db->Name() << " " << c << endl;

    ground_truth gt = GroundTruthExpression(c, target_any_target, -1, expand);
    for (int j=0; j<gt.Length(); j++)
      if (gt[j]==1) {
        cout << "#" << j << " " << db->Label(j) << " "
             << TargetTypeString(db->ObjectsTargetType(j));

        for (size_t m=0; m<Nindices(); m++)
          for (size_t l=0; l<TsSom(m).Nlevels(); l++) {
            const IntVector& div = TsSom(m).Division(l, 0);
            if (div.IndexOK(j) && div[j]!=-1)
              cout << " " << IndexFullName(m) << "[" << l << "]";
          }
        cout << endl;
      }
  }
  
  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseLabelHash(const vector<string>&) {
  WriteLog("AnalyseLabelHash");
  ReadFiles(true);

  DataBase *db = GetDataBase();

  if (rounds==-1)
    rounds = 1;

  TicTac tt("label hash speed test");
  tt.Start();

  for (int r=0; r<rounds; r++) {
    IntVector rnd = RandVar::Permutation(db->Size(), RndSeed()+r);
  
    tt.Tic("old way");
    for (int i=0; i<rnd.Length(); i++) {
      const string& lab = Label(rnd[i]);
      int idx = LabelIndex(lab);
      if (idx!=rnd[i])
        ShowError("AnalyseLabelHash() caught an error in the old way");
      // cout << i << " " << rnd[i] << " " << lab << " " << idx << endl;
    }
    tt.Tac("old way");

    tt.Tic("new way");
    for (int i=0; i<rnd.Length(); i++) {
      // tt.Tic("Label_oi");
      const string& lab = Label(rnd[i]);
      // tt.Tac("Label_oi");
      // tt.Tic("LabelIndex_oi");
      int idx = LabelIndex(lab);
      // tt.Tac("LabelIndex_oi");
      if (idx!=rnd[i])
        ShowError("AnalyseLabelHash() caught an error in the new way");
      // cout << i << " " << rnd[i] << " " << lab << " " << idx << endl;
    }
    tt.Tac("new way");
  }

  tt.Summary(true, false, cout);

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseRgb(const vector<string>&) {
  WriteLog("AnalyseRGB");
  ReadFiles(false);

  for (size_t i=0; i<Nindices(); i++)
    for (int j=0; j<IndexNlevels(i); j++) {
      if (level>=0 && j!=level)
        continue;

      const TreeSOM& ts = Map(i, j);
      imagedata img(ts.Width(), ts.Height());
      
      for (int y=0; y<ts.Height(); y++)
        for (int x=0; x<ts.Width(); x++) {
          const FloatVector *v = ts.Unit(x, y);
          vector<float> rgb(3);
          for (int q=0; q<v->Length() && q<3; q++)
            rgb[q] = (*v)[q];

          img.set(x, y, rgb);
        }

      bool dpy = false;
      string name = ResultName(dpy, i, j, -1, "");

      DisplayOrWrite(img, dpy, name, "image/png", "AnalyseRgb:");
    }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseConv(const vector<string>& argv) {
  WriteLog("AnalyseConv");
  ReadFiles();

  CreateIndexData(false);

  int argc = argv.size();

  for (size_t i=0; i<Nindices(); i++) {
    for (int j=0; j<IndexNlevels(i); j++) {
      if (level>=0 && j!=level)
        continue;

      string ct = ConvType(i);

      if (ct.substr(0, 16)=="umatrix-unitmean" &&
          !Map(i, j).CalculateUnitMeanUmatrix())
        return false;

      int kkkk = 0;
      // removed 24.10.2005 CreateMatrices(i, j, kkkk);
      simple::FloatMatrix& img = Hits(i, j, kkkk);
      img.Size(Map(i, j).Height(), Map(i, j).Width());

      struct {
        int x, y;
      } positive[1000], negative[1000];
      int npos = 0, nneg = 0;

      for (int k=0; k<argc; k++) {
        int x, y, s = 1;
        const char *ptr = argv[k].c_str();
        if (*ptr=='-') {
          s = -1;
          ptr++;
        }
        if (sscanf(ptr, "%d,%d", &x, &y)!=2) {
          ShowError("AnalyseConv() failed with <", argv[k], ">");
          return false;
        }
        if (!img.IndexOK(y, x)) {
          char msg[1000];
          sprintf(msg, "%s[%d] size %dx%d failed with (%d,%d)",
                  TsSom(i).Name().c_str(), j, img.Columns(), img.Rows(), x, y);
          ShowError("AnalyseConv() ", msg);
          return false;
        }
        if (s>0) {
          positive[npos].x = x;
          positive[npos].y = y;
          npos++;
        } else {
          negative[nneg].x = x;
          negative[nneg].y = y;
          nneg++;
        }
      }

      // cout << "npos=" << npos << " nneg=" << nneg << endl;

      for (int kk=0; kk<npos; kk++)
        img.Set(positive[kk].y, positive[kk].x, 1.0/npos);

      for (int kl=0; kl<nneg; kl++)
        img.Set(negative[kl].y, negative[kl].x, -1.0/nneg);

      if (!query->Convolve(i, j, kkkk)) {
        ShowError("AnalyseConv() Convolve() failed");
        return false;
      }
      img = Convolved(i, j, kkkk);

      string xtra;
      if (ct.length())
        xtra = string("-")+ct;

//       float thresh;
//       FloatVector udata = Map(i, j).UnitMeanUmatrixValues();
//       udata.SortDecreasingly();
//       thresh = udata[(int)(imul*udata.Length())];

      SOM *som = NULL;
      if (threshold>0 && Map(i, j).HasRawUmatrix()) {
        som = &Map(i, j);
        som->CalculateUnitMeanUmatrix();
      }

      MakeImage(i, j, -1, xtra, classname,"BlueWhiteRedMap","AnalyseConv:",
                img, som, &SOM::UnitMeanUmatrix, threshold);

      if (MatlabName()!="") {
        string n = MatlabFileName(i, j, ct), mfile(n+".m");
        ofstream matlabos(mfile.c_str());
        if (matlabos)
          WriteLog("AnalyseConv() : writing to <", mfile.c_str(), ">");
        img.Label(n).WriteMatlab(matlabos);
        if (!matlabos) {
          ShowError("AnalyseConv() : failed to write to <", mfile, ">");
          return false;
        }
      }
    }
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseMI(const vector<string>& /*argv*/) {
  if (Nindices()!=2)
    return ShowError("AnalyseMI() : exactly two features should be selected");
  
  ReadFiles();

  if (TsSom(0).Nlevels()!=TsSom(1).Nlevels())
    return ShowError("AnalyseMI() : "
                     "the two TS-SOMs should equal in level count");

  if (level>=0 && !TsSom(0).LevelOK(level))
    return ShowError("AnalyseMI() : level ",
                     ToStr(level), " inexistent");

  WriteLog("AnalyseMI");
  
  if (classname=="")
    classname = "*";

  target_type  t = query->Target();
  ground_truth corr = GroundTruthExpression(classname, t, -1, expand);
  int ncorr = corr.NumberOfEqual(1);

  WriteLog("AnalyseMI : database=", DataBaseName());
  WriteLog("AnalyseMI : class=",    classname);
  WriteLog("AnalyseMI : objects=",  ToStr(ncorr), "/", ToStr(corr.Length()));

  for (size_t j=0; j<TsSom(0).Nlevels(); j++) {
    if (level>=0 && int(j)!=level)
      continue;

    const IntVector& d0all = TsSom(0).Division(j, 0);
    const IntVector& d1all = TsSom(1).Division(j, 0);

    IntVector d0(ncorr);
    IntVector d1(ncorr);

    for (int i=0, s=0; i<d0all.Length(); i++)
      if (corr[i]==1) {
        d0[s  ] = d0all[i];
        d1[s++] = d1all[i];
      }

    int nu = Map(0, j).Units();
    IntVector m(nu);
    double hm = m.SetIndices().SymbolEntropy();

    double h0 = d0.SymbolEntropy();
    double h1 = d1.SymbolEntropy();
    double h01min = h0<h1 ? h0 : h1;

    if (d0.NumberOfEqual(-1) || d1.NumberOfEqual(-1)) {
      ShowError("AnalyseMI() : -1 indices not allowed");
      continue;
    }

    WriteLog("AnalyseMI : level = ", ToStr(j), "  units = ", ToStr(nu));    

    WriteLog("AnalyseMI :   max.entropy = ", ToStr(hm));
    WriteLog("AnalyseMI :   entropy0    = ", ToStr(h0),
             "  fraction = ", ToStr(h0/hm));
    WriteLog("AnalyseMI :   entropy1    = ", ToStr(h1),
             "  fraction = ", ToStr(h1/hm));

    double e0 = d0.SymbolEquiVocation(d1), e1 = d1.SymbolEquiVocation(d0);
    double I = h0-e0;
    WriteLog("AnalyseMI :   equivoc.0|1 = ", ToStr(e0),
             "  fraction = ", ToStr(e0/hm));
    WriteLog("AnalyseMI :   equivoc.1|0 = ", ToStr(e1),
             "  fraction = ", ToStr(e1/hm));

    char tmps[1000];
    sprintf(tmps, "%g  fraction = %g  entropy fraction = %g",
            I, I/hm, I/h01min);

    WriteLog("AnalyseMI :   MI          = ", tmps);
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseDiv(const vector<string>& argvin) {
  if (classname!="")
    return ShowError("AnalyseDiv() : class should NOT be defined.",
                     " Instead, define positive and negative");

  bool solve_entropies = false, allow_empty = true;
  bool skip_large_avg_pair_dist = true;
  bool make_images = imagefilename!="" && imagefilename!="/dev/null";

  size_t ai = 0;
  for (; ai<argvin.size(); ai++) {
    string s = argvin[ai];
    if (s[0]!='(' || s[s.size()-1]!=')')
      break;

    s = s.substr(1, s.size()-2);
    if (s.find("entrop")==0)
      solve_entropies = true;
  }
  vector<string> argv(argvin.begin()+ai, argvin.end());

  bool native = false, alien = false;
  for (size_t i=0; i<Nindices(); i++)
    if (TsSom(i).Type()==TSSOM::tssom_normal)
      native = true;
    else if (TsSom(i).Type()==TSSOM::tssom_alien_data)
      alien = true;
    else
      return ShowError("AnalyseDiv() : unknown tssom_type");
  if (native && alien)
    return ShowError("AnalyseDiv() : native and alien tssom_types mixed");

  DataBase *db = alien ? TsSom(0).AlienDataBase() : GetDataBase();
  query->SetDataBase(db);

  WriteLog("AnalyseDiv");
  ReadFiles();

  query->StageFunc(stage_enter, func_goto_has_positives);

  string mmat;
  query->WriteAnalyseVariablesOld("Div", -1, NULL, NULL, 0, false, mmat);

  target_type t = query->Target();
  int o = -1;
  const string& pos = query->Positive();
  const string& neg = query->Negative();
  ground_truth posi = DataBaseRestrictionGT()&db->GroundTruthExpression(pos, t, o, expand);
  ground_truth nega = DataBaseRestrictionGT()&db->GroundTruthExpression(neg, t, o, expand);

  int nneg, nzero, npos;
  posi.TernaryCounts(nneg, nzero, npos);
  if (npos) {
    char tmps[1000] = "";
    if (alien)
      sprintf(tmps, "of <%s> ", db->Name().c_str());
    sprintf(tmps+strlen(tmps), "has %d/%d positive items", npos, (nneg+npos));

    WriteLog("AnalyseDiv: positive=<"+pos+"> ", tmps);
  }
  
  if (argv.size())
    for (size_t i=0; i<argv.size(); i++) {
      ground_truth s = db->GroundTruthExpression(argv[i], t, o, expand);
      int n, z, p;
      s.TernaryCounts(n, z, p);
      if (!p)
        ShowError("AnalyseDiv() : empty class <", argv[i], ">");
      posi = posi.TernaryOR(s);
    }

  posi.TernaryCounts(nneg, nzero, npos);
  if (!npos && !allow_empty) {
    ShowError("AnalyseDiv: positive=<"+pos+
              "> or command line object list empty");
    db->GroundTruthSummary(posi);
    return false;
  }

  WriteLog(db->GroundTruthSummaryStr(posi, true, true, true));

  query->CanShowSeen(true);
  query->PerMapObjects(1);
  query->MaxQuestions(1);

  map<string,double> entropyall;

  if (solve_entropies) {
    string all = "$type("+TargetTypeString(t)+")";
    ground_truth pall = db->GroundTruthExpression(all);
    ground_truth nall = db->GroundTruthExpression("",  t, o, expand);

    WriteLog("AnalyseDiv: entropy/positives: "+
             db->GroundTruthSummaryStr(pall, true, false, false));
    WriteLog("AnalyseDiv: entropy/negatives: "+
             db->GroundTruthSummaryStr(nall, true, false, false));

    query->MarkAsSeenNoAspects(&pall, &nall, db); // MarkAsSeenEmptyAspect() ?
    CbirStages();

    for (size_t i=0; i<Nindices(); i++)
      for (int j=0; j<query->NlevelsEvenAlien(i); j++) 
        for (size_t k=0; k<query->GetMatrixCount(i); k++) {
          stringstream ss;
          ss << i << ":" << j << ":" << k;
          entropyall["hh"+ss.str()] = Hits(i, j, k).Entropy();
          entropyall["hc"+ss.str()] = Convolved(i, j, k).Entropy();
        }

    query->DeleteSeen();
    query->DeleteNew();
  }

  query->MarkAsSeenEmptyAspect(&posi, &nega, db);
  CbirStages();
  analyse_result result(true);
  StoreMatrices(result);

  vector<double> mweights(Nindices());
  double mwsum=0;

  for (size_t i=0; i<Nindices(); i++)
    for (int j=0; j<query->NlevelsEvenAlien(i); j++) {
      if (level>=0) {
        if (!TsSom(i).LevelOKEvenAlien(level)&&j==0)
          ShowError("AnalyseDiv() : ", IndexFullName(i), "[",
                    ToStr(level), "] level inexistent");
        if (j!=level)
          continue;
      }
      
      const FloatVector *cvec=query->ConvolutionVector(query->ConvType(i),j);
      double h0 = cvec ? Query::ConvolutionEntropy(cvec) : 0.0 ;
      if (h0<0.0)
        h0 = 0.0;

      for (size_t k=0; k<query->GetMatrixCount(i); k++) {
        char matrixname[1000];
        sprintf(matrixname, "%s%s[%d]-%d",
                convolved?"convolved ":"", TsSom(i).Name().c_str(), j, (int)k);

        const simple::FloatMatrix& himg = Hits(i, j, k);
        const simple::FloatMatrix& cimg = Convolved(i, j, k);
        const simple::FloatMatrix& img  = convolved ? cimg : himg;
        
        if (img.Size()==0) {
          WriteLog("AnalyseDiv: skipping zero-sized matrix ", matrixname);
          continue;
        }

	simple::FloatMatrix imgout(img);
          
        SOM *som = NULL;
        if (threshold>0 && Map(i, j).HasRawUmatrix()) {
          som = &Map(i, j);
          som->CalculateUnitMeanUmatrix();
        }

        const string& cnr = query->Positive();
        string cnx = cnr;
        for (;;) {
          size_t slash = cnx.find('/');
          if (slash==string::npos)
            break;
          cnx[slash] = '_';
        }

        if (make_images) {
          string xtra = convolved ? "-convolved" : "";
          
          if (logarithm) {
            xtra  += "-logarithm";
            imgout = Logarithmize(img);
          }
          
          MakeImage(i, j, k, xtra, cnx, "BlueWhiteRedMap","AnalyseDiv:",
                    imgout, som, &SOM::UnitMeanUmatrix, threshold);
        }

        double hh = himg.Entropy(), hc = cimg.Entropy();
        double hmax = Query::MaximumEntropy(img);

        char entropytxt[2000];
        sprintf(entropytxt,"entropy of %s on %s (max. %g) is %g [%g]"
                " -> %g [%g] change: %g [%g] (max. %g)",
                cnr.c_str(), matrixname, hmax,
                hh, hh/hmax, hc, hc/hmax, 
                hc-hh, (hc-hh)/hmax, h0);
        WriteLog("AnalyseDiv: ", entropytxt);

        if (hc && cvec) {
          sprintf(entropytxt,"entropy of %s is %g ->"
                  " entropy of %s purified=%g",
                  cvec->Label(), h0, matrixname, hc-h0);
          WriteLog("AnalyseDiv: ", entropytxt);
        }

        stringstream ss;
        ss << i << ":" << j << ":" << k;
        double hha = entropyall["hh"+ss.str()];
        double hca = entropyall["hc"+ss.str()];

        sprintf(entropytxt,"entropy of ALL on %s (max. %g) is %g [%g]"
                " -> %g [%g] change: %g [%g] (max. %g)",
                matrixname, hmax,
                hha, hha/hmax, hca, hca/hmax, 
                hca-hha, (hca-hha)/hmax, h0);
        WriteLog("AnalyseDiv: ", entropytxt);

        if (hca && cvec) {
          sprintf(entropytxt,"entropy of %s is %g ->"
                  " entropy of ALL purified=%g",
                  cvec->Label(), h0, hca-h0);
          WriteLog("AnalyseDiv: ", entropytxt);
        }

        sprintf(entropytxt,"mutual information of hits   : %g - %g = %g",
                hha, hh, hha-hh);
        WriteLog("AnalyseDiv: ", entropytxt);

        sprintf(entropytxt,"mutual information convolved : %g - %g = %g",
                hca, hc, hca-hc);
        WriteLog("AnalyseDiv: ", entropytxt);

        if (MatlabName()!="") {
          stringstream hhhcss;
          hhhcss << MatlabName() << "_" << cnx << "_" << matrixname;
          string hhhcname = Simple::MakeMatlabCompliant(hhhcss.str());
          FloatVector hhhc(2, NULL, hhhcname.c_str());
          hhhc[0] = hh/hmax;
          hhhc[1] = hc/hmax;
          hhhc.WriteMatlab(hhhcname+".m");
          WriteLog("Wrote entropy values in <", hhhcname, ".m>");
        }

        simple::FloatMatrix nshimg = himg;
        nshimg *= npos;

        string cnmn = cnr + " " + matrixname;
        stringstream stmp;
        double msize = cimg.Size();
        double mu = MapUsage(nshimg);
        stmp << mu << " (" << (mu/msize) << " of SOM size) ("
             << (mu/npos) << " of class size)";
        WriteLog("Map usage      ", cnmn, " = ", stmp.str());

        if (nshimg.Columns()<=100 || !skip_large_avg_pair_dist) {
          stmp.str("");
          double ad = AveragePairDistance(nshimg);
          stmp << ad << " (" << (ad/sqrt(msize)) << ") of SOM size";
          WriteLog("Average dist. ", cnmn, " = ", stmp.str());
        }

        if (!pairdistancekernel.empty() && mu>0.0) {
          stmp.str("");
          double adk = AveragePairDistanceKernel(nshimg, pairdistancekernel);
          stmp << adk << " (" << (adk/sqrt(msize)) << ") of SOM size";
          WriteLog("Average dist. with "+pairdistancekernel+" kernel ", cnmn, 
                   " = ", stmp.str());
                   
          mweights[i] = adk/sqrt(msize);
          mwsum += adk/sqrt(msize);
        }

        stmp.str("");
        double fr = Fragmentation(nshimg);
        stmp << fr << " (" << (fr/npos) << " of class size)";
        WriteLog("Fragmentation  ", cnmn, " = ", stmp.str());

        stmp.str("");
        double pu = Purity(nshimg, query->TsSom(i).BackReference(j));
        stmp << pu;
        WriteLog("Purity         ", cnmn, " = ", stmp.str());

        if (make_images) {
          simple::FloatMatrix maskimg = himg;
          for (int y=0; y<maskimg.Rows(); y++)
            for (int x=0; x<maskimg.Columns(); x++)
              if (maskimg.Get(y, x))
                maskimg.Set(y,x, 1);
          MakeImage(i, j, k, "-mask", cnx, "BlueWhiteRedMap","AnalyseDiv:",
                    maskimg, som, &SOM::UnitMeanUmatrix, threshold);
        }          

        char matlabn[1000], matlabf[2000], gnuplotf[2000];
        string feaname = Simple::MakeMatlabCompliant(TsSom(i).Name().c_str());
        sprintf(matlabn, "%s_%s_%s_%d_%d_%s", MatlabName().c_str(),
                cnx.c_str(), feaname.c_str(),
                j, (int)k, convolved?"convolved":"raw");          
        float *foo = imgout.Concatenate();
        FloatVector stacked(imgout.Size(), foo, matlabn);
        delete foo;
        if (MatlabName()!="") {
          sprintf(matlabf, "%s.m", matlabn);
          stacked.WriteMatlab(matlabf);
          WriteLog("AnalyseDiv: wrote matlab file <", matlabf, ">");
        }

        // NOTE THAT THIS MATLAB VECTOR IS INDEXED COLUMN-WISE
        // WHEREAS THOSE MADE BY Query::MapSnapshots() ARE ROW-WISE !!!

        if (histbins) {
          // stacked.Dump(DumpLong);
	  simple::Histogram hist(&stacked, histbins);
          sprintf(gnuplotf, "%s.gnuplot", matlabn);
          // hist.Dump(DumpLong);
          hist.WriteGnuPlot(gnuplotf);
          WriteLog("AnalyseDiv: wrote <", gnuplotf, ">");
        }
      }
    }

  if (!pairdistancekernel.empty())
    cout << endl << "${features_" << query->Positive() << "}=";
  for (size_t i=0; i<Nindices(); i++) {
    mweights[i] *= Nindices()/mwsum;
    cout << (i?",":"") << TsSom(i).Name().c_str() << "(weight=" << mweights[i] 
         << ")";
  }
  cout << endl << endl;

  return result;
}

///////////////////////////////////////////////////////////////////////////////

int Analysis::MapUsage(const simple::FloatMatrix& m) {
  int n = 0;
  for (int i=0; i<m.Rows(); i++)
    for (int j=0; j<m.Columns(); j++)
      if (m.Get(i, j))
        n++;
  return n;
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::AveragePairDistanceKernel(const simple::FloatMatrix& m, 
                                           const string& fstring) {
  double (*kernelfunc)(const double);
  
  string funcname, fparam;
  if (fstring.find_first_of('(') == string::npos) 
    funcname = fstring;
  else
    SplitParentheses(fstring, funcname, fparam);
  if (funcname=="identity")
    kernelfunc = &identity_kernel;
  else if (funcname=="gaussian") {
    gaussian_kernel_d = atof(fparam.c_str());
    kernelfunc = &gaussian_kernel;
  } else
    return ShowError("Analysis::AveragePairDistanceKernel() : "
                     "Unknown kernel function: "+funcname);

  //cout << "m.Rows()=" << m.Rows() << " m.Columns()=" << m.Columns() << endl;
  double n = 0.0, s = 0.0;
  for (int i=0; i<m.Rows(); i++)
    for (int j=0; j<m.Columns(); j++)
      if (m.FastGet(i, j))
        for (int p=i; p<m.Rows(); p++)
          for (int q=0; q<m.Columns(); q++) {
            if (p==i && q==0)
              q = j;
            
            // cout << "i=" << i << " j=" << j << " p=" << p << " q=" << q
            //         << endl;

            if (m.FastGet(p, q)) {
              double dn = i==p && j==q ?
                (m.FastGet(i, j)*(m.FastGet(i, j)-1))/2 :
                m.FastGet(i, j)*m.FastGet(p, q);
              double di = i-p, dj = j-q;
/*              
              cout << i << "," << j << "  " << p << "," << q
                   << "  " << m.FastGet(i, j) << " " << m.FastGet(p, q)
                   << "  " << dn << "  " << di << "," << dj << endl;
*/            
              s += dn*kernelfunc(sqrt(di*di+dj*dj));
              n += dn;
            }
          }

  // cout << "### " << n << endl;

  return n ? s/n : MAXFLOAT;
}

///////////////////////////////////////////////////////////////////////////////

int Analysis::Fragmentation(const simple::FloatMatrix& m) {
  IntMatrix g(m.Rows(), m.Columns());
  int n = 0;
  set<int> r;

  for (int i=0; i<m.Rows(); i++)
    for (int j=0; j<m.Columns(); j++)
      if (m.Get(i, j)) {
        // cout << i << "," << j;

        set<int> t;
        if (g.Get(i, j-1))
          t.insert(g.Get(i, j-1));
        if (g.Get(i-1, j-1))
          t.insert(g.Get(i-1, j-1));
        if (g.Get(i-1, j))
          t.insert(g.Get(i-1, j));
        if (g.Get(i-1, j+1))
          t.insert(g.Get(i-1, j+1));

        /*
        if (!t.size())
          cout << ": " << (n+1);
        cout << endl;
        */

        set<int>::const_iterator p = t.begin();
        int a = t.size() ? *(p++) : ++n;
        g.Set(i, j, a);

        for (; p!=t.end(); p++)
          r.insert(*p);
      }

  return n-r.size();
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::Purity(const simple::FloatMatrix& m, const IntVectorSet& b) {
  int e = 0, t = 0;
  for (int i=0, u=0; i<m.Rows(); i++)
    for (int j=0; j<m.Columns(); j++, u++)
      if (m.Get(i, j)) {
        t++;
        if (m.Get(i, j)==b[u].Length())
          e++;
      }
  return double(e)/t;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::AnalyseShotBoundaryInit(string imsg, 
                                       ground_truth& select,
                                       XmlDom &gtresult) {

  cout << imsg << " votepercent=" << sbdparams.votepercent 
       << " framegap=" << sbdparams.framegap
       << " mindist=" << sbdparams.mindist 
       << " nframes=" << sbdparams.nframes
       << " nframes_next=" << sbdparams.nframes_next << endl;

  while (sbdparams.boundaryexp.size() < (size_t)Nindices())
    sbdparams.boundaryexp.push_back(1.3);
  while (sbdparams.feature_weight.size() < (size_t)Nindices())
    sbdparams.feature_weight.push_back(1.0);


  for (size_t i=0; i<Nindices(); i++) 
    cout << "--> Params for map " << TsSom(i).Name() 
         << " boundaryexp=" << sbdparams.boundaryexp[i] 
         << " weight=" << sbdparams.feature_weight[i] 
         << endl;

  if (classname!="") {
    select = GroundTruthExpression(classname, query->Target(), -1, expand);
    int npos = select.NumberOfEqual(1), nzero = select.NumberOfEqual(0);
    char tmps[100];
    sprintf(tmps, "%d/%d", npos, (int)DataBaseSize()-nzero);
    WriteLog("AnalyseShotBoundary: class=<", classname, "> has ",
             tmps, " items");

    if (!npos && classname!="*")
      return ShowError("only class=* should be used for empty classes");
  }

  ReadFiles();

  CreateIndexData(false);

  // if the ground truth file is specified, load the gt xml file
  gtresult = XmlDom();
  if (sbdparams.gtfile!="") {
    XmlDom gtdoc = XmlDom::Parse(sbdparams.gtfile);
    if (gtdoc.DocOK())
      gtresult = gtdoc.Root().FindChild("shotBoundaryResult");
  }


  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::CompareShotBoundaryResultsCommon(XmlDom &gtresult, 
                                                vector<pair<size_t,size_t> > 
                                                &boundaries,
                                                string &segsrc,
                                                size_t &true_positives, 
                                                size_t &gt_boundaries, 
                                                size_t &detected_boundaries,
                                                size_t &gd_true_positives, 
                                                size_t &gd_gt_boundaries, 
                                                size_t 
                                                &gd_detected_boundaries) {


  // find the right <seg> tag from the gt xml:
  XmlDom gtseg = gtresult.FirstChild();
  bool gtfound = false;
  while(gtseg.node) {
    if(gtseg.IsElement() && gtseg.NodeName() == "seg" && 
       gtseg.Property("src") == segsrc) {
      gtfound = true;
      break;
    } else
      gtseg = gtseg.Next();
  }

  if (gtfound) {
    //size_t true_positives, gt_boundaries, detected_boundaries;
    //size_t gd_true_positives, gd_gt_boundaries, gd_detected_boundaries;
    CompareShotBoundaryResults(boundaries, gtseg, true_positives, 
                               gt_boundaries, detected_boundaries,
                               gd_true_positives, gd_gt_boundaries, 
                               gd_detected_boundaries);
    double recall = gt_boundaries != 0 ? 
      (double)true_positives/(double)gt_boundaries : 0.0;
    double precision = detected_boundaries != 0 ?
      (double)true_positives/(double)detected_boundaries : 0.0;
    
    double gd_recall = gd_gt_boundaries != 0 ? 
      (double)gd_true_positives/(double)gd_gt_boundaries : 0.0;
    double gd_precision = gd_detected_boundaries != 0 ?
      (double)gd_true_positives/(double)gd_detected_boundaries : 0.0;

    double f1v = HarmonicMean(precision,recall,sbdparams.precision_weight);
    double gd_f1v = HarmonicMean(gd_precision,gd_recall,
                                 sbdparams.precision_weight);

    cout << "Precision and recall for " << segsrc << ": " << precision 
         << ", " << recall  << " -- F1: " << f1v << endl;
    cout << "GD precision and recall for " << segsrc << ": " 
         << gd_precision << ", " << gd_recall  << " -- F1: " 
         << gd_f1v << endl;
  }

  return gtfound;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::CompareShotBoundaryResultsSBD(XmlDom &gtresult, 
                                             vector<pair<size_t,size_t> > 
                                             &boundaries,
                                             string &segsrc,
                                             size_t &total_true_positives,
                                             size_t &total_sbd_boundaries,
                                             size_t &total_gt_boundaries,
                                             size_t &gd_total_true_positives,
                                             size_t &gd_total_sbd_boundaries,
                                             size_t &gd_total_gt_boundaries) {

  size_t true_positives, gt_boundaries, detected_boundaries, 
    gd_true_positives, gd_gt_boundaries, gd_detected_boundaries;
  
  if (CompareShotBoundaryResultsCommon(gtresult, boundaries, segsrc, 
                                       true_positives, 
                                       gt_boundaries, detected_boundaries,
                                       gd_true_positives, gd_gt_boundaries,
                                       gd_detected_boundaries)) {
    
    total_true_positives += true_positives;
    total_sbd_boundaries += detected_boundaries;
    total_gt_boundaries += gt_boundaries;

    gd_total_true_positives += gd_true_positives;
    gd_total_sbd_boundaries += gd_detected_boundaries;
    gd_total_gt_boundaries += gd_gt_boundaries;
  }
  
  return true;
}

///////////////////////////////////////////////////////////////////////////////

///
bool Analysis::CompareShotBoundaryResultsSBDP(size_t &total_true_positives,
                                              size_t &total_sbd_boundaries,
                                              size_t &total_gt_boundaries,
                                              size_t &gd_total_true_positives,
                                              size_t &gd_total_sbd_boundaries,
                                              size_t &gd_total_gt_boundaries,
                                              map<string, pair<double,double> >
                                              &resultmap) {

  double gradualoptpercent = sbdparams.gradualoptpercent;
  
  vector<float> params;
  params.push_back(sbdparams.votepercent);
  params.push_back(sbdparams.framegap);
  params.push_back(sbdparams.mindist);
  params.push_back(sbdparams.nframes);
  params.push_back(sbdparams.nframes_next);
  for (size_t i=0; i<Nindices(); i++) {
    params.push_back(sbdparams.boundaryexp[i]);
    params.push_back(sbdparams.feature_weight[i]);
  }
  string tmpstr = SBDParamString(params);
  
  double recall = total_gt_boundaries != 0 ? 
    (double)total_true_positives/(double)total_gt_boundaries : 0.0;
  double precision = total_sbd_boundaries != 0 ?
    (double)total_true_positives/(double)total_sbd_boundaries : 0.0;

  double gd_recall = gd_total_gt_boundaries != 0 ? 
    (double)gd_total_true_positives/(double)gd_total_gt_boundaries : 0.0;
  double gd_precision = gd_total_sbd_boundaries != 0 ?
    (double)gd_total_true_positives/(double)gd_total_sbd_boundaries : 0.0;

  double abruptoptpercent = 1.0-gradualoptpercent;

  double combined_precision = abruptoptpercent*precision + 
    gradualoptpercent*gd_precision;
  double combined_recall = abruptoptpercent*recall + 
    gradualoptpercent*gd_recall;

  resultmap[tmpstr] = pair<double,double>(combined_precision,combined_recall);
    
  return true;
}

///////////////////////////////////////////////////////////////////////////////

string Analysis::SBDParamString(vector<float> &params) {
  char tmpstr[100];
  sprintf(tmpstr,"%f,%d,%d,%d,%d",params[0],(int)params[1],(int)params[2],
          (int)params[3],(int)params[4]);
  string str = string(tmpstr);
  for (size_t i=0; i<Nindices(); i++) {
    sprintf(tmpstr,",%f,%f",params[5+i*2],params[6+i*2]);
    str.append(string(tmpstr));
  }
  return str;
}

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseFinlandiaKatsaus(const vector<string>& argv) { 
    string msg = "Analysis::AnalyseFinlandiaKatsaus() : ";

    bool write_it = !dryrun;
    bool debug = true;

    float head_min = 10, head_max = 20;
    float tail_min = 10, tail_max = 20;

    DataBase *db = CheckDB();

    if (write_it && !db->OpenReadWriteSql())
      return ShowError(msg+"database should be opened -rw=...sql...");

    if (segmentspec=="")
      return ShowError(msg+"segmentspec should be set"); 

    if (detections.size()!=1)
      return ShowError(msg+"detections.size() should be ==1"); 

    const string& dc = detections[0];

    ground_truth gt(db->Size());
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }

    vector<size_t> vidx = gt.indices(1);
    for (auto vi=vidx.begin(); vi!=vidx.end(); vi++) {
      size_t idx = *vi;
      const string& label = db->Label(idx);
      map<string,string> oi = db->ReadOriginsInfo(idx, false, true);
      string pvid = oi["name"];
      cout << msg << "STARTING " << label << " : " << pvid << endl;

      float fps = db->VideoFrameRate(idx);
      if (!fps)
	return ShowError(msg+"zero frame rate"); 

      float dur = db->VideoDuration(idx);
      if (2*dur<head_min+head_max+tail_min+tail_max)
	return ShowError(msg+"duration "+ToStr(dur)+"s too short"); 

      string ti = query->TextIndex(), text;
      if (ti=="")
	ti = db->DefaultTextIndex();
      //  obs! should this use DataBase::TextIndexLine()?
      auto tr = db->TextIndexRetrieve(idx, ti);
      for (auto k=tr.begin(); k!=tr.end(); k++) {
	cout << k->first << " = " << k->second << endl;
	if (k->first=="text")
	  text = k->second;
      }
      vector<string> textseg;
      for (string tx = text;;) {
	size_t p = tx.find(" # ");
	if (p!=string::npos) {
	  textseg.push_back(tx.substr(0, p));
	  tx.erase(0, p+3);

	} else {
	  textseg.push_back(tx);
	  break;
	}
      }
      cout << "[" << JoinWithString(textseg,"][") << "]" << endl;

      if (textseg.size()==1 && textseg[0]=="")
	return ShowError(msg+"text not found"); 

      size_t nseg = textseg.size();

      const vector<pair<size_t,size_t> > fv =
	db->VideoOrSegmentFramesOrdered(idx);
      vector<float> b(fv.size());
      auto bp = b.begin();

      for (auto i=fv.begin(); i!=fv.end(); i++, bp++) {
	bool dummy, allow_incore = false;
	auto d = db->RetrieveOrProduceDetectionData(i->first, dc, "",
						    true, dummy, allow_incore);
	if (d.size()!=1)
	  return ShowError(msg+"d.size()!=1"); 
	if (d.begin()->second.size()!=1)
	  return ShowError(msg+"d.begin()->second.size()!=1"); 

	float v = d.begin()->second[0];
	int cfy = fpclassify(v);
	if (cfy==FP_NAN || cfy==FP_INFINITE) {
	  cout << "   #" << i->first << " in " << dc << " is NaN" << endl;
	  v = 0;
	}
	*bp = v;
      }

      vector<vector<float> > fea;
      if (Nindices()) {
	const string& fname = query->IndexFullName(0);
	for (auto i=fv.begin(); i!=fv.end(); i++) {
	  FloatVector *v = db->FeatureData(fname, i->first, false);
	  vector<float> vv((float*)*v, (float*)*v+v->Length());
	  fea.push_back(vv);
	  delete v;
	}
      }

      vector<size_t> bl(nseg+1);
      float max = 0;
      size_t max_i = 0;
      size_t ia = floor(fps*head_min), ib = ceil(fps*head_max);
      for (size_t i=ia; i<=ib; i++)
	if (b[i]>max) {
	  max = b[i];
	  max_i = i;
	}
      cout << "head : " << ia << " .. " << ib << " -> " << max_i
	   << " = " << max_i/fps << " s" << endl;
      bl[0] = max_i;
      
      max = 0;
      max_i = 0;
      ia = floor(fps*(dur-tail_max)); ib = ceil(fps*(dur-tail_min));
      for (size_t i=ia; i<=ib; i++)
	if (b[i]>max) {
	  max = b[i];
	  max_i = i;
	}
      cout << "tail : " << ia << " .. " << ib << " -> " << max_i
	   << " = " << max_i/fps << " s" << endl;
      bl[bl.size()-1] = max_i;
      
      float mlen = (bl[bl.size()-1]-bl[0])/(bl.size()-1), mstd = 20;
      for (size_t i=1; i<bl.size()-1; i++)
	bl[i] = bl[0]+i*mlen;

      for (;;) {
	float bmul = 1.0e-3, mmul = 1, smul = 1;
	float score = TimeSegmentationScore(bl, 0, bl.size()-1, b, bmul,
					    mlen, mstd, mmul, fea, smul);
	for (size_t i=0; i<bl.size(); i++)
	  cout << (i?" ":"") << bl[i];
	cout << " score=" << score << endl;

	float best = score;
	vector<size_t> bl_new;
	for (size_t q=1; q<bl.size()-1; q++)
	  for (size_t p=bl[q-1]+1; p<bl[q+1]; p++) {
	    vector<size_t> bl_try = bl;
	    bl_try[q] = p;
	    float s = TimeSegmentationScore(bl_try, 0, bl_try.size()-1, b, bmul,
					    mlen, mstd, mmul, fea, smul);
	    if (s>best) {
	      best = s;
	      bl_new = bl_try;
	    }
	    if (debug)
	      cout << "q=" << q << " p=" << p << " s=" << s << endl;
	  }
	
	if (best>score)
	  bl = bl_new;
	else
	  break;
      }

      vector<size_t> sidx;
      for (size_t i=0; i<=bl.size(); i++) {
	// obs! this _might_ have some in common with similar code in
	// AnalyseShotBoundaryThreshold() and should be placed in DataBase.
	
	float sta = (i==0         ? 0        : bl[i-1])/fps;
	float end = (i==bl.size() ? b.size() : bl[i]  )/fps; 
	string seglabel = segmentspec+":"+label+":t"+ToStr(i);
	string spec = pvid+"["+SecondsToMPEG7MediaTimePoint(sta)+"/"+
	  SecondsToMPEG7MediaDuration(end-sta)+"]";
	// aa:0:t1 video+segment aa:0:t1.mp4 0.mp4[T0:0:25:0F25/PT20S0N25F]
	// - video/mp4 >256 10x10 - 0 -
	target_type tt = target_videosegment;
	if (write_it && !db->AddLabelAndParents(seglabel, tt, false))
	  return ShowError(msg+"AddLabelAndParents() failed with <"+
			   seglabel+">");

	size_t segidx = write_it ? db->LabelIndex(seglabel) : 127;
	sidx.push_back(segidx);

	cout << seglabel << " #" << segidx << " " << spec;
	if (i!=0 && i!=bl.size())
	  cout << "[" << textseg[i-1] << "]";
	cout << endl;

	map<string,string> oi;
	oi["colors"] = ">256"; 
	oi["dimensions"] = "0x0";
	oi["checksum"] = "0";
	int nframes = 0;
	float framerate = 0.0;
	XmlDom xml;
	if (write_it &&
	    !db->InsertOriginsInfo(segidx, false,
				   "", seglabel+".mp4", "video/mp4",
				   spec, "-", "", oi, "-", tt, nframes,
				   framerate, xml))
	  return ShowError(msg+"InsertOriginsInfo() failed with <"+
			   seglabel+">");

	if ((true||write_it) && i!=0 && i!=bl.size()) {
	  string line1 = "topicfi add-attribute text "+textseg[i-1];
	  string line2 = "topicfi add-document "+seglabel;
	  list<string> lines { line1, line2 };
	  if (!db->TextIndexInput(lines))
	    return ShowError(msg+"TextIndexInput() failed with ["+
			     line1+"] ["+line2+"]");
	}
      }
      if (write_it)
	db->AppendSubobjectsFile(idx, sidx);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  float Analysis::TimeSegmentationScore(const vector<size_t>& bl,
					size_t f, size_t l,
					const vector<float>& b, float bmul,
					float mean, float std, float mmul,
					const vector<vector<float> >& fea,
					float smul) { 
    string msg = "Analysis::TimeSegmentationScore() : ";

    bool debug = true;

    float r = 1, r2pi = sqrt(2*M_PI);
    for (size_t i=f; i<l; i++) {
      if (i>f) {
	if (debug)
	  cout << "dif: i=" << i << " : " << b[bl[i]] << " -> " << bmul*b[bl[i]]
	       << endl;
	r *= bmul*b[bl[i]];
      }
      float x = bl[i+1]-bl[i];
      float d = (x-mean)/std;
      float p = exp(-0.5*d*d)/(std*r2pi);
      if (debug)
	cout << "dur: i=" << i << " : " << bl[i] << " .. " << bl[i+1]
	     << " " << x << " -> " << p << " -> " <<  mmul*p
	     << endl;
      r *= mmul*p;

      if (fea.size() && fea[0].size()) {      
	vector<float> m(fea[0].size()), s(m);
      
	for (size_t j=bl[i]; j<bl[i+1]; j++) {
	  const vector<float>& f = fea[j];
	  for (size_t k=0; k<f.size(); k++) {
	    m[k] += f[k];
	    s[k] += f[k]*f[k];
	  }
	}

	size_t n = bl[i+1]-bl[i];
	float savg = 0;
	for (size_t k=0; n>1 && k<m.size(); k++) {
	  m[k] /= n;
	  s[k] = sqrt((s[k]-n*m[k]*m[k])/(n-1));
	  savg += s[k]/m.size();
	}

	float ss = 10, z = 1/(1+savg*ss);

	if (debug)
	  cout << "std: i=" << i << " : " << bl[i] << " .. " << bl[i+1]
	       << " " << savg << " -> " << z << " -> " <<  smul*z
	       << endl;

	r *= smul*z;
      }
    }

    return r;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseShotBoundaryThreshold(const vector<string>& argv) { 
    string msg = "Analysis::AnalyseShotBoundaryThreshold() : ";

    bool write_it = !dryrun;

    size_t len = 25;
    float thr = threshold;
    float max_v = 100000;
    
    if (!thr)
      return ShowError(msg+"threshold>0 should be set");

    if (segmentspec=="")
      return ShowError(msg+"segmentspec should be set, eg. segmentspec=ab"
		       " or segmentspec=ab1");

    if (detections.size()!=1)
      return ShowError(msg+"detections.size() should be ==1"); 
    const string& dc = detections[0];

    string sspec = segmentspec+"-"+ToStr(len)+"-"+ToStr(thr);
    for (;;) {
      size_t p = sspec.find('.');
      if (p==string::npos)
	break;
      sspec.erase(p, 1);
    }

    DataBase *db = CheckDB();
    ground_truth gt(db->Size());
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }

    vector<size_t> vidx = gt.indices(1);

    for (size_t i=0; i<vidx.size(); i++) {
      size_t vvidx = vidx[i];
          
      map<string,string> oi = db->ReadOriginsInfo(vvidx, false, true);
      string pvid = oi["name"];
      cout << msg << "STARTING " << sspec << " "
	   << db->Label(vvidx) << " : " << pvid << endl;

      float fps = db->VideoFrameRate(vvidx);
      if (!fps)
	return ShowError(msg+"zero frame rate"); 

      vector<pair<size_t,size_t> > fi = db->VideoOrSegmentFramesOrdered(vvidx);
      if (fi.size()==0)
	return ShowError(msg+"no frames");

      map<size_t,size_t> f2idx;
      for (auto i=fi.begin(); i!=fi.end(); i++)
	f2idx[i->second] = i->first;

      if (f2idx.size()!=fi.size())
	return ShowError(msg+"duplicate frame numbers");

      size_t first = f2idx.begin()->first, last = f2idx.rbegin()->first;
      vector<float> ff(last-first+1);
      float max = 0;
      size_t pidx = -1;
      for (size_t i=first; i<=last; i++) {
	size_t idx = f2idx.find(i)!=f2idx.end() ? f2idx[i] : pidx;
	pidx = idx;

	bool dummy = true, allow_incore = false;
	auto d = db->RetrieveOrProduceDetectionData(idx, dc, "", true, dummy,
						    allow_incore);
	if (d.size()!=1)
	  return ShowError(msg+"d.size()!=1"); 
	if (d.begin()->second.size()!=1)
	  return ShowError(msg+"d.begin()->second.size()!=1"); 

	float v = ff[i-first] = d.begin()->second[0];
	int cfy = fpclassify(v);
	if (cfy==FP_NAN || cfy==FP_INFINITE) {
	  cout << "   #" << idx << " in " << dc << " is NaN" << endl;
	  v = 0;
	}
	if (max_v>0 && v>max_v) {
	  cout << "   #" << idx << " in " << dc << " exceeds max_v " 
	       << max_v << endl;
	  v = 0;
	}

	if (verbose>1)
	  cout << db->Label(vvidx) << " " << i << " #" << idx 
	       << " " << db->Label(idx) << " "
	       << v << " max=" << max << endl;
	
	if (v>max)
	  max = v;
      }

      if (!max)
	return ShowError(msg+"max==0"); 

      for (size_t i=first; i<=last; i++)
	ff[i-first] /= max;
      
      vector<size_t> b { first };
      for (size_t i=first+len; i<=last-len; i++) {
	float v = ff[i-first];
	if (v<thr)
	  continue;

	bool is_max = true;
	for (size_t j=i-len; is_max && j<=i+len; j++)
	  if (j!=i && ff[j-first]>=v)
	    is_max = false;
	if (is_max)
	  b.push_back(i);
      }
      b.push_back(last+1);  //obs! dangerous??? no...

      vector<size_t> sidx;
      for (size_t i=0; i<b.size()-1; i++) {
	// obs! this _might_ have some in common with similar code in
	// AnalyseFinlandiaKatsaus() and should be placed in DataBase.
	
	float sta = b[i]/fps, end = b[i+1]/fps;
	string seglabel = sspec+":"+db->Label(vvidx)+":t"+ToStr(i);
	string spec = pvid+"["+SecondsToMPEG7MediaTimePoint(sta)+"/"+
	  SecondsToMPEG7MediaDuration(end-sta)+"]";
	target_type tt = target_videosegment;
	cout << "   " << seglabel << " " << b[i] << " ... " << b[i+1]-1
	     << "  " << spec << endl;
	if (write_it && !db->AddLabelAndParents(seglabel, tt, false))
	  return ShowError(msg+"AddLabelAndParents() failed with <"+
			   seglabel+">");

	size_t segidx = write_it ? db->LabelIndex(seglabel) : 127;
	sidx.push_back(segidx);

	map<string,string> oi;
	oi["colors"] = ">256"; 
	oi["dimensions"] = "0x0";
	oi["checksum"] = "0";
	int nframes = 0;
	float framerate = 0.0;
	XmlDom xml;
	if (write_it &&
	    !db->InsertOriginsInfo(segidx, false,
				   "", seglabel+".mp4", "video/mp4",
				   spec, "-", "", oi, "-", tt, nframes,
				   framerate, xml))
	  return ShowError(msg+"InsertOriginsInfo() failed with <"+
			   seglabel+">");
      }
      if (write_it)
	db->AppendSubobjectsFile(vvidx, sidx);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseShotBoundary(const vector<string>& 
							 argv) { 
    string msg = "Analysis::AnalyseShotBoundary() : ";
    if (argv.size()==0 || (argv[0]!="summary" && argv[0]!="features"))
      return ShowError(msg+"1st argument should be either \"summary\""
		       " or \"features\"");

    vector<string> a = argv;
    a.erase(a.begin());

    if (argv[0]=="summary")
      return AnalyseShotBoundaryWithSummary(a);

    if (argv[0]=="features")
      return AnalyseShotBoundaryWithFeatures(a);

    if (argv[0]=="elan")
      return AnalyseShotBoundaryFromElan(a);

    return false;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseShotBoundaryFromElan(const vector<string>& /*argv*/) { 
    string msg = "Analysis::AnalyseShotBoundaryFromElan() : ";

    return false;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseShotBoundaryWithFeatures(const vector<string>& argv) { 
    string msg = "Analysis::AnalyseShotBoundaryWithFeatures() : ";

    bool write_it = !dryrun;
    size_t len = 20, skip = 0;

    if (segmentspec=="")
      return ShowError(msg+"segmentspec should be set, eg. segmentspec=sbd"
		       " or segmentspec=sbd1");

    if (query->Nindices()==0)
      return ShowError(msg+"features unspecified");

    DataBase *db = CheckDB();
    ground_truth gt(db->Size());
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }
    vector<size_t> vidx = gt.indices(1);

    for (size_t i=0; i<vidx.size(); i++) {
      size_t idx = vidx[i];

      for (size_t j=0; j<query->Nindices(); j++) {
	auto fd = db->FeatureFrameDifference(idx, query->IndexFullName(j),
					     len, skip);

	string detname = segmentspec+"::"+query->IndexFullName(j)+"::"+
	  ToStr(len)+"_"+ToStr(skip)+"::";

	//string detfile = db->ExpandPath("detections")+"/"+detname+".bin";
	for (auto k=fd.begin(); k!=fd.end(); k++)
	  if (write_it) {
	    vector<float> v { k->second };
	    XmlDom xml;
	    if (!db->StoreDetectionResult(k->first, detname, v, xml, false))
	      return ShowError(msg+"StoreDetectionResult() failed");
	  } else
	    cout << "  #" << k->first << " = " << k->second << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseShotBoundaryWithSummary(const vector<string>& argv) { 
    string msg = "Analysis::AnalyseShotBoundaryWithSummary() : ";

    if (segmentspec=="")
      return ShowError(msg+"segmentspec should be set, eg. segmentspec=sbs"
		       " or segmentspec=sbs1");

    string exe = Picsom()->FindExecutable("opencv", "summary", "");
    if (exe=="")
      return ShowError(msg+"\"opencv/summary\" binary not found"); 
    
    string lffile = "lf_UIUC.txt", lff = exe;
    size_t p = lff.rfind('/');
    if (p!=string::npos) {
      lff.erase(p+1);
      lff += lffile;
      if (!FileExists(lff))
	return ShowError(msg+lff+" not found");
    }

    string sname = segmentspec, lname = "ShotBoundaryWsummary";
			      
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      string vfile = CheckDB()->SolveObjectPath(*a);
      if (vfile=="")
	return ShowError(msg+"path for <"+*a+"> not found");

      int idx = CheckDB()->LabelIndex(*a);

      string segout = vfile, vfileb = vfile;
      size_t ps = segout.rfind('/'), pd = segout.rfind('.');
      if (ps==string::npos || pd==string::npos || pd<ps)
	return ShowError(msg+"failed to form segmentation oputput filename");

      vfileb.erase(0, ps+1);

      segout.erase(pd);
      string datout = segout;

      segout += ".seg";
      segout.insert(ps+1, "segments/"+sname+":");

      datout += "-"+sname+":summary.dat";
      datout.insert(ps+1, "features/");

      string tmpdir = CheckDB()->TempDir(*a+"-summary");
      if (!Symlink(lff, tmpdir+"/"+lffile))
	return ShowError(msg+"symlinking "+lff+" to "+tmpdir+" failed");

      videofile vf(vfile);
      float fps = vf.get_frame_rate();
      string wxh = ToStr(vf.get_width())+"x"+ToStr(vf.get_height());

      string outf = tmpdir+"/summary.out";

      //int clipnf = (int)ceil(fps*15/25); //obs! 25 fps clipsize=15 <=> 0.6 s

      // vector<string> cmd1 { "(", "cd", tmpdir, ";",
      // 	  exe, vfile, "--showvalues", "--showshots", "--novideo",
      // 	  "--sbs=r", "--clipsize="+ToStr(clipnf), "--nclips=7000",
      // 	  ")", "1>"+outf, "2>&1"
      // 	  };

      vector<string> cmd2 { "(", "cd", tmpdir, ";",
	  exe, vfile, "--showvalues", "--showshots", "--novideo",
	  "--sbs=r", ")", "1>"+outf, "2>&1"
	  };

      Picsom()->ExecuteSystem(cmd2, true, true, true);
      
      string out = FileToString(outf);
      vector<string> lines = SplitInSomething("\n", false, out);

      AddDescription *ad = NULL;
      segmentfile *image = NULL;
      if (!OpenAddDescription(ad, image, segout, sname, lname))
	return ShowError(msg+"OpenAddDescription() failed");
      
      FloatVectorSet vecset;
      vector<pair<string,string> > newlab;

      string ext = ".avi";  // obs" hard-coded
      string mime = FileExtensionToMIMEtype(ext);

      for (auto l=lines.begin(); l!=lines.end(); l++)
	if (l->find("SHOTDATA ")==0) {
	  stringstream data;
	  data << *l;
	  string tmp;
	  int shotno, start, end;
	  data >> tmp >> shotno >> start >> end; // [start,end[
	  stringstream val;
	  val << start << " " << end-1 << " shot";
	  string valstr = val.str();
	  // cout << *l << " => " << valstr << endl;
	  ad->addPendingAnnotation("shot"+ToStr(shotno), "frange", valstr);
	  string nl = segmentspec+":"+*a+":t"+ToStr(shotno);
	  string ol = nl+ext+"\t"+vfileb+"["+ToStr(start)+"-"+ToStr(end-1)+
	    "]\t-\t"+mime+"\t>256\t"+wxh+"x"+ToStr(end-start)+"@"+ToStr(fps)+
	    "\t0\t0\t-";
	  newlab.push_back(make_pair(nl, ol));

	} else if (l->find("VALUEDATA ")==0) {
	  stringstream data;
	  data << *l;
	  string tmp;
	  int frameno;
	  float v0, v1, v2;
	  data >> tmp >> frameno >> v0 >> v1 >> v2;
	  FloatVector v(3);
	  v.Label(CheckDB()->Label(idx)+":"+ToStr(frameno));
	  v[0] = v0;
	  v[1] = v1;
	  v[2] = v2;
	  vecset.AppendCopy(v);
	}
      
      CloseSegmentation(ad, image);
      
      CheckDB()->WriteLog("Wrote shot boundary data to <"
			  +CheckDB()->ShortFileName(segout)+">");

      Picsom()->MakeDirectory(datout, true); 
      vecset.Write(datout);      

      CheckDB()->WriteLog("Wrote shot boundary detection values to <"
			  +CheckDB()->ShortFileName(datout)+">");

      if (addlabels) {
	bool ok = true;
	for (size_t l=0; ok && l<newlab.size(); l++)
	  ok = CheckDB()->AddLabelAndParents(newlab[l].first,
					     target_videosegment, true);
	if (newlab.size())
	  CheckDB()->CloseLabelsFile(true);

	if (ok)
	  CheckDB()->WriteLog("Added "+ToStr(newlab.size())+" new labels");
	else
	  return ShowError(msg+"failed to add "+ToStr(newlab.size())+
			   " new labels");

	if (ok) {
	  for (size_t l=0; ok && l<newlab.size(); l++)
	    ok = CheckDB()->UpdateOriginsInfo(0, newlab[l].first,
					      newlab[l].second);
	  if (ok)
	    CheckDB()->WriteLog("Added origins info for "+
				ToStr(newlab.size())+" new objects");
	  else
	    return ShowError(msg+"failed to add origins info for"+
			     ToStr(newlab.size())+" new objects");
	}
      }

      /*
	vector<string> cmd2 { exe, "--second", vfile };
	Picsom()->ExecuteSystem(cmd2, true, true, true);
      */
    }
    
    return true;
  }
  
///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result 
Analysis::AnalyseShotBoundaryTrecvid(const vector<string>& /*argv*/) { 

  ground_truth select;
  XmlDom gtresult;

  AnalyseShotBoundaryInit("Analysis::AnalyseShotBoundary : Using parameters",
                          select, gtresult);

  // write the results to an xml file
  XmlDom doc = XmlDom::Doc("shotBoundaryResults","",
                           "shotBoundaryResults.dtd");
  XmlDom results = doc.Root("shotBoundaryResults");
  XmlDom result = results.Element("shotBoundaryResult");

  // OBS! fill in the missing information:
  result.Prop("sysId","something");
  result.Prop("totalRunTime","something");
  result.Prop("totalDecodeTime","something");
  result.Prop("totalSegmentationTime","something");
  result.Prop("processorTypeSpeed","something");

  bool compareresults = gtresult.node 
    && gtresult.NodeName() == "shotBoundaryResult";

  size_t total_true_positives = 0, total_sbd_boundaries = 0, 
    total_gt_boundaries = 0, gd_total_true_positives = 0, 
    gd_total_sbd_boundaries = 0, gd_total_gt_boundaries = 0;

  // for each object..
  for (size_t k=0; ; k++) {
    if (k==GetDataBase()->Size())
      break;
    
    // class restrictions etc:
    if (select.Length() && select[k]!=1)
      continue;
    
    vector<vector<IntPoint> > trajectory = SolveSubObjectTrajectories(k);

    /*    for (size_t dbg=0; dbg < trajectory.size(); dbg++) {
      cout << "DEBUG: trajectory for map " << TsSom(dbg).Name() << endl;
      for (size_t dbg2=0; dbg2 < trajectory[dbg].size(); dbg2++) {
        int b1 = dbg2-sbdparams.nframes-sbdparams.framegap;
        int e1 = dbg2-sbdparams.framegap;
        int b2 = dbg2;
        int e2 = dbg2+sbdparams.nframes_next;
        FloatPoint c1 = TrajectoryAvgPoint(trajectory[dbg], b1, e1);
        FloatPoint c2 = TrajectoryAvgPoint(trajectory[dbg], b2, e2);
        float r1 = TrajectoryMaxDistance(trajectory[dbg], b1, e1, c1);
        float r2 = TrajectoryMaxDistance(trajectory[dbg], b2, e2, c2);
        cout << " frame " << dbg2 << ": " << trajectory[dbg][dbg2].X() 
             << "," << trajectory[dbg][dbg2].Y() 
             << " avgpointprev=" << c1.X() << "," << c1.Y() << " - " << r1 
             << " avgpointnext=" << c2.X() << "," << c2.Y() << " - " << r2
             << endl;
      }
      }*/

    vector<pair<size_t,size_t> > boundaries = SolveShotBoundaries(trajectory);

    XmlDom seg = result.Element("seg");
    string segsrc = Label(k);
    seg.Prop("src",segsrc);
    size_t framecount = trajectory.size() > 0 ? trajectory[0].size() : 0;
    seg.Prop("totalFNum",framecount);

    //cout << "Shot boundaries for label " << LabelP(k) << " :" << endl;
    //    const float fps = 29.97;

    // common for both segmentation data generation methods:

    string segm = "sb";
    if (!segmentspec.empty())
      segm = segmentspec;

    string opath = GetDataBase()->SolveObjectPath(Label(k),"","",false);
    opath.erase(opath.find_last_of("/"));
    opath.append("/segments/"+segm+":");
    opath.append(Label(k));
    opath.append(".seg");
    picsom->MakeDirectory(opath.c_str(), true);

    size_t running_tpart_num = 0;
    int tpart_start = 0;
    int tpart_end;

    AddDescription *ad = NULL;
    segmentfile *image = NULL;
    if (!OpenAddDescription(ad, image, opath))
      return ShowError("AnalyseShotBoundary() : OpenAddDescription() failed");

    ostringstream segcmd;
    static const string segprogram = 
      "~/picsom/segmentation/segmentation.linux64.fast";
    segcmd << segprogram << " -o " << opath << " ad";

    for (size_t bi=0; bi<boundaries.size(); bi++) {
      XmlDom trans = seg.Element("trans");    

      // TRECVID-optimization: expand transition windows to 5 frames:
      if(trecvid != "") {
        static const size_t tvminlength = 5;
        if(boundaries[bi].second < tvminlength) {
          boundaries[bi].first -= 
            (size_t) ceil((tvminlength-boundaries[bi].second)/2.0);
          boundaries[bi].second = tvminlength;
        }
      } 

      string transtype = boundaries[bi].second > 0 ? "grad" : "cut";
      size_t prefnum   = boundaries[bi].first-1;
      size_t postfnum  = boundaries[bi].first+boundaries[bi].second;
      trans.Prop("type",     transtype);
      trans.Prop("preFNum",  prefnum);
      trans.Prop("postFNum", postfnum);

      // generate the segmentation data:
      tpart_end = prefnum;
      ostringstream name;
      name << "tpart" << running_tpart_num++;
      ostringstream value;
      value << tpart_start << " " << tpart_end << " shot";

      ad->addPendingAnnotation(name.str(), "frange", value.str());
      segcmd << " -aag " << name.str() << ".frange=\"" << value.str() << "\"";

      // add another tpart, if transition duration > 0
      if(postfnum-prefnum > 1) {
        name.str("");
        name << "tpart" << running_tpart_num++;
        value.str("");
        value << prefnum+1 << " " << postfnum-1 << " tran";

        ad->addPendingAnnotation(name.str(), "frange", value.str());
        segcmd << " -aag " << name.str() << ".frange=\"" << value.str() 
               << "\"";
      }
      tpart_start = postfnum; // update for next iteration

      /*float seconds = (float)boundaries[bi].first/fps;
      int minutes = (int) floor(seconds / 60.0);
      seconds -= minutes*60;*/
      /*cout << "SB " << bi << ": " << boundaries[bi].first
           << " (" << minutes << " min " << (int)seconds << " s): " 
           << boundaries[bi].second << " frames" << endl;*/
    }


    // add the last tpart (from the last transition to the end)
    tpart_end = framecount-1;
    if(tpart_end-tpart_start >= 0) {
      ostringstream name; 
      name << "tpart" << running_tpart_num++;
      ostringstream value;
      value << tpart_start << " " << tpart_end << " shot";

      ad->addPendingAnnotation(name.str(), "frange", value.str());
      segcmd << " -aag " << name.str() << ".frange=\"" << value.str() << "\"";
    }

    cout<<"added "<<running_tpart_num<<" tpart descriptions."<<endl;
    segcmd << " ''";

    CloseSegmentation(ad, image);
    
    // compare to ground truth data if gt data is given:
    if (compareresults) {
      CompareShotBoundaryResultsSBD(gtresult, boundaries, segsrc, 
                                    total_true_positives,
                                    total_sbd_boundaries, total_gt_boundaries,
                                    gd_total_true_positives,
                                    gd_total_sbd_boundaries, 
                                    gd_total_gt_boundaries);
    }
  }

  if (compareresults) {
    double recall = total_gt_boundaries != 0 ? 
      (double)total_true_positives/(double)total_gt_boundaries : 0.0;
    double precision = total_sbd_boundaries != 0 ?
      (double)total_true_positives/(double)total_sbd_boundaries : 0.0;
    double gd_recall = gd_total_gt_boundaries != 0 ? 
      (double)gd_total_true_positives/(double)gd_total_gt_boundaries : 0.0;
    double gd_precision = gd_total_sbd_boundaries != 0 ?
      (double)gd_total_true_positives/(double)gd_total_sbd_boundaries : 0.0;

    cout << "Total precision and recall: " << precision 
         << ", " << recall << endl;
    cout << "Total gradual precision and recall: " << gd_precision 
         << ", " << gd_recall << endl;
  }

  if (trecvid != "") {
    string xmlname = trecvid+".xml"; 
    doc.Write(xmlname, true);
  }
  doc.DeleteDoc();
  
  return true;
}

///////////////////////////////////////////////////////////////////////////////

  bool Analysis::OpenAddDescription(AddDescription* &ad,
                                    segmentfile* &image,
                                    const string& opath,
				    const string& sname,
				    const string& lname) const {
    string msg = "Analysis::OpenAddDescription() : ";

    if (verbose)
      cout << msg << "running Segmentation::CreateMethod(\"ad\");" << endl;

    ad = (AddDescription*)Segmentation::CreateMethod("ad");
    if (!ad)
      return false;

    image = new segmentfile();
    image->setFirstInChain(ad);
    ad->setStorage(image);

    if (sname!="" && lname!="")
      ad->SetMethodName(sname, lname);

    if (verbose)
      cout << msg << "generating segmentation file: " << opath << endl;

    image->openFiles(""); // open an empty file to generate global 
                          // segmentation description without reading the 
                          // video data
    if (opath!="")
      image->outSegmentName(opath.c_str());

    ad->SetFileNames();

    // cout << msg << "num.frames=" << image->getNumFrames() << endl;
    // image->Description().sequenceinfo.lastframe = 123;
    // cout << msg << "num.frames=" << image->getNumFrames() << endl;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::CloseSegmentation(Segmentation *ad,
                                   segmentfile *image) const {
    string msg = "Analysis::CloseSegmentation() : ";

    ad->ProcessGlobal();
    if (image) {
      int framestep = 24; // obs!
      for (int f=0; f<image->getNumFrames(); f+=framestep) {
	image->setCurrentFrame(f);
	if (verbose)
	  cout << msg << "f=" << f << " curr.frame="
	       << image->getCurrentFrame() << endl;

	image->tagFrameAsProcessed(ad, image->getCurrentFrame());
	ad->Process();

	/*
	set<int> mset;
	mset.insert(0);
	image->Description().processedFrames[f] = mset;
	*/
      }
    }

    ad->CloseFiles();
    ad->setStorage(NULL);
    delete image;
    
    return true;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result 
Analysis::AnalyseShotBoundaryParams(const vector<string>& 
                                    /*argv*/) { 

  ground_truth select;
  XmlDom gtresult;

  AnalyseShotBoundaryInit("Analysis::AnalyseShotBoundaryParams : "
                          "Starting with parameters", select, gtresult);

  vector< vector<float> > paramtmp;
  vector<float> ptmp;
  map<string,pair<double,double> > resultmap;

  // initial settings:
  ptmp.clear();
  ptmp.push_back(sbdparams.votepercent); // votepercent 
  ptmp.push_back((float)sbdparams.framegap); // framegap
  ptmp.push_back((float)sbdparams.mindist); // mindist
  ptmp.push_back((float)sbdparams.nframes); // nframes 
  ptmp.push_back((float)sbdparams.nframes_next); // nframes_next 
  for (size_t i=0; i<Nindices(); i++) {
    ptmp.push_back(sbdparams.boundaryexp[i]); // boundaryexp
    ptmp.push_back(sbdparams.feature_weight[i]); // boundaryexp
  }
  paramtmp.push_back(ptmp);


  bool compareresults = gtresult.node 
    && gtresult.NodeName() == "shotBoundaryResult";

  // the list of trajectories for all the objects (cached for speed)
  map<size_t, vector<vector<IntPoint> > > trajectorycache;


  while(paramtmp.size()) {
    cout << "Calculating SBD results with " << paramtmp.size() 
         << " sets of parameters" << endl;

    for (size_t parami=0; parami < paramtmp.size(); parami++) {
      sbdparams.votepercent = paramtmp[parami][0];
      sbdparams.framegap = (int) paramtmp[parami][1];
      sbdparams.mindist = (int) paramtmp[parami][2];
      sbdparams.nframes = (int) paramtmp[parami][3];
      sbdparams.nframes_next = (int) paramtmp[parami][4];
      for (size_t mi=0; mi<Nindices(); mi++) {
        sbdparams.boundaryexp[mi] = paramtmp[parami][5+mi*2];
        sbdparams.feature_weight[mi] = paramtmp[parami][6+mi*2];
      }
      
      cout << "Analysis::AnalyseShotBoundary : Using parameters votepercent="
           << sbdparams.votepercent 
           << " framegap=" << sbdparams.framegap
           << " mindist=" << sbdparams.mindist 
           << " nframes=" << sbdparams.nframes
           << " nframes_next=" << sbdparams.nframes_next
           << endl;
      for (size_t mi=0; mi<Nindices(); mi++) 
        cout << "--> Params for map " << TsSom(mi).Name() 
             << ": boundaryexp=" << sbdparams.boundaryexp[mi] 
             << " feature_weight=" << sbdparams.feature_weight[mi] 
             << endl;

      size_t total_true_positives = 0, total_sbd_boundaries = 0, 
        total_gt_boundaries = 0, gd_total_true_positives = 0, 
        gd_total_sbd_boundaries = 0, gd_total_gt_boundaries = 0;
        
      // for each object..
      for (size_t k=0; ; k++) {
        if (k==GetDataBase()->Size())
          break;
        
        // class restrictions etc:
        if (select.Length() && select[k]!=1)
          continue;
        
        //vector<vector<IntPoint> > trajectory;
        if (trajectorycache.find(k) == trajectorycache.end()) {
          vector<vector<IntPoint> > trajectory = SolveSubObjectTrajectories(k);
          trajectorycache[k] = trajectory;
        }
        
        vector<pair<size_t,size_t> > boundaries 
          = SolveShotBoundaries(trajectorycache[k]);
        
        string segsrc = Label(k);
        
        // compare to ground truth data if gt data is given:
        if (compareresults) {
          CompareShotBoundaryResultsSBD(gtresult, boundaries, segsrc, 
                                        total_true_positives,
                                        total_sbd_boundaries, 
                                        total_gt_boundaries,
                                        gd_total_true_positives,
                                        gd_total_sbd_boundaries, 
                                        gd_total_gt_boundaries);
        }
      }
    
      CompareShotBoundaryResultsSBDP(total_true_positives,
                                     total_sbd_boundaries, total_gt_boundaries,
                                     gd_total_true_positives,
                                     gd_total_sbd_boundaries, 
                                     gd_total_gt_boundaries, resultmap);
      
    }

    paramtmp.clear();
    GetNewShotBoundaryParams(resultmap, paramtmp);

  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::GetNewShotBoundaryParams(map<string,pair<double,double> >
                                        &resultmap, 
                                        vector< vector<float> > &paramtmp) {
  
  vector<float> ptmp;
  
  // find the best pr-parameters:
  double bestvalue=0.0;
  double bestp=0.0,bestr=0.0;
  string bestparams = "";
  for(map<string,pair<double,double> >::iterator i=resultmap.begin();
      i!=resultmap.end(); i++) {
    double f1value = HarmonicMean(i->second.first, i->second.second, 
                                  sbdparams.precision_weight);
    if(f1value>=bestvalue) {
      bestvalue = f1value;
      bestp = i->second.first;
      bestr = i->second.second;
      bestparams = i->first;
    }
  }
  cout << "Best parameters so far: "<< bestparams <<" with weighted "
       << "(gradual weight=" << sbdparams.gradualoptpercent << ") precision "
       << bestp << " and recall " << bestr << " F1=" << bestvalue 
       << endl;
  
  vector<string> baseparamstr = SplitInCommas(bestparams);
  vector<float> baseparams;
  for(size_t bpi=0; bpi<baseparamstr.size(); bpi++)
    baseparams.push_back(atof(baseparamstr[bpi].c_str()));

  // global options:
  for (int i=0; i<5; i++) {
    ptmp = baseparams;
    ptmp[i] = ptmp[i]-sbdparams.stepsize[i];
    if(!SBDHasBeenComputed(resultmap,ptmp))
      paramtmp.push_back(ptmp);

    ptmp = baseparams;
    ptmp[i] = ptmp[i]+sbdparams.stepsize[i];
    if(!SBDHasBeenComputed(resultmap,ptmp))
      paramtmp.push_back(ptmp);
  }
  
  // map-specific options:
  for (size_t i=0; i<Nindices(); i++)
    for (int j=5; j<7; j++) {
      if(baseparams[i*2+6] <= 0.0) // weight = 0.0
        j=6; // if weight==0.0, alter only the weight value for this map

      ptmp = baseparams;
      ptmp[i*2+j] = ptmp[i*2+j]-sbdparams.stepsize[j];
      if(!SBDHasBeenComputed(resultmap,ptmp))
        paramtmp.push_back(ptmp);
  
      ptmp = baseparams;
      ptmp[i*2+j] = ptmp[i*2+j]+sbdparams.stepsize[j];
      if(j==6 && ptmp[i*2+j] > 10.0)
        ptmp[i*2+j] = 10.0; // maximum weight 10.0
      if(!SBDHasBeenComputed(resultmap,ptmp))
        paramtmp.push_back(ptmp);
    }

  // ensure that parameters are non-negative:
  /*  for (size_t i=0; i<paramtmp.size(); i++)
    for (size_t j=0; j<paramtmp[i].size(); j++)
      if (paramtmp[i][j] < 0.0)
      paramtmp[i][j] = 0.0; */

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::SBDHasBeenComputed(map<string,pair<double,double> >& resultmap,
                                  vector<float>& params) {
  // ensure that parameters are non-negative:
  for (size_t j=0; j<params.size(); j++)
    if (params[j] < 0.0)
      params[j] = 0.0;

  string tmpstr = SBDParamString(params);
  return resultmap.find(tmpstr)!=resultmap.end();
}

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSomValues(const vector<string>&
						      argv) {
    size_t argc = argv.size();

    ReadFiles();

    for (size_t m=0; m<Nindices(); m++) {
      TSSOM& tssom = TsSom(m);
      if (!tssom.Nlevels())
	continue;

      tssom.ReadMapFile();
      const SOM& som = tssom.Map(tssom.Nlevels()-1);

      const vector<simple::VectorComponent>&
	comp = tssom.ComponentDescriptions();

      for (int i=0; i<som.VectorLength(); i++) {
	if (argc && atoi(argv[0].c_str())!=i)
	  continue;

	string compname = "component";
	if (comp.size()>(size_t)i)
	  compname = comp[i].name;

	float min = numeric_limits<float>::max(), max = -min;
	simple::FloatMatrix mtx(som.Height(), som.Width());
	for (int y=0; y<som.Height(); y++)
	  for (int x=0; x<som.Width(); x++) {
	    float v = som.Unit(x, y)->Get(i);
	    if (v>max)
	      max = v;
	    if (v<min)
	      min = v;
	    mtx.Set(y, x, som.Unit(x, y)->Get(i));
	  }

	cout << tssom.MapName(true) << " component=" << i
	     << " " << mtx.Rows() << "x" << mtx.Columns()
	     << " min=" << min << " max=" << max << endl;

	IntMatrix *hbar = NULL, *vbar = NULL;
	imagedata img = query->BlueWhiteRedMap(mtx, NULL, NULL,
					       hbar, vbar, magnify, NULL);

	bool dpy = false;
	string name = ResultName(dpy, m, i, -1, compname);

	DisplayOrWrite(img, dpy, name, "image/png", "AnalyseSomValues");
      }
    }

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseDivOld(const vector<string>& argv) {
  size_t argc = argv.size();

  ground_truth select;
  if (classname!="") {
    select = GroundTruthExpression(classname, query->Target(), -1, expand);
    int npos = select.NumberOfEqual(1), nzero = select.NumberOfEqual(0);
    char tmps[100];
    sprintf(tmps, "%d/%d", npos, (int)DataBaseSize()-nzero);
    WriteLog("AnalyseDivOld: class=<", classname, "> has ",
             tmps, " items");

    if (!npos && classname!="*")
      return ShowError("only class=* should be used for empty classes");
  }

  ReadFiles();

  CreateIndexData(false);

  int npoints = 0;

  for (size_t i=0; i<Nindices(); i++)
    for (int j=0; j<IndexNlevels(i); j++) {
      if (level>=0 && j!=level)
        continue;

      TreeSOM& ts = Map(i, j);

      int kkkk = 0;
      // removed 24.10.2005 CreateMatrices(i, j, kkkk);
      simple::FloatMatrix& img = Hits(i, j, kkkk);
      img.Size(ts.Height(), ts.Width());

      for (size_t k=0; ; k++) {
        int idx = -1;
        string lab;

        if (argc) {
          if (k==argc)
            break;

          lab = argv[k];
          idx = LabelIndex(argv[k]);

        } else {

          if (k==GetDataBase()->Size())
            break;
          
          if (select.Length() && select[k]!=1)
            continue;

          idx = k;
          lab = Label(idx);
        } 

        const IntVector& divvec = TsSom(i).Division(j, 0);

        if (!divvec.IndexOK(idx)) {
          ShowError("AnalyseDivOld() idx=", ToStr(idx), " illegal");
          continue;
        }

        int u = divvec[idx];

        AddToPoint(img, u, ts, lab, idx, IndexFullName(i), j);
        npoints++;

        if (true /*query->UseSubObjects()*/) {
          const vector<int>& sub = GetDataBase()->SubObjects(idx);
          for (size_t subi=0; subi<sub.size(); subi++) {
            idx = sub[subi];
            string labp = GetDataBase()->Label(idx);
            u = divvec[idx];
            AddToPoint(img, u, ts, labp, idx, IndexFullName(i), j);
          }
        }
      }

      if (imagefilename.length()) {
        char xtra[100] = "";
        if (convolved) {
          strcat(xtra, "-convolved");
          query->Convolve(i, j, kkkk);
          img = Convolved(i, j, kkkk);
        }

        double h = img.Entropy();
        simple::FloatMatrix em(ts.Height(), ts.Width());
        em.Set(0, 0, 1);
        // double hmin = em.Entropy();
        em.Zero().Add(1);
        double hmax = em.Entropy();

        simple::FloatMatrix imgout(img);

        if (logarithm) {
          strcat(xtra, "-logarithm");
          imgout = Logarithmize(img);
        }
        
        SOM *som = NULL;
        if (threshold>0 && ts.HasRawUmatrix()) {
          som = &ts;
          som->CalculateUnitMeanUmatrix();
        }

        MakeImage(i, j, -1, xtra, classname, "BlueWhiteRedMap",
                  "AnalyseDivOld:",
                  imgout, som, &SOM::UnitMeanUmatrix, threshold);

        char entropytxt[1000];
        sprintf(entropytxt, "%s entropy of %s on %s[%d] is %g (max. %g)",
                convolved?"convolved":"", classname.c_str(),
                TsSom(i).Name().c_str(), j, h, hmax);
        WriteLog("AnalyseDivOld: ", entropytxt);
      }
    }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

void Analysis::AddToPoint(simple::FloatMatrix& img, int u, const TreeSOM& ts,
                                  const string& lab, int idx, const string& n,
                                  int j) const {
  IntPoint p = ts.ToPoint(u);

  char pstr[100] = "";
  if (u!=-1) {
    sprintf(pstr, " (%d,%d)", p.X(), p.Y());
    img.Add(p.Y(), p.X(), 1);
  }

  if (verbose>1)
    cout << "label=" << lab << "  index=" << idx << "  "
         << n << "[" << j << "] -> " << u << pstr << endl;

}

///////////////////////////////////////////////////////////////////////////////

vector<vector<IntPoint> > Analysis::SolveSubObjectTrajectoriesDiv(int objidx) {

  vector<vector<IntPoint> > trajectory(Nindices(), vector<IntPoint>());
  vector<bool> valuesexist(Nindices(), false);

  for (size_t i=0; i<Nindices(); i++) {
    // utilise bottommost level if level not specified:
    int maplevel = level >= 0 ? level : TsSom(i).Nlevels()-1;
    if (maplevel >= (int)TsSom(i).Nlevels())
      continue;

    TreeSOM& ts = Map(i, maplevel);

    const IntVector& divvec = TsSom(i).Division(maplevel, 0);

    if (!divvec.IndexOK(objidx)) {
      ShowError("SolveSubObjectTrajectories() idx=", ToStr(objidx)," illegal");
      continue;
    }

    if (true /*query->UseSubObjects()*/) {
      const vector<int>& sub = GetDataBase()->SubObjects(objidx);
      string sgmeth,imgname,frame,sg;
      trajectory[i].resize(sub.size(), IntPoint());
      for (size_t subi=0; subi<sub.size(); subi++) {
        int idx = sub[subi];
        int u = divvec[idx];
        if (u!=-1) {
          IntPoint p = ts.ToPoint(u);
          const string sublab = GetDataBase()->Label(idx);
          /*cout << "Trajectory: Subobject " << subi << " with label " << sublab
            << ": Point(" << idx << ","
            << TsSom(i).Name() << ") = " << p.X() << ", " << p.Y()
            << endl;*/

          GetDataBase()->SplitLabel(sublab,sgmeth,imgname,frame,sg);
          size_t framenum = atol(frame.c_str());
          trajectory[i][framenum] = p;

          if(!valuesexist[i])
            valuesexist[i] = true;

        } else {
          const string sublab = GetDataBase()->Label(idx);
          cout << "Point(" << sublab << "," << idx << "," << u << ","
               << TsSom(i).Name() << "): not found" << endl;
        }
      }
      /*cout << trajectory[i].size() << " points in trajectory "<< i << endl;
        for(size_t ti = 0; ti < trajectory[i].size(); ti++) {
        cout << "Point " << i << "," << ti << ": " << trajectory[i][ti].X()
        << "," << trajectory[i][ti].Y() << endl;
        }*/
    }
  }

  // remove the empty feature map trajectories:
  for (size_t i=(size_t)Nindices()-1; i>0; i--)
//  for (size_t i=0; i<valuesexist.size(); i++)
    if (!valuesexist[i]) {
      cout << "Removing empty trajectory " << i << endl;
      valuesexist.erase(valuesexist.begin()+i);
      trajectory.erase(trajectory.begin()+i);
      //i--;
    }

  return trajectory;
}


///////////////////////////////////////////////////////////////////////////////

vector<vector<IntPoint> > Analysis::SolveSubObjectTrajectories(int objidx) {

  // if possible, solve trajectory using the fast method of reading 
  // data from map div files:
  vector<vector<IntPoint> > traj = SolveSubObjectTrajectoriesDiv(objidx);
  if(traj.size() == (size_t) Nindices())
    return traj;

  // otherwise, do a BMU search:
  vector<vector<IntPoint> > trajectory(Nindices(), vector<IntPoint>());
  vector<bool> valuesexist(Nindices(), false);

  size_t subobjcount = GetDataBase()->SubObjects(objidx).size();

  for (size_t i=0; i<Nindices(); i++) {
    // utilise bottommost level if level not specified:
    int maplevel = level >= 0 ? level : TsSom(i).Nlevels()-1;
    if (maplevel >= IndexNlevels(i))
      continue;

    trajectory[i].resize(subobjcount, IntPoint());


    TreeSOM& ts = Map(i, 0);
    //TreeSOM* ts = Map(i,0).Root();


    const string& label = Label(objidx);
    bool gzip=false;
    string in = TsSom(i).CalculatedFeaturePath(label, false, false), in1 = in;
    if (! /*TsSom(i).*/ FileExists(in)) {
      in = TsSom(i).CalculatedFeaturePath(label, false, false, true); // try with gzip
      if (!FileExists(in)) {
         in = TsSom(i).CalculatedFeaturePath(label, false, true);
        if (!FileExists(in)) {
          in = TsSom(i).CalculatedFeaturePath(label, false, true, true); // try with gzip
          if (FileExists(in)) gzip=true;
        }
      } else gzip=true;
    }

    if (! /*TsSom(i).*/ FileExists(in)) {
      ShowError("Could not find features file: "+in1);
      continue;
    }

    cout << "Reading features from file " << in << endl;
    FloatVectorSet set(in.c_str(),gzip);
    if (!set.Nitems())
      continue;

    cout << "Calculating trajectory coordinates for " << set.Nitems()
         << " vectors" << endl;
    string sgmeth,imgname,frame,sg;
    bool ok = true;
    for (int k=0; ok && k<set.Nitems(); k++) {
      FloatVector& vec = set[k];

      int idx = vec.Label() ? LabelIndex(vec.Label()) : -1;

      if (idx<0)
        continue;

      GetDataBase()->SplitLabel(vec.Label(),sgmeth,imgname,frame,sg);
      if(label!=imgname)
        continue;

      IntVector bmu = ts.FindBestMatches(vec,false);
      IntPoint p = Map(i,maplevel).ToPoint(bmu[maplevel]);
      size_t framenum = atol(frame.c_str());
      trajectory[i][framenum] = p;

      /*cout << "Point " << framenum << " of map " << i <<": " << p.X()
        << "," << p.Y() << endl;*/

      if(!valuesexist[i])
        valuesexist[i] = true;

      // update division information:
      TsSom(i).SetDivision(idx,bmu);
    }

    cout << "done" << endl;

      /*cout << trajectory[i].size() << " points in trajectory "<< i << endl;
        for(size_t ti = 0; ti < trajectory[i].size(); ti++) {
        cout << "Point " << i << "," << ti << ": " << trajectory[i][ti].X()
        << "," << trajectory[i][ti].Y() << endl;
        }*/
  }

  for (size_t i=(size_t)Nindices()-1; i>0; i--)
  //for (size_t i=0; i<(size_t)Nindices(); i++)
    if (!valuesexist[i]) { // if we could not calculate any bmu coordinates:
      // remove the empty feature map trajectories
      cout << "Removing empty trajectory " << i << endl;
      valuesexist.erase(valuesexist.begin()+i);
      trajectory.erase(trajectory.begin()+i);
      //i--;
    } else {
      // write updated division information
      cout << "Rewriting division file for map " << i << endl;
      bool cwd = false;
      TsSom(i).ReWriteDivisionFile(cwd, zipped);
    }

  return trajectory;
}

///////////////////////////////////////////////////////////////////////////////

vector<pair<size_t,size_t> > 
Analysis::SolveShotBoundaries(vector<vector<IntPoint> >& trajectories) {
  //cout << "In Analysis::SolveShotBoundaries" << endl;

  vector<pair<size_t,size_t> > sbounds;

  vector<vector<pair<size_t,size_t> > > tbounds;
  size_t framecount = 0;
  size_t framegap = sbdparams.framegap; 

  // solve the boundaries according to each separate feature:
  for (size_t i=0; i<(unsigned)trajectories.size(); i++) {
    tbounds.push_back(SolveTrajectoryBoundaries(trajectories[i],i));
    if (framecount < trajectories[i].size())
      framecount = trajectories[i].size();
  }

  float weight_sum = 0.0;
  for(size_t i=0; i<sbdparams.feature_weight.size(); i++)
    weight_sum += sbdparams.feature_weight[i];

  // combine (by voting) the boundaries
  for (size_t i=0; i<framecount; i++) {
    size_t length = 0;
    //float minp=1,maxp=0,p;
    while ((/*p=*/InShotBoundaryTransition(tbounds, i+length, weight_sum)) 
           >= sbdparams.votepercent 
           && i+length<framecount) {
      //if(p<minp) minp=p;
      //if(p>maxp) maxp=p;
      length++;
    }
    

    if (length>0) {
      /*cout << "Frame " << i << ": in transition for " << length 
           << " frames with minp=" << minp << ", maxp="<<maxp 
           << ", tbounds.size()=" << tbounds.size() << endl;*/
      size_t true_length = length >= framegap ? length-framegap : 0;
      sbounds.push_back(pair<size_t,size_t>(i,true_length));
      i += length;
    }
  }
  
  return CombineBoundaries(sbounds);
}

///////////////////////////////////////////////////////////////////////////////

float 
Analysis::InShotBoundaryTransition(vector<vector<pair<size_t,size_t> > >& b,
                                   size_t framenum, float weight_sum) {
  //cout << "In Analysis::IsShotBoundaryTransition" << endl;

  if (weight_sum<=0.0)
    return 0.0;

  float votecount = 0.0;
  for (size_t i=0; i<b.size(); i++) {
    if(sbdparams.feature_weight[i] <= 0.0)
      continue;
    for (size_t j=0; j<b[i].size(); j++) 
      if (framenum >= b[i][j].first && 
          framenum <= b[i][j].first+b[i][j].second) {
        votecount += sbdparams.feature_weight[i];
        break; // break from the inner loop
      }
  }
  //cout << "Votecount for frame " << framenum << ": " << votecount << endl;
  return (float)votecount/weight_sum;
}

///////////////////////////////////////////////////////////////////////////////

vector<pair<size_t,size_t> > 
Analysis::SolveTrajectoryBoundaries(vector<IntPoint>& trajectory, size_t idx) {
  //cout << "In Analysis::SolveTrajectoryBoundaries" << endl;

  vector<pair<size_t,size_t> > tbounds;

  if(sbdparams.feature_weight[idx] <= 0.0)
    return tbounds;

  size_t nframes = sbdparams.nframes; 
  size_t nframes_n = sbdparams.nframes_next; 
  size_t framegap = sbdparams.framegap;

  // check if the area spanned by the trajectory of the previous n fames
  // overlaps the area spanned by the trajectory of the next n frames
  for (size_t i=nframes+framegap; i<trajectory.size()-nframes_n; i++) {
    size_t length=0;
    while(!TrajectorySpannedAreasOverlap(trajectory,i+length-nframes-framegap,
                                         i+length-framegap,
                                         i+length, i+length+nframes_n, idx) 
          && i+length < trajectory.size()) 
      length++;
    if (length>0) {
      //size_t true_length = length >= framegap ? length-framegap : 0;
      //tbounds.push_back(pair<size_t,size_t>(i,true_length));
      tbounds.push_back(pair<size_t,size_t>(i,length));
      i += length;
    }
  }

  return CombineBoundaries(tbounds);
}

///////////////////////////////////////////////////////////////////////////////

vector<pair<size_t,size_t> > 
Analysis::CombineBoundaries(vector<pair<size_t,size_t> >& bounds) {
  //cout << "In Analysis::CombineBoundaries" << endl;
  vector<pair<size_t,size_t> > newbounds;

  size_t mindist = sbdparams.mindist; 

  for (size_t i=0; i<bounds.size(); i++) {
    size_t start = bounds[i].first;
    size_t end = start+bounds[i].second;
    while (i+1 < bounds.size() && bounds[i+1].first-end < mindist) {
      i++;
      end = bounds[i].first+bounds[i].second;
    }
    newbounds.push_back(pair<size_t,size_t>(start,end-start));
  }

  return newbounds;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::TrajectorySpannedAreasOverlap(vector<IntPoint>& trajectory,
                                             size_t b1, size_t e1, 
                                             size_t b2, size_t e2,
                                             size_t idx) {

  //cout << "In Analysis::TrajectorySpannedAreasOverlap" << endl;

  // avoid using sqrt function by comparing the squares of distances:
  float boundaryexpsq = 
    4.0*sbdparams.boundaryexp[idx]*sbdparams.boundaryexp[idx];

  if (e1 >= trajectory.size())
    e1 = trajectory.size()-1;
  if (e2 >= trajectory.size())
    e2 = trajectory.size()-1;

  for (size_t i=b1; i<=e1; i++) {
    IntPoint p1 = trajectory[i];
    for (size_t j=b2; j<=e2; j++) {
      IntPoint p2 = trajectory[j];

      // if some points in the two trajectories are close enough, return true:
      if ( (p1.X()-p2.X())*(p1.X()-p2.X()) + 
           (p1.Y()-p2.Y())*(p1.Y()-p2.Y()) < boundaryexpsq)
        return true;
    }
  }
  return false; // false if none of the points overlap
}

/*bool Analysis::TrajectorySpannedAreasOverlap(vector<IntPoint>& trajectory,
                                             size_t b1, size_t e1, 
                                             size_t b2, size_t e2) {

  //cout << "In Analysis::TrajectorySpannedAreasOverlap" << endl;

  float boundaryexp = sbdparams.boundaryexp;

  FloatPoint c1 = TrajectoryAvgPoint(trajectory, b1, e1);
  FloatPoint c2 = TrajectoryAvgPoint(trajectory, b2, e2);
  float r1 = TrajectoryMaxDistance(trajectory, b1, e1, c1);
  float r2 = TrajectoryMaxDistance(trajectory, b2, e2, c2);

  return sqrt( (c1.X()-c2.X())*(c1.X()-c2.X()) + 
               (c1.Y()-c2.Y())*(c1.Y()-c2.Y()) ) < r1 + r2 + 2.0*boundaryexp;
}*/

///////////////////////////////////////////////////////////////////////////////

FloatPoint Analysis::TrajectoryAvgPoint(vector<IntPoint>& trajectory,
                                        size_t b, size_t e) {
  float x=0,y=0;
  size_t n=0;
  for (size_t i=b; i <= e && i < trajectory.size(); i++) {
    x += (float) trajectory[i].X();
    y += (float) trajectory[i].Y();
    n++;
  }
  if(n>0) {
    x /= (float)n;
    y /= (float)n;
  }
  return FloatPoint(x,y);
}

///////////////////////////////////////////////////////////////////////////////

float Analysis::TrajectoryMaxDistance(vector<IntPoint>& trajectory,
                                      size_t b, size_t e, FloatPoint p) {
  float maxdist2 = -1;
  for (size_t i=b; i <= e && i < trajectory.size(); i++) {
    // distance^2:
    float dist2 = 
      ((float)trajectory[i].X()-p.X())*((float)trajectory[i].X()-p.X()) +
      ((float)trajectory[i].Y()-p.Y())*((float)trajectory[i].Y()-p.Y());
    if (dist2 > maxdist2)
      maxdist2 = dist2;
  }
  return sqrt(maxdist2);
}

///////////////////////////////////////////////////////////////////////////////

// notice: this function destroys most of the boundary list during processing,
// so a copy should be given if the list is still needed afterwards
void
Analysis::CompareShotBoundaryResults(vector<pair<size_t,size_t> >& boundaries,
                                     XmlDom& gt, 
                                     size_t& ab_true_positives,
                                     size_t& ab_gt_boundaries, 
                                     size_t& ab_detected_boundaries, 
                                     size_t& gd_true_positives,
                                     size_t& gd_gt_boundaries, 
                                     size_t& gd_detected_boundaries) {
  //cout << "In Analysis::CompareShotBoundaryResults" << endl;

  // in last year's trecvid the transition borders were expanded by 5 frames
  // to both directions, and the boundary was marked as found if there was
  // even one overlapping frame in the ground truth boundary and the found
  // boundary
  const size_t allowed_frame_difference = 5;

  // Also all transitions that are less than 5 frames long are treated as
  // abrupt cuts (ab) and longer transitions as gradual transitions (gd).

  ab_true_positives = gd_true_positives = 0;
  ab_gt_boundaries = gd_gt_boundaries = 0;
  ab_detected_boundaries = gd_detected_boundaries = 0;
  for(vector<pair<size_t,size_t> >::iterator i=boundaries.begin(); 
      i!=boundaries.end(); i++) 
    if (i->second > 5)
      gd_detected_boundaries++;
    else
      ab_detected_boundaries++;


  XmlDom gttrans = gt.FirstChild();
  while(gttrans.node) {
    if (gttrans.IsElement() && gttrans.NodeName()=="trans") {
      int preFNum = atol(gttrans.Property("preFNum").c_str());
      int postFNum = atol(gttrans.Property("postFNum").c_str());
      //bool isgradual = gttrans.Property("type")=="grad";
      bool gtisgradual = postFNum-preFNum > 5; // reference: trecvid guidelines
      // bool found = false;
      int mindist = 99999999; // impossibly large distance

      if (gtisgradual)
        gd_gt_boundaries++;
      else
        ab_gt_boundaries++;

      //cout << preFNum << " " << postFNum << " " << isgradual << endl;

      for(vector<pair<size_t,size_t> >::iterator i=boundaries.begin(); 
          i!=boundaries.end(); i++) {        
        // if overlaps, remove the boundary element from the list, and
        // increment the true_positives counter
        int testpref = i->first-allowed_frame_difference;
        int testpostf = i->first+i->second+allowed_frame_difference;
        bool testisgradual = i->second > 5;
        /*cout << "Testing if " << testpref << ".." << testpostf 
          << " matches with " << preFNum << ".." << postFNum << endl;*/
        if (((preFNum >= testpref
              && preFNum <= testpostf)
             || (postFNum >= testpref 
                 && postFNum <= testpostf)
             || (preFNum <= testpref &&
                 postFNum >= testpostf)) 
            && testisgradual == gtisgradual) {
          /*cout << "Match for GT " << preFNum << "..." << postFNum 
                   << " : " << i->first << "..." << i->first+i->second << endl;*/
          i = boundaries.erase(i)-1; // ei tarpeellinen breakin takia?

          if (testisgradual)
            gd_true_positives++;
          else
            ab_true_positives++;

          // found = true;
          break;
          // perhaps we should also check the type of the transition?
        } else {
          // lasketaan  min-distance, ja katsotaan, miten lahelle osuttiin
          int dist1 = abs((int)(preFNum-i->first+i->second));
          int dist2 = abs((int)(postFNum-i->first));
          int dist = dist1 < dist2 ? dist1 : dist2;
          if (dist < mindist) mindist = dist;
        }
      }
      /*    if (!found)
        cout << "No match for GT " << preFNum << "..." << postFNum 
        << ", mindist=" << mindist << endl;*/
    }
    gttrans = gttrans.Next();
  }
}

///////////////////////////////////////////////////////////////////////////////

simple::FloatMatrix Analysis::Logarithmize(const simple::FloatMatrix& in) {
  simple::FloatMatrix out(in);

  for (int i=0; i<in.Columns(); i++)
    out.GetColumn(i)->Add(1).SetLog();

  return out;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseSpread(const vector<string>& argv) {
  WriteLog("AnalyseSpread");
  int argc = argv.size();

  for (size_t i=0; i<Nindices(); i++) {
    cout << IndexFullName(i) << " " << TsSom(i).VectorLength()
         << " " << TsSom(i).DataSetSize() << endl; // was: Fragile
    
    FloatVector mean, val;
    simple::FloatMatrix cova = TsSom(i).Data().AutoCov(&mean);
    simple::FloatMatrix eig = cova.EigenVectors(&val, 2);
    val.Lengthen(2);
    while (eig.Columns()>2)
      eig.RemoveColumn(eig.Columns()-1);

    simple::SubSpace ss(eig, val, mean);
    FloatVectorSet coeff = ss.Coefficients(TsSom(i).Data(), &mean);
    FloatVector min = coeff.MinimumComponents();
    FloatVector max = coeff.MaximumComponents();
//     max.Append(min*-1);
    FloatVector diff = max-min, mid = (max+min)/2;
    float mx = diff.Maximum();
    
    float x0 = 4200-mid[0]*6000/mx;
    float y0 = 4200+mid[1]*6000/mx;

    char selected[1000] = "";
    for (int kk=0; kk<argc; kk++) 
      if (argv[kk]!="*")
        sprintf(selected+strlen(selected), "-%s", argv[kk].c_str());

    const char *dpn = DataBaseName().c_str();
    char fname[2000];
    sprintf(fname, "%s-%s%s.fig", dpn, TsSom(i).Name().c_str(), selected);
    cout << "  " << fname << endl;

    char figtxt1[1000], figtxt2[1000];
    sprintf(figtxt1, "Database: %s", dpn);
    sprintf(figtxt2, "Feature:  %s", TsSom(i).Name().c_str());

    simple::FigFile fig(fname);
    fig.WriteHeader();
    fig.Depth(101).Box(1200,-1200, 7200, -7200).Depth(100);
    fig.Depth(99).FontSize(20).LeftText(1200, -7500, figtxt1);
    fig.LeftText(1200, -7850, figtxt2).Depth(100);
    fig.PushSettings().SetTransformation(x0, y0, 6000/mx);
    fig.Depth(101).Line(0, -0.1, 0, 0.1).Line(-0.1, 0, 0.1, 0).PopSettings();

    float text_y = -7500, text_dy = -250;
    const char **cnames = simple::FigFile::Colornames();
    for (int j=0; cnames[j]; j++) {
      const char *cls = NULL; // GetKeyValue(cnames[j]);
      if (!cls)
        continue;

      bool found = false;
      for (int k=0; k<argc && !found; k++)
        if (argv[k]==cls)
          found = true;
      if (!found && argc)
        continue;

      ground_truth sel = GroundTruthExpression(cls, query->Target(), -1,
                                               expand);
      int npos = sel.NumberOfEqual(1);
      int nzer = sel.NumberOfEqual(0);
      int nmin = sel.NumberOfEqual(-1);
      cout << "    " << cnames[j] << "  \t" << cls << "\t"
           << npos << "  \t" << nzer << "  \t" << nmin << endl;

      //gt IntVector onesx = sel.EqualsXXYY(1);
      //gt FloatVectorSet subset = coeff.SubsetByIndex(onesx.NonZeroIndices());
      FloatVectorSet subset = coeff.SubsetByIndex(sel.indices(1));

      fig.BeginCompound();
      fig.SetTransformation(x0, y0, 6000/mx).CapStyle("Round");
      fig.Thickness(5).PenColor(cnames[j]);
      fig.Depth(100).PointSet(subset);
      fig.EndCompound();
      fig.BeginCompound().SetTransformation(0, 0, 1);
      fig.Depth(99).PenColor(cnames[j]).RightText(7200, text_y, cls);
      fig.EndCompound();
      text_y += text_dy;
    }
    fig.Close();
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseVote(const vector<string>&) {
  WriteLog("AnalyseVote");
  ReadFiles();

  ground_truth_set select = SelectionList(classname);

  for (size_t i=0; i<Nindices(); i++)
    for (int j=0; j<IndexNlevels(i); j++) {
      if (level>=0 && j!=level)
        continue;

      const TreeSOM& map = Map(i, j);

      ListOf<IntMatrix> hits;
      for (size_t s=0; s<select.size(); s++) {
        hits.Append(new IntMatrix(map.Height(), map.Width()));
        IntMatrix& mat = *hits.Peek();

        for (int idx=0; idx<select[s].Length(); idx++)
          if (select[s][idx]==1) {
            int u = TsSom(i).Division(j, 0)[idx];
            IntPoint p = map.ToPoint(u);
            const string lab = Label(idx);

            if (verbose>1)
              cout << "label=" << lab << "  index=" << idx << "  "
                   << IndexFullName(i) << "[" << j << "] -> " << u
                   << " (" << p.X() << "," << p.Y() << ")" << endl;

            mat.Add(p.Y(), p.X(), 1);
          }
      }

      ConfusionMatrix cfm;

      IntMatrix voted(map.Height(), map.Width());
      for (int y=0; y<map.Height(); y++)
        for (int x=0; x<map.Width(); x++) {
          int maxidx = -1, sum = 0;
          ostringstream msg;
          msg << IndexFullName(i) << "[" << j << "] x=" << x << " y=" << y;

          bool overlap = false;
          for (size_t s=0; s<select.size(); s++) {
            msg << " " << hits[s](y, x);
            sum += hits[s](y, x);
            if (maxidx>=0 && hits[s](y, x))
              overlap = true;
            if (hits[s](y, x) && (maxidx<0||hits[s](y, x)>hits[maxidx](y, x)))
              maxidx = s;
          }

          if (verbose>1 || (verbose==1 && overlap)) {
            // char *msgstr = msg.str();
            // msgstr[msg.pcount()] = 0;
            // cout << msgstr << endl;
            // delete msgstr;
            cout << msg.str() << endl;
          }

          for (size_t ss=0; ss<select.size(); ss++)
            if (hits[ss](y, x))
              cfm.Add(select[ss].Label(), select[maxidx].Label(),
                      hits[ss](y, x));

          if (maxidx>=0 && hits[maxidx](y, x)<=sum/2)
            maxidx = -2;
          voted.Set(y, x, maxidx);
        }

      if (compress>=0 && compress<=1) {
        cfm.Compress(compress);
        cfm.Display();
      }
      cout << IndexFullName(i) << "[" << j << "] " << classname << " : ";
      cfm.DisplayAccuracy();
      cout << endl;

      if (verbose)
        voted.Dump(Simple::DumpLong);

      voted.Add(2);

      SOM *som = NULL;
      if (threshold>0 && Map(i, j).HasRawUmatrix()) {
        som = &Map(i, j);
        som->CalculateUnitMeanUmatrix();
      }

      MakeImage(i, j, -1, "", classname, "ColorIndexMap",
                "AnalyseVote:", voted,
                som, &SOM::UnitMeanUmatrix, threshold);
    }

  return true;
}

  /////////////////////////////////////////////////////////////////////////////

  ground_truth_set Analysis::SelectionList(const string&
                                           classname) const {
    ground_truth_set select = GroundTruthExpressionListOld(classname, expand);
    size_t l = select.ground_truth_size();

    for (size_t i=0; i<l; i++) {
      bool found = false;
      for (size_t s=0; s<select.size(); s++)
        if (found)
          select[s][i] = -1;
        else if (select[s][i]==1)
          found = true;
    }

    for (size_t i=0; i<select.size(); i++) {
      char counts[100];
      sprintf(counts, "%d %d %d / %d",
              (int)select[i].NumberOfEqual(1), (int)select[i].NumberOfEqual(0),
              (int)select[i].NumberOfEqual(-1), (int)l);
      WriteLog("SelectionList: class=<", select[i].Label(), "> ", counts);
    }
   
    return select;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::IsInSelectionList(const ground_truth_set& set, int idx,
                                   string& lab) const {
    for (size_t s=0; s<set.size(); s++)
      if (set[s][idx]==1) {
        lab = set[s].label();
        return true;
      }

    lab = "";

    return false;
  }

  /////////////////////////////////////////////////////////////////////////////

  string Analysis::ResultName(bool& dpy, int m, int l, int k,
                              const string& xtra) const {
    dpy = imagefilename=="" || imagefilename=="-";      
    if (dpy)
      return "";

    string name = imagefilename!="-" ? imagefilename+"-" : "";
    string dbn = DataBaseName();
    if (dbn!=".")
      name += dbn+"-";
    // name += IndexFullName(m)+"["+ToStr(l)+"]";
    name += IndexFullName(m)+"-"+ToStr(l)+"-";
    if (k>-1)
      name += string("-")+ToStr(k);

    return name+xtra;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::DisplayOrWrite(const imagedata& img, bool dpy,
                                const string& name,
                                const string& type,
                                const string& hdr) const {
    if (dpy) {
      WriteLog("Displaying image", forkdisplay?" (forking)":"");

      bool forked = forkdisplay && fork()==0;
      if (!forkdisplay || forked) {
        imagefile::displaysettings fmt;
        fmt.title = name;
        imagefile::display(img, fmt);
        if (forked)
          exit(0);
      }
      
      return true;
    }

    if (name.empty())
      return true;

    string filename = name + MIMEtypeToFileExtension(type);

    imagefile::write(img, filename);
    string htxt = hdr=="" ? "Wrote" : hdr+" wrote";
    WriteLog(htxt, " image file <", filename, ">");

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

bool Analysis::MakeImage(int mm, int ll, int kk,
                                 const string& xtra,
                                 const string& cn,
                                 const string& type,
                                 const string& hdr,
                                 const IntMatrix *imtrx,
                                 const simple::FloatMatrix *fmtrx,
                                 const SOM *som,
                                 float& (SOM::*uf)(int,int,bool) const,
                                 double th) const {
  int w = 0, h = 0;
  if (imtrx) {
    w = imtrx->Columns();
    h = imtrx->Rows();
  }
  if (fmtrx) {
    w = fmtrx->Columns();
    h = fmtrx->Rows();
  }
  if (!w || !h)
    return ShowError("Analysis::MakeImage() zero-sized matrix");

  if (kk==0 && query->GetMatrixCount(mm)==1)
    kk = -1;

  bool dpy = false;
  string xxx = xtra + (cn.length() ? string("-")+cn : string(""));
  string name = ResultName(dpy, mm, ll, kk, xxx);

  size_t p;
  while ((p = name.find('['))!=string::npos)
    name[p] = '_';
  while ((p = name.find(']'))!=string::npos)
    name.erase(p, 1);

  IntMatrix *hbar = NULL, *vbar = NULL;
  
  if (som && uf) {
    MakeUmatrixBars(som, uf, th, hbar, vbar);
    char tmp[100];
    sprintf(tmp, "-%f", th);
    name += tmp;
  }

  imagedata imgdata;

  bool ok = true;

  if (imtrx)
    imgdata = query->ColorIndexMap(*imtrx, hbar, vbar, magnify);

  else if (fmtrx) {
    const map<string,imagedata>& bg = TsSom(mm).BackGround();
    const imagedata *imgd = bg.empty() || int(TsSom(mm).Nlevels())-1!=ll ? NULL
      : &bg.rbegin()->second;
    imgdata = query->BlueWhiteRedMap(*fmtrx, NULL, NULL,
                                     hbar, vbar, magnify, imgd);

  } else
    ok = false;

  delete hbar;
  delete vbar;

  if (!ok)
    return ShowError("Analysis::MakeImage() : ", type,
                     " [", name, "] () failed");

  return DisplayOrWrite(imgdata, dpy, name, "image/png", hdr);
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::MakeUmatrixBars(const SOM *som,
                                       float& (SOM::*uf)(int,int,bool) const,
                                       double th, IntMatrix*& hbar,
                                       IntMatrix*& vbar) const {
  int w = som->Width(), h = som->Height();

  hbar = new IntMatrix(h-1, w);
  vbar = new IntMatrix(h,   w-1);
  
  if (th < 99)
    for (int x=0; x<w; x++)
      for (int y=0; y<h; y++) {
        if (x<som->Width()-1  && (som->*uf)(x, y, true)>=th)
          vbar->Set(y, x, 1); 
        if (y<som->Height()-1 && (som->*uf)(x, y, false)>=th)
          hbar->Set(y, x, 1); 
      }
  else {
    hbar->Label("graybars");
    for (int x=0; x<w; x++)
      for (int y=0; y<h; y++) {
        if (x<som->Width()-1)
          vbar->Set(y, x, int(128*(som->*uf)(x, y, true))); 
        if (y<som->Height()-1)
          hbar->Set(y, x, int(128*(som->*uf)(x, y, false))); 
    }
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseClassSim(const vector<string>&
                                                   args) {
  WriteLog("AnalyseClassSim");
  
  const string err = "AnalyseClassSim() : ";

  if (args.size()<1 || args[0].size()<3)
    return ShowError(err+"parenthesized argument missing A");

  string aa = args[0];
  if (aa[0]!='(' || aa[aa.size()-1]!=')')
    return ShowError(err+"parenthesized argument missing B");
  aa = aa.substr(1, aa.size()-2);

  vector<string> aparts = SplitInCommas(aa);

  vector<string> argv = DashedExtraArguments();

  list<string> classl = GetDataBase()->SplitClassNames(classname);
  if (classl.size()<3)
    return ShowError(err+"less than three classes");

  set<string> classes(classl.begin(), classl.end());

  //const string train = "_train", val = "_val";
  const string train = "_trainval", val = "_trainval";
  map<string,string> tra_gt, val_gt;

  typedef list<pair<string,string> > task_t;
  task_t task;

  for (set<string>::const_iterator i=classes.begin(); i!=classes.end(); i++){
    tra_gt[*i] = *i+train;
    val_gt[*i] = *i+val;
    cout << "CLASSSIM map tra_gt[" << *i << "]=" << tra_gt[*i] << endl;
    cout << "CLASSSIM map val_gt[" << *i << "]=" << val_gt[*i] << endl;

    for (set<string>::const_iterator j=i; ++j!=classes.end(); ) {
      task.push_back(make_pair(*i, *j));
      cout << "CLASSSIM task " << *i << " " << *j << endl;
    }
  }
  
  typedef multimap<float,pair<string,string> > errmat_t;
  errmat_t errmat;

  typedef map<pair<string,string>,float> simmat_t;
  simmat_t simmat;

  // const string dangerous = "&|()^!~\\";

  bool ok = true, first = true;
  size_t r = 0;
  for (;classes.size()>1;) {
    cout << "CLASSSIM round " << r << " c=" << classes.size()
	 << " t=" << task.size() << " m=" << errmat.size() << endl;

    while (task.size()) {
      string pos = task.begin()->first, neg = task.begin()->second;
      task.erase(task.begin());

      string restr = val_gt[pos]+"|"+val_gt[neg];

      script_exp_t plist = ScriptExpand(script, false);

      ok = ok &&ScriptReplace(plist, "analyse",     aparts[0],   false, false);
      ok = ok &&ScriptReplace(plist, "positive",    tra_gt[pos], true,  false);
      ok = ok &&ScriptReplace(plist, "negative",    tra_gt[neg], true,  false);
      ok = ok &&ScriptReplace(plist, "viewclass",   val_gt[pos], true,  false);
      ok = ok &&ScriptReplace(plist, "restriction", restr,       true,  false);
      if (!ok)
        return ShowError(err+"failed to modify script");

      cout << "CLASSSIM calc " << tra_gt[pos] << " " << tra_gt[neg] << " "
           << val_gt[pos] << " " << restr << endl;

      Analysis analysis(Picsom(), this, NULL, argv);
      analysis.Script(ScriptUnExpand(plist));
      analyse_result res = analysis.Analyse();
      pair<float,float> opt = OptimizeValue(res);
      errmat.insert(make_pair(opt.second, make_pair(pos, neg)));
      simmat.insert(make_pair(make_pair(pos, neg), opt.second));

      cout << "CLASSSIM dist " << pos << " " << neg << " " << opt.second << endl;
    }

    if (first) {
      ClassSimMatrix(simmat);
      first = false;
    }

    string pos  = errmat.rbegin()->second.first;
    string neg  = errmat.rbegin()->second.second;
    string comb = pos+"+"+neg;

    cout << "CLASSSIM combine #" << r++ << ": " << pos << " " << neg
         << " => " << comb << endl;

    for (errmat_t::iterator i=errmat.begin(); i!=errmat.end(); )
      if (i->second.first ==pos || i->second.first ==neg ||
          i->second.second==pos || i->second.second==neg) {
        cout << "CLASSSIM remove " << i->second.first << " " << i->second.second
             << endl;
        errmat.erase(i);
        i = errmat.begin();
      } else
        i++;

    classes.erase(pos);
    classes.erase(neg);

    for (set<string>::const_iterator i=classes.begin(); i!=classes.end(); i++){
      task.push_back(make_pair(*i, comb));
      cout << "CLASSSIM task " << *i << " " << comb << endl;
    }

    classes.insert(comb);
    tra_gt[comb] = tra_gt[pos]+"|"+tra_gt[neg];
    val_gt[comb] = val_gt[pos]+"|"+val_gt[neg];

    cout << "CLASSSIM map tra_gt[" << comb << "]=" << tra_gt[comb] << endl;
    cout << "CLASSSIM map val_gt[" << comb << "]=" << val_gt[comb] << endl;
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ClassSimMatrix(const map<pair<string,string>,float>& sm) {
  typedef map<pair<string,string>,float> sm_t;

  set<string> ss;
  for (sm_t::const_iterator i=sm.begin(); i!=sm.end(); i++) {
    ss.insert(i->first.first);
    ss.insert(i->first.second);
  }
  vector<string> s(ss.begin(), ss.end());
  size_t l = s.size(), li = 0;
  
  typedef map<string,size_t> idx_t;
  idx_t idx;
  for (vector<string>::const_iterator i=s.begin(); i!=s.end(); i++, li++)
    idx[*i] = li;

  using cox::matrix;
  matrix<float> m(l, l), w(l, l);
  for (sm_t::const_iterator i=sm.begin(); i!=sm.end(); i++)
    m(idx[i->first.first], idx[i->first.second]) =
      m(idx[i->first.second], idx[i->first.first]) = i->second;
  for (size_t i=0; i<l; i++) {
    m(i, i) = 100; // obs!
    for (size_t j=i, v=0; j<l; j++, v++)
      w(i, j) = w(j, i) = v;
  }

  cout << "CLASSSIM v-matrix" << endl;
  ClassSimMatrixShow(s, m);

  cout << "CLASSSIM w-matrix" << endl;
  ClassSimMatrixShow(s, w);

  for (size_t r=0; r<m.rows(); r++) {
    vector<float> rv = m.row(r);
    typedef multiset<float,greater<float> > rs_t;
    rs_t rs(rv.begin(), rv.end());

    for (size_t c=0; c<m.columns(); c++) {
      size_t v = 0;
      for (rs_t::const_iterator ri=rs.begin(); ri!=rs.end(); ri++, v++)
        if (m(r, c)==*ri)
          break;
      m(r, c) = v;
    }
  }

  float mv = m.element_product_sum(w);

  cout << "CLASSSIM i-matrix : " << mv << endl;
  ClassSimMatrixShow(s, m);

  for (size_t r = 0; r<l*l; r++) {
    matrix<float> o = m;
    size_t i = rand()%l, j = rand()%l;
    o.swap(i, j);
    float ov = o.element_product_sum(w);
    if (ov>mv) {
      mv = ov;
      m = o;
      string tmp = s[i];
      s[i] = s[j];
      s[j] = tmp;
    }
  }

  cout << "CLASSSIM o-matrix : " << mv << endl;
  ClassSimMatrixShow(s, m);

  return true;
}

///////////////////////////////////////////////////////////////////////////////

void Analysis::ClassSimMatrixShow(const vector<string>& s,
                                  const cox::matrix<float>& m) {
  for (size_t r=0; r<m.rows() && r<s.size(); r++) {
    cout << "CLASSSIM " << s[r];
    for (size_t c=0; c<m.columns(); c++)
      cout << " " << m(r, c);
    cout << endl;
  }
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseKnnOld(const vector<string>&) {
  bool old_way = false;

  string msg = string("AnalyseKnnOld (")+(old_way?"OLD":"NEW")+")";
  WriteLog(msg);
  msg += " : ";

  if (classifier.substr(0, 3)!="knn" || classifier.size()<4)
    return ShowError(msg+"called with classifier!~/^knn.+/");

  ReadFiles(false);

  ground_truth_set select = SelectionList(classname);
  if (!select.size()) 
    return ShowError(msg+"SelectionList() failed");

  DataBase *db = CheckDB();

  if (select.size()==1) {
    ground_truth complement = select[0].TernaryNOT();
    complement.Label("not-"+select[0].Label());
    select.insert(complement);
  }

  target_type tt = query->Target();
  ground_truth view(db->Size(), -1);
  if (query->HasViewClass())
    view = GroundTruthExpression(query->ViewClass(), tt, -1, expand);

  for (size_t i=0; i<Nindices(); i++) {
    if (!TsSom(i).SetDataSetNumbers(false, false))
      return ShowError(msg+"Setting data set numbers in <",
                       IndexFullName(i), "> failed");
    
    const FloatVectorSet& data = TsSom(i).Data();
    FloatVectorSet knnset, tstset;

    for (int j=0; j<data.Nitems(); j++) {
      int idx = data[j].Number();
      string lab;

      if (old_way) {
        if (IsInSelectionList(select, idx, lab)) {
          knnset.AppendCopy(data[j]);
          knnset.Peek()->Label(lab);
          knnset.Peek()->Number(idx);
          continue;
        }
        if (view[idx]==1) {
          tstset.AppendCopy(data[j]);
          tstset.Peek()->Label("?");
          tstset.Peek()->Number(idx);
          continue;
        }

      } else {

        if (view[idx]==1) {
          if (!IsInSelectionList(select, idx, lab))
            return ShowError(msg+"view object not in selection list");

          tstset.AppendCopy(data[j]);
          tstset.Peek()->Label(lab);
          tstset.Peek()->Number(idx);
          continue;
        }

        if (IsInSelectionList(select, idx, lab)) {
          knnset.AppendCopy(data[j]);
          knnset.Peek()->Label(lab);
          knnset.Peek()->Number(idx);
          continue;
        }
      }
    }

    TsSom(i).WriteLog(ToStr(knnset.Nitems())+" vectors used in codebook");
    if (tstset.Nitems())
      TsSom(i).WriteLog(ToStr(tstset.Nitems())+
                        " separate viewclass vectors will be classified");

    string filename(MatlabName());
    if (filename.length())
      filename += "-";
    filename += IndexFullName(i);

    if (!DataPreProcessing(knnset, filename))
      return ShowError(msg+"DataPreProcessing() failed A");

    if (!DataPreProcessing(tstset, filename))
      return ShowError(msg+"DataPreProcessing() failed B");

    string txt = filename+" : "+classname;

    string knn = classifier.substr(3);

    IntVector allk    = IntVector().ValueFromString(knn);
    IntVector rejectk = IntVector().ValueFromString(knn_reject);

    if (rejectk.Length() && allk.Length()!=rejectk.Length())
      return ShowError(msg+"lengths of allk and rejectk differ");

    if (!allk.Length()) {
      allk.Push(3);
      rejectk.Push(0);

    } else
        if (!rejectk.Length()) 
          rejectk.Length(allk.Length());

    IntVector alllen = IntVector().ValueFromString(vectorlength);
    if (!alllen.Length())
      alllen.Push(knnset.VectorLength());
    alllen.SortDecreasingly();

    IntVector lenvec, bestkvec;
    FloatVector errvec, corvec;

    string fname;
    for (int li=0; li<alllen.Length(); li++) {
      knnset.Lengthen(alllen[li]);
      tstset.Lengthen(alllen[li]);
      Classifier cfr(knnset);
      if (tstset.Nitems())
        cfr.TestingSet(&tstset);

      cfr.NoAdapt();
      cfr.DistanceComparisonInterval(distcomp);
      cfr.Silent(verbose>=1?0:1);
      cfr.PreAccuracyText(txt.c_str());
      cfr.ConfusionMatrixSorting(false);

      fname = filename;
      if (!SetMetric(cfr, fname)) // this might make _mah_mah_mah...
        return false;
        
      float minerr = 100;
      int bestk = 0;
      for (int ki=0; ki<allk.Length(); ki++) {
        cfr.DefaultK(allk[ki]);
        cfr.RejectK(rejectk[ki]);

        cfr.ClearConfusionMatrix();
        if (tstset.Nitems())
          cfr.Classify(tstset);
        else
          cfr.Classify(cfr.VectorSetPart());
        cfr.ShowResults();

        if (tstset.Nitems()) {
          map<string,int> res;

          map<int,string> cfrres = cfr.ClassificationsByNumber();
          for (map<int,string>::const_iterator ri=cfrres.begin();
               ri!=cfrres.end(); ri++) {
            // cout << ri->first << " " << ri->second << endl;
            res[ri->second]++;
          }

          for (map<string,int>::const_iterator ni=res.begin();
               ni!=res.end(); ni++) {
            ground_truth gt(db->Size(), -1);
            gt.label("knn-"+ni->first);
            for (map<int,string>::const_iterator ri=cfrres.begin();
               ri!=cfrres.end(); ri++)
              if (ri->second==ni->first)
                gt[ri->first] = 1;

            db->GroundTruthSummaryTable(gt);

            string ffname = OutDirEvenDot()+gt.label();
            db->WriteClassFile(ffname, gt, "k-NN result", false);
          }
        }

        float err = cfr.ErrorRatio();
        if (err<minerr) {
          minerr = err;
          bestk = allk[ki];
        }
      }

      lenvec.Push(knnset.VectorLength());
      errvec.Push(minerr);
      corvec.Push(100-minerr);
      bestkvec.Push(bestk);
    }

    if (MatlabName()!="") {
      string n(Simple::MakeMatlabCompliant(fname)), mfile(n+".m");
      ofstream matlabos(mfile.c_str());
      if (matlabos)
        WriteLog(msg+"Writing to <", mfile.c_str(), ">");
      lenvec.Label(n+"_dim").WriteMatlab(matlabos);
      errvec.Label(n+"_err").WriteMatlab(matlabos);
      corvec.Label(n+"_cor").WriteMatlab(matlabos);
      bestkvec.Label(n+"_k").WriteMatlab(matlabos);
      if (!matlabos)
        return ShowError(msg+"failed to write to <", mfile, ">");
    }
  }

  return true;
}

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseClassification(const vector<string>& args) {
    string msg = "AnalyseClassification";
    WriteLog(msg);
    msg += "() : ";

    DataBase *db = GetDataBase();

    // if (!db->IsMetaClassFile(classname))
    //   return ShowError(msg+"class="+classname+" should be METACLASSFILE"); 

    if (detections.size()!=1)
      return ShowError(msg+"detections.size() should be ==1"); 

    vector<pair<float,float> > coeff(args.size());
    for (size_t i=0; i<args.size(); i++) {
      vector<string> t = SplitInCommas(args[i]);
      if (t.size()!=2)
	return ShowError(msg+"should be mul,add but was\""+args[i]+"\"");
      coeff[i] = make_pair(atof(t[0].c_str()), atof(t[1].c_str()));
    }
    
    const ground_truth& gt = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", gt);

    string mstr;
    list<string> extra;
    AddExtraVariableInfo(extra, "detections", 	    ToStr(detections));
    AddExtraVariableInfo(extra, "class",     	    classname);
    AddExtraVariableInfo(extra, "ntop",       	    ToStr(ntop));
    CheckQuery()->WriteAnalyseVariablesNew("Classification", mstr, gtl, extra);

    list<string> c = db->SplitClassNames(classname);
    vector<string> cx(c.begin(), c.end());

    //obs! this check should be based on bin_data.vdim()...
    bool is_vector = detections.size()==1 &&
      detections[0].find("caffe::reference")==0;
    if (is_vector) {
      c.clear();
      c.push_back("");
    }

    map<string,size_t> confmat, total;

    // map<string,size_t> losses; // replaced by classwise_res  - markus
    map<string,pair<size_t,size_t> > classwise_res; // pair<correct,wrong>

    map<string,ground_truth> gtmap;

    size_t tot = 0, cor = 0;
    for (size_t i=0; i<gt.size(); i++) {
      if (gt[i]!=1)
	continue;

      if (verbose>1) {
	cout << "#" << i << " " << db->Label(i);
	if (verbose>2)
	  cout << endl;
      }

      multimap<float,string> v;
      size_t ci = 0;
      for (auto j=c.begin(); j!=c.end(); j++, ci++) {
	bool angry = true, exists = false, allow_incore = false;
	string dc = detections[0];
	if (!is_vector)
	  dc += "#"+*j;
	if (instance!="")
	  dc += "§"+instance;
	map<string,vector<float> >
	  d = db->RetrieveOrProduceDetectionData(i, dc, "", angry, exists,
						 allow_incore);
	if (d.size()!=1)
	  return ShowError(msg+ToStr(d.size())+" detections for #"+
			   ToStr(i)+" with "+dc); 

	if (!is_vector && d.begin()->second.size()!=1)
	  ShowError(msg+"detection dimensionality != 1");
	
	if (is_vector && d.begin()->second.size()!=cx.size())
	  ShowError(msg+"detection dimensionality "+
		    ToStr(d.begin()->second.size())+" != "+
		    ToStr(cx.size()));

	if (verbose>4)
	  cout << "   " << *j << " " << ToStr(d.begin()->second) << endl;

	if (!is_vector) {
	  float val = d.begin()->second[0], valmod = val;
	  if (coeff.size()>ci) {
	    valmod = coeff[ci].first*val + coeff[ci].second;
	    if (verbose>4)
	      cout << coeff[ci].first << " * " << val << " + " 
		   << coeff[ci].second << " = " << valmod << endl;
	  }
	  v.insert(make_pair(valmod, *j));
	} else
	  for (size_t k=0; k<cx.size() && k<d.begin()->second.size(); k++)
	    v.insert(make_pair(d.begin()->second[k], cx[k]));
      }

      bool is_cor = false;
      size_t n = 0;
      string dst;
      for (auto j=v.rbegin(); j!=v.rend(); j++) {
	auto gtp = gtmap.find(j->second);
	if (gtp==gtmap.end()) {
	  gtmap[j->second] = db->GroundTruthExpression(j->second);
	  gtp = gtmap.find(j->second);
	}
	bool hit = gtp->second[i]==1;
	if (n<ntop && hit)
	  is_cor = true;

	if (n==0)
	  dst = j->second;
	
	if ((verbose>2 && n<ntop) || verbose>3)
	  cout << "   " << n << " " << j->first << " " << j->second << " "
	       << (int)hit << endl;
	if (verbose==3&&n>ntop&&hit) {
	  if (n>ntop+1)
	    cout << "   ..." << endl;
	  cout << "   " << n << " " << j->first << " " << j->second << " "
	       << (int)hit << endl;
	}

	n++;
	if ((verbose==3&&hit) || (verbose<3&&n==ntop))
	  break;
      }

      if (verbose>1)
	cout << "   " << (is_cor?"CORRECT":"miss") << endl;

      for (auto gtp=gtmap.begin(); gtp!=gtmap.end(); gtp++)
	if (gtp->second[i]==1) {
	  if (classwise_res.find(gtp->first)==classwise_res.end())
	    classwise_res[gtp->first] = make_pair(0, 0);
	  if (is_cor)
	    classwise_res[gtp->first].first++;
	  else 
	    classwise_res[gtp->first].second++;
	  confmat[gtp->first+" "+dst]++;
	  total[gtp->first]++;
	}
      
      tot++;
      cor += is_cor;
    }
      
    // for (auto mi=confmat.begin(); mi!=confmat.end(); mi++)
    //   cout << "<" << mi->first << ">" << mi->second << " ";
    // cout << endl;
      
    stringstream ss;
    ss << float(cor)/tot << " (" << cor << "/" << tot << ")";
    WriteLog(detections[0]+" "+classname+" "+gt.label()+" top"+ToStr(ntop)+
	     " overall accuracy: "+ss.str());
    cout << "AVG-TOTAL-ACC " << db->Name() << " " << detections[0] << "\t"
	 << float(cor)/tot << endl;

    float avg_per_class_acc = 0.0;
    size_t nclass = 0;
    for (auto g=classwise_res.begin(); g!=classwise_res.end(); g++) {
      float per_class_acc = float(g->second.first)/
	(g->second.first+g->second.second);
      avg_per_class_acc += per_class_acc;
      nclass++;
      cout << g->first << " " << g->second.first << " " << g->second.second 
	   << " " << per_class_acc << " (";
      for (auto c=classwise_res.begin(); c!=classwise_res.end(); c++) {
	cout << " " << c->first << ": " << confmat[g->first+" "+c->first]
	     << " " << float(confmat[g->first+" "+c->first])/total[g->first];
      }
      cout << " )" << endl;
    }
    avg_per_class_acc /= float(nclass);
    WriteLog(detections[0]+" "+classname+" "+gt.label()+" top"+ToStr(ntop)+
	     " avg-per-class accuracy: "+ToStr(avg_per_class_acc));
    cout << "AVG-CLASS-ACC " << db->Name() << " " << detections[0] << "\t"
	 << avg_per_class_acc << endl;

    /*
    size_t ng = 0, ng_max = 40;
    multimap<size_t,string> missmap;
    for (auto g=losses.begin(); g!=losses.end(); g++)
      missmap.insert(make_pair(g->second, g->first));
    for (auto g=missmap.rbegin(); g!=missmap.rend() && ng!=ng_max; g++, ng++)
      cout << g->second << " " << g->first << endl;
    */

    analyse_result res;
    res.avgprec  = avg_per_class_acc;
    res.rescount = 1;

    return res;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseClassify(const vector<string>&
                                                   args) {
  string msg = "AnalyseClassify";

  WriteLog(msg);
  msg += " : ";

  ReadFiles(false);
  DataBase *db = CheckDB();

  list<string> classes = db->SplitClassNames(classname);
  if (classes.empty()) 
    return ShowError(msg+"SplitClassNames() class=["+classname+"] failed");

  return AnalyseCommonDiscriminantNew(false, classes, args);
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseFeatureClassify(const
							  vector<string>&) {
  string msg = "AnalyseFeatureClassify";
  WriteLog(msg);
  msg += " : ";

  if (gt_trainset.empty() || gt_testset.empty())
    return ShowError(msg+"trainset and testset have to be defined");
  
  DataBase *db = CheckDB();

  TSSOM& tssom = TsSom(0);
  tssom.ReadDataFile();
  
  tssom.SetDataSetNumbers(false, false);
  const FloatVectorSet& data = tssom.Data();

  cout << "gt_trainset size= " << gt_trainset.size() << endl;
  cout << "gt_testset size = " << gt_testset.size() << endl;
  cout << "data size       = " << data.Nitems() << endl;

  FloatVectorSet trainset, testset;
  for (int i=0; i<data.Nitems(); i++) {
    int idx = data[i].Number();
    if (gt_trainset[idx]==1) 
      trainset.AppendCopy(data[i]);
    if (gt_testset[idx]==1)
    testset.AppendCopy(data[i]);
  }
  cout << "trainset size   = " << trainset.Nitems() << endl;
  cout << "testset size    = " << testset.Nitems() << endl;

  FloatVector trainvec(trainset.VectorLength());

  //  trainvec = trainset.Mean();
  for (int i=0; i<trainset.Nitems(); i++)
    trainvec += trainset[i];
  trainvec /= trainset.Nitems();

  float traindist = 0.0; 
  for (int i=0; i<trainset.Nitems(); i++)
    traindist += trainset[i].DistanceXX(trainvec);
  traindist /= trainset.Nitems();
  cout << "avg distance to trainset = " << traindist << endl;
  cout << "threshold set to         = " << classmargin << endl;

  ground_truth gt(db->Size(), -1);
  float testdist = 0.0; 
  size_t npositive = 0;
  for (int i=0; i<testset.Nitems(); i++) {
    float dist = testset[i].DistanceXX(trainvec);
    testdist += dist;
    if (dist < classmargin) {      
      gt[testset[i].Number()] = 1;
      if (!npositive) 
        cout << "Objects classified as positive:" << endl;
      cout << npositive++ << " : "
           << testset[i].Label() << " : "
           << testset[i].Number() << " : " 
           << dist << endl;
    }
  }
  testdist /= testset.Nitems();
  cout << "avg distance to testset  = " << testdist << endl;

  if (classname!="") {
    string text = "Class created by AnalyseFeatureClassify()"; 
    return db->ConditionallyWriteClassFile(true, classname, gt, text, false);
  }
  
  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseTwoClass(const vector<string>& args){
  WriteLog("AnalyseTwoClass");

  const string& pos = query->Positive();
  list<string> classes = GetDataBase()->SplitClassNames(pos);
  if (classes.size()==1)
    return AnalyseTwoClassPerClass(args);

  return ShowError("AnalyseTwoClass() : "
                   "only implemented for exactly one positive class");
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result 
Analysis::AnalyseTwoClassPerClass(const vector<string>& args) {
  WriteLog("AnalyseTwoClassPerClass");

  string neg = CheckQuery()->Negative();
  if (neg=="")
    neg = "~*";

  list<string> lc;
  lc.push_back(CheckQuery()->Positive());
  lc.push_back(neg);
  
  return AnalyseCommonDiscriminantOld(true, lc, args);
}

///////////////////////////////////////////////////////////////////////////////

typedef multiset<vector<float> > scatter_t;
typedef list<cox::knn::lvector_t> cox_knn_set_t;
typedef struct {
  string name;
  float w;
  cox::classifier* cfier;
  cox_knn_set_t test;
  cox_knn_set_t::const_iterator ti;
  scatter_t pos_all, pos_err, neg_all, neg_err;
} discrim_fd_t;

Analysis::analyse_result 
Analysis::AnalyseCommonDiscriminantOld(bool posneg, const list<string>& lc,
                                       const vector<string>&/*args*/) {
  string err = "AnalyseCommonDiscriminantOld() failed : ";
  if (gt_trainset.empty() || gt_testset.empty())
    return ShowError(err+"trainset and testset have to be defined");

  ground_truth intsect = gt_trainset.TernaryAND(gt_testset);
  if (intsect.has_plus())
    return ShowError(err+"trainset and testset should be disjoint");

  if (classifier=="")
    return ShowError(err+"classifier not defined");

  bool debug = verbose>2;

  WriteLog("AnalyseCommonDiscriminant");

  string knntmp = classifier;
  if (knntmp.substr(0, 3)=="knn")
    knntmp.erase(0, 3);

  bool use_lsc = false;
  if (knntmp.find("lsc")==0) {
    use_lsc = true;
    knntmp.erase(0, 3);
  }

  size_t knn_k = atoi(knntmp.c_str()), discard = 0;

  size_t p = knntmp.find_first_not_of("0123456789");
  string knnopt = p!=string::npos ? knntmp.substr(p) : "";
  if (knnopt[0]==',') {
    knnopt.erase(0, 1);
    discard = atoi(knnopt.c_str());
    p = knnopt.find_first_not_of("0123456789");
    knnopt = p!=string::npos ? knnopt.substr(p) : "";
  }
  bool sqr_avg  =  knnopt.find('q')!=string::npos;
  bool sqr_term =  knnopt.find('s')!=string::npos;
  bool sqr_sum  =  knnopt.find('S')!=string::npos;

  ReadFiles(false);

  const ground_truth& gt_tt  = TargetTypeGT();
//   const ground_truth gt_test = gt_tt&RestrictionGT();
//   const ground_truth gt_view =
//     ViewClassGT().empty() ? ground_truth() : gt_tt&ViewClassGT();
  
//   ground_truth gt_testx = gt_test;
//   for (size_t i=0; i<gt_testx.size(); i++)
//     if (!gt_view.empty() && gt_view[i]==1 && gt_testx[i]!=1)
//       return ShowError(err+"viewclass not fully in restriction");
//     else
//       gt_testx[i] = gt_testx[i]==1 ? gt_view[i]==1 ? 1 : -1 : 0;

  ground_truth_list gtl, train_set_parts, test_set_parts;;
  ground_truth train_set_all = ground_truth(DataBaseSize(), -1);
  ground_truth test_set_all  = train_set_all;

  for (list<string>::const_iterator li=lc.begin(); li!=lc.end(); li++) {
    string lab = posneg?gtl.empty()?"positive":"negative":*li;

    ground_truth tmp = gt_tt&GTExpr(*li);
    // lgt.push_back(tmp);
    AddGroundTruthInfo(gtl, lab, tmp);

    ground_truth tmp_tr = tmp&gt_trainset;
    AddGroundTruthInfo(gtl, lab+"-train", tmp_tr);
    AddGroundTruthInfo(train_set_parts, lab, tmp_tr);
    train_set_all = train_set_all.TernaryOR(tmp_tr);

    ground_truth tmp_te = tmp&gt_testset;
    AddGroundTruthInfo(gtl, lab+"-test", tmp_te);
    AddGroundTruthInfo(test_set_parts, lab, tmp_te);
    test_set_all = test_set_all.TernaryOR(tmp_te);
  }

  // AddGroundTruthInfo(gtl, "restriction", gt_test);
  // AddGroundTruthInfo(gtl, "viewclass",   gt_view);

  AddGroundTruthInfo(gtl, "trainset",    gt_trainset);
  AddGroundTruthInfo(gtl, "testset",     gt_testset);

  AddGroundTruthInfo(gtl, "trainset-eff",    train_set_all);
  AddGroundTruthInfo(gtl, "testset-eff",     test_set_all);

  CreateIndexData(false);

  string mstr;
  list<string> extra;
  AddExtraVariableInfo(extra, "knn",       knntmp);
  AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
  AddExtraVariableInfo(extra, "taskstack", TaskStack());
  CheckQuery()->WriteAnalyseVariablesNew("Discriminant", mstr, gtl, extra);

  list<discrim_fd_t> fd;
  size_t test_size = 0;

  for (size_t j=0; j<Nfeatures(); j++) {
    cox_knn_set_t train_set_vecs, test_set_vecs;

    for (ground_truth_list::const_iterator i=train_set_parts.begin();
         i!=train_set_parts.end(); i++) {
      cox_knn_set_t tmp = PrepareDataSet(j, i->second.first, i->first);
      train_set_vecs.splice(train_set_vecs.end(), tmp);
    }

    for (ground_truth_list::const_iterator i=test_set_parts.begin();
         i!=test_set_parts.end(); i++) {
      cox_knn_set_t tmp = PrepareDataSet(j, i->second.first, i->first);
      test_set_vecs.splice(test_set_vecs.end(), tmp);
    }

    typedef cox::classifier* cp;
    fd.push_back(discrim_fd_t());
    fd.back().name  = IndexFullName(j);
    //fd.back().w   = CheckQuery()->FeatureWeight(j);  //should be this?
    fd.back().w     = CheckQuery()->Weight(j);
    fd.back().cfier = use_lsc?(cp)new cox::lsc(knn_k):(cp)new cox::knn(knn_k);
    fd.back().test  = test_set_vecs;
    fd.back().ti    = fd.back().test.begin();

    if (j==0)
      test_size = fd.back().test.size();
    else if (test_size!=fd.back().test.size())
      return ShowError(err+"test_size differs");

    try {
      cox::classifier *c = fd.back().cfier;

      if (use_lsc) {
        cox::lsc& lsc = *(cox::lsc*)c;
        lsc.add(train_set_vecs);

      } else {
        cox::knn& knn = *(cox::knn*)c;
        knn.discard(discard);
        knn.sqr_avg(sqr_avg);
        knn.add(train_set_vecs);
      }

      WriteLog(IndexFullName(j)+" : "+c->description()+" weight="+
               ToStr(fd.back().w)+" sqr_term="+ToStr(sqr_term)
               +" sqr_sum="+ToStr(sqr_sum));
    }
    catch (const char *e) {
      return ShowError(err+e);
    }
  }

  size_t pos_all = 0, pos_err = 0, neg_all = 0, neg_err = 0;
  multimap<float,size_t> best;

  for (size_t i=0; i<test_set_all.size(); i++) {
    if (test_set_all[i]!=1)
      continue;

    if (debug)
      cout << i << " :";

    bool is_pos = false;

    float v11sum = 0, v12sum = 0,  v21sum = 0, v22sum = 0;
    for (list<discrim_fd_t>::iterator f = fd.begin(); f!=fd.end(); f++) {
      bool is_pos_f = f->ti->label()=="pos";
      if (f==fd.begin())
        is_pos = is_pos_f;
      else if (is_pos!=is_pos_f)
        return ShowError(err+"is_pos!=is_pos_f");

      if (debug)
        cout << " " << f->name << "(" << f->test.front().size()
             << "/" << f->cfier->vector_length()
          // << "x" << ((cox::knn*)f->cfier)->n() 
             << ")";

      string cres = f->cfier->classify(*f->ti);
      if (debug)
        cout << " [" << f->ti->label() << "->" << cres << "]";

      typedef vector<pair<string,double> > cdist_t;
      cdist_t cdist = f->cfier->class_distances(*f->ti);

      float pos = 0, neg = 0;
      for (cdist_t::const_iterator c=cdist.begin(); c!=cdist.end(); c++) {
        if (debug)
          cout << " " << c->first << ":" << c->second;
        if (c->first=="pos")
          pos = c->second;
        else
          neg = c->second;
      }

      float ne2 = neg*neg, po2 = pos*pos;
      float v11 = (neg-pos)/(neg+pos);
      float v22 = (ne2-po2)/(ne2+po2);
      float v12 = v11*v11*(v11<0?-1:1);
      float v21 = v22<0 ? -sqrt(-v22) : sqrt(v22);

      if (debug)
        cout << " -> " << v11 << "," << v22 << "," << v12 << "," << v21
             << " * " << f->w;

      bool res_pos = neg>pos, res_err = res_pos!=is_pos;

      float vx[6] = { neg, pos, v11, v22, v12, v21 };
      vector<float> vvv(vx, vx+6);
      (is_pos?f->pos_all:f->neg_all).insert(vvv);
      if (res_err)
        (is_pos?f->pos_err:f->neg_err).insert(vvv);

      v11sum += v11*f->w;
      v22sum += v22*f->w;
      v12sum += v12*f->w;
      v21sum += v21*f->w;

      f->ti++;
    }

    if (debug)
      cout << " +=> " << v11sum << "," << v22sum
           << ","     << v12sum << "," << v21sum << endl;

    float sum_res = sqr_sum ?
      sqr_term ? v22sum : v12sum :
      sqr_term ? v21sum : v11sum;

    best.insert(pair<float,size_t>(sum_res, i));
    
    bool sum_res_pos = sum_res>0, sum_res_err = sum_res_pos!=is_pos;
    if (sum_res_err)
      (is_pos?pos_err:neg_err)++;
    (is_pos?pos_all:neg_all)++;
  }

  ofstream os;
  if (MatlabName()!="")
    os.open((ExpandedMatlabName()+"_scat.m").c_str());

  cout << "[TOTAL] : "
       << " pos->pos " << pos_all-pos_err << " neg->neg " << neg_all-neg_err
       << " pos->neg " << pos_err << " neg->pos " << neg_err << endl;

  for (list<discrim_fd_t>::iterator f = fd.begin(); f!=fd.end(); f++) {
    cout << "[" << f->name << "] :"
         << " pos->pos " << f->pos_all.size()-f->pos_err.size()
         << " neg->neg " << f->neg_all.size()-f->neg_err.size()
         << " pos->neg " << f->pos_err.size()
         << " neg->pos " << f->neg_err.size()
         << endl;
    
    if (MatlabName()=="")
      continue;

    string hdr = ExpandedMatlabName()+"_"+
      Simple::MakeMatlabCompliant(f->name)+"_scat";

    using cox::matlab::write;
    os << hdr+"_pos_all = ["; write(f->pos_all, os); os << " ];" << endl;
    os << hdr+"_neg_all = ["; write(f->neg_all, os); os << " ];" << endl;
    os << hdr+"_pos_err = ["; write(f->pos_err, os); os << " ];" << endl;
    os << hdr+"_neg_err = ["; write(f->neg_err, os); os << " ];" << endl;
  }

  ofstream res;
  string resnam = resultname!="" ? resultname+".txt" : "";
  if (resnam!="")
    res.open(resnam.c_str());

  DataBase *db = CheckDB();

  objectlist_t bestidxval;
  multimap<float,size_t>::reverse_iterator b = best.rbegin();
  for (size_t i=0; i<best.size(); i++, b++) {
    bestidxval.push_back(make_pair(b->second, b->first)); 
    if (resnam!="") {
      map<string,string> hash = db->ReadOriginsInfo(b->second,
                                                    false, true);
      string url = hash["url"]; 
      size_t dpos = url.find('.');
      if (dpos!=string::npos)
        url.erase(dpos);

      if (url=="")
        return ShowError("origins file does not contain url of <"+
                         Label(b->second)+">");

      res << url << " " << b->first << endl;
    }
  }

  if (resnam!="") {
    if (res)
      WriteLog("Wrote results in <"+resnam+">");
    else
      return ShowError("Failed to write results in <"+resnam+">");
  }

  return AnalyseResultsCommon(bestidxval, test_set_all, mstr);
}

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseCommonDiscriminantNew(bool posneg, const list<string>& lc,
                                         const vector<string>&/*args*/) {
    string err = "AnalyseCommonDiscriminantNew() failed : ";
    if (gt_trainset.empty() || gt_testset.empty())
      return ShowError(err+"trainset and testset have to be defined");

    cout << "trainset=";
    CheckDB()->GroundTruthSummaryTable(gt_trainset);
    cout << "testset=";
    CheckDB()->GroundTruthSummaryTable(gt_testset);

    ground_truth intsect = gt_trainset.TernaryAND(gt_testset);
    if (intsect.has_plus())
      return ShowError(err+"trainset and testset should be disjoint");

    if (classifier=="")
      return ShowError(err+"classifier not defined");

    bool debug = verbose>2;

    WriteLog("AnalyseCommonDiscriminant");

    ground_truth_set gt_train_set, gt_test_set;

    ground_truth_list gtl, train_set_parts, test_set_parts;

    ground_truth train_set_all = ground_truth(DataBaseSize(), -1);
    ground_truth test_set_all  = train_set_all;
    const ground_truth& gt_tt  = TargetTypeGT();

    for (list<string>::const_iterator li=lc.begin(); li!=lc.end(); li++) {
      string lab = posneg?gtl.empty()?"positive":"negative":*li;

      ground_truth tmp = gt_tt&GTExpr(*li);
      AddGroundTruthInfo(gtl, lab, tmp);

      ground_truth tmp_tr = tmp&gt_trainset;
      AddGroundTruthInfo(gtl, lab+"-train", tmp_tr);
      AddGroundTruthInfo(train_set_parts, lab, tmp_tr);
      train_set_all = train_set_all.TernaryOR(tmp_tr);

      ground_truth tmp_te = tmp&gt_testset;
      AddGroundTruthInfo(gtl, lab+"-test", tmp_te);
      AddGroundTruthInfo(test_set_parts, lab, tmp_te);
      test_set_all = test_set_all.TernaryOR(tmp_te);

      ground_truth tmp_set = tmp_tr;
      tmp_set.label(lab);
      gt_train_set.insert(tmp_set);

      tmp_set = tmp_te;
      tmp_set.label(lab);
      gt_test_set.insert(tmp_set);
    }

    // AddGroundTruthInfo(gtl, "restriction", gt_test);
    // AddGroundTruthInfo(gtl, "viewclass",   gt_view);

    AddGroundTruthInfo(gtl, "trainset",    gt_trainset);
    AddGroundTruthInfo(gtl, "testset",     gt_testset);

    AddGroundTruthInfo(gtl, "trainset-eff",    train_set_all);
    AddGroundTruthInfo(gtl, "testset-eff",     test_set_all);

    string cfiertmp = classifier, preopt; // eg. sS:knn3,2q
    size_t colon = cfiertmp.find(':');
    if (colon<3) {
      preopt = cfiertmp.substr(0, colon);
      cfiertmp.erase(colon+1);
    }

    ReadFiles(false);

    typedef pair<cox_knn_set_t,cox_knn_set_t::iterator> test_data_e;
    typedef list<test_data_e> test_data_t;
    test_data_t test_data;

    list<string> cnames;

    for (size_t i=0; i<Nfeatures(); i++) {
      TSSOM& tssom = TsSom(i);
      string cname = cfiertmp;
      if (!tssom.CreateClassifier(cname, cfiertmp, gt_train_set))
        return ShowError(err+"CreateClassifier("+cname+
                         ","+cfiertmp+") failed");
      cnames.push_back(cname);

      cox_knn_set_t tset = tssom.CoxVectors(gt_test_set);
      test_data.push_back(make_pair(tset, tset.begin()));
      test_data.back().second = test_data.back().first.begin();

      if (test_data.front().first.size()!=test_data.back().first.size())
        return ShowError(err+"data set size mismatch");
    }

    bool sqr_term =  preopt.find('s')!=string::npos;
    bool sqr_sum  =  preopt.find('S')!=string::npos;

    CreateIndexData(false);

    string mstr;
    list<string> extra;
    AddExtraVariableInfo(extra, "classifier", cfiertmp);
    AddExtraVariableInfo(extra, "depth",      ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack",  TaskStack());
    CheckQuery()->WriteAnalyseVariablesNew("Discriminant", mstr, gtl, extra);

    size_t pos_all = 0, pos_err = 0, neg_all = 0, neg_err = 0;
    multimap<float,size_t> best;

    ConfusionMatrix cfmat;

    for (size_t i=0; i<test_set_all.size(); i++) {
      if (test_set_all[i]!=1)
        continue;

      if (debug)
        cout << i << " :";

      cox_knn_set_t vecs;
      for (test_data_t::iterator k=test_data.begin(); k!=test_data.end(); k++) {
        if (k->second==k->first.end())
          return ShowError(err+"indexing problem");
        vecs.push_back(*k->second);
        k->second++;
      }

      list<multimap<double,string> > cdists = ClassDistances(vecs, cnames);
      if (cdists.empty())
        return ShowError(err+"ClassDistances() failed");

      float res = 0.0;
      if (!OneDiscriminant(vecs, cnames, sqr_term, sqr_sum, res, cfmat))
        return ShowError(err+"OneDiscriminant() failed");
      
      best.insert(pair<float,size_t>(res, i));
    }

    cfmat.DisplayWide();
    cfmat.DisplayAccuracy();

    ofstream os;
    if (MatlabName()!="")
      os.open((ExpandedMatlabName()+"_scat.m").c_str());

    cout << "[TOTAL] : "
         << " pos->pos " << pos_all-pos_err << " neg->neg " << neg_all-neg_err
         << " pos->neg " << pos_err << " neg->pos " << neg_err << endl;

//     for (list<discrim_fd_t>::iterator f = fd.begin(); f!=fd.end(); f++) {
//       cout << "[" << f->name << "] :"
//            << " pos->pos " << f->pos_all.size()-f->pos_err.size()
//            << " neg->neg " << f->neg_all.size()-f->neg_err.size()
//            << " pos->neg " << f->pos_err.size()
//            << " neg->pos " << f->neg_err.size()
//            << endl;
    
//       if (MatlabName()=="")
//         continue;

//       string hdr = ExpandedMatlabName()+"_"+
//         Simple::MakeMatlabCompliant(f->name)+"_scat";
//       using cox::matlab::write;
//       os << hdr+"_pos_all = ["; write(f->pos_all, os); os << " ];" << endl;
//       os << hdr+"_neg_all = ["; write(f->neg_all, os); os << " ];" << endl;
//       os << hdr+"_pos_err = ["; write(f->pos_err, os); os << " ];" << endl;
//       os << hdr+"_neg_err = ["; write(f->neg_err, os); os << " ];" << endl;
//     }

    ofstream res;
    string resnam = resultname!="" ? resultname+".txt" : "";
    if (resnam!="")
      res.open(resnam.c_str());

    DataBase *db = CheckDB();

    objectlist_t bestidxval;
    multimap<float,size_t>::reverse_iterator b = best.rbegin();
    for (size_t i=0; i<best.size(); i++, b++) {
      bestidxval.push_back(make_pair(b->second, b->first)); 
      if (resnam!="") {
        map<string,string> hash = db->ReadOriginsInfo(b->second,
                                                      false, true);
        string url = hash["url"];
        if (url=="")
          url = Label(b->second);

        size_t dpos = url.find('.');
        if (dpos!=string::npos)
          url.erase(dpos);

        if (url=="")
          return ShowError("origins file does not contain url of <"+
                           Label(b->second)+">");

        res << url << " " << b->first << endl;
      }
    }

    if (resnam!="") {
      if (res)
        WriteLog("Wrote results in <"+resnam+">");
      else
        return ShowError("Failed to write results in <"+resnam+">");
    }

    return AnalyseResultsCommon(bestidxval, test_set_all, mstr);
  }

  /////////////////////////////////////////////////////////////////////////////

  list<multimap<double,string> >  
  Analysis::ClassDistances(const list<cox::knn::lvector_t>& vecs,
                           const list<string>& cnames) {
    string err = "Analysis::ClassDistances() : ";

    bool debug = verbose>2;

    list<multimap<double,string> > empty, ret;

    if (vecs.size()!=Nfeatures()) {
      ShowError(err+"list size mismatch A");
      return empty;
    }

    if (vecs.size()!=cnames.size()) {
      ShowError(err+"list size mismatch B");
      return empty;
    }

    list<cox::knn::lvector_t>::const_iterator fi = vecs.begin();
    list<string>::const_iterator ci = cnames.begin();

    for (size_t i=0; i<Nfeatures(); i++) {
      TSSOM& tssom = TsSom(i);
      TSSOM::classifier_data *c = tssom.FindClassifier(*ci);
      if (!c) {
        ShowError(err+"classifier ["+*ci+"] not found");
        return empty;
      }

      if (debug)
        cout << " " << tssom.Name() << "/" << c->name;

      string cres = c->classify(*fi);
      if (debug)
        cout << " [<" << fi->label() << "->" << cres << ">]";

      typedef vector<pair<string,double> > cdist_t;
      cdist_t cdist = c->class_distances(*fi);

      ret.push_back(multimap<double,string>());
      for (cdist_t::const_iterator j=cdist.begin(); j!=cdist.end(); j++)
        ret.back().insert(make_pair(j->second, j->first));

      fi++;
      ci++;
    }

    return ret;
  }
  
  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::OneDiscriminant(const list<cox::knn::lvector_t>& vecs,
                                 const list<string>& cnames,
                                 bool sqr_term, bool sqr_sum, float& res,
                                 ConfusionMatrix& cfmat) {
    string err = "Analysis::OneDiscriminant() : ";

    bool debug = verbose>2;

    if (vecs.size()!=Nfeatures())
      return ShowError(err+"list size mismatch A");

    if (vecs.size()!=cnames.size())
      return ShowError(err+"list size mismatch B");

    list<cox::knn::lvector_t>::const_iterator fi = vecs.begin();
    list<string>::const_iterator ci = cnames.begin();

    bool is_pos = false;

    float v11sum = 0, v12sum = 0,  v21sum = 0, v22sum = 0;
    for (size_t i=0; i<Nfeatures(); i++) {
      double weight = 1.0;

      bool is_pos_f = fi->label()=="pos";
      if (i==0)
        is_pos = is_pos_f;
      else if (is_pos!=is_pos_f)
        return ShowError(err+"is_pos!=is_pos_f");

      TSSOM& tssom = TsSom(i);
      TSSOM::classifier_data *c = tssom.FindClassifier(*ci);
      if (!c)
        return ShowError(err+"classifier ["+*ci+"] not found");

      if (debug)
        cout << " " << tssom.Name() << "/" << c->name;

      string cres = c->classify(*fi);
      if (debug)
        cout << " [[" << fi->label() << "->" << cres << "]]";

      cfmat.Add(fi->label(), cres);

      typedef vector<pair<string,double> > cdist_t;
      cdist_t cdist = c->class_distances(*fi);

      float pos = 0, neg = 0;
      for (cdist_t::const_iterator cdi=cdist.begin(); cdi!=cdist.end(); cdi++) {
        if (debug)
          cout << " " << cdi->first << ":" << cdi->second;
        if (cdi->first=="pos")
          pos = cdi->second;
        else
          neg = cdi->second;
      }

      float ne2 = neg*neg, po2 = pos*pos;
      float v11 = (neg-pos)/(neg+pos);
      float v22 = (ne2-po2)/(ne2+po2);
      float v12 = v11*v11*(v11<0?-1:1);
      float v21 = v22<0 ? -sqrt(-v22) : sqrt(v22);

      if (debug)
        cout << " -> " << v11 << "," << v22 << "," << v12 << "," << v21
             << " * " << weight;

      // bool res_pos = neg>pos, res_err = res_pos!=is_pos;

//       float vx[6] = { neg, pos, v11, v22, v12, v21 };
//       vector<float> vvv(vx, vx+6);
//       (is_pos?f->pos_all:f->neg_all).insert(vvv);
//       if (res_err)
//         (is_pos?f->pos_err:f->neg_err).insert(vvv);

      v11sum += v11*weight;
      v22sum += v22*weight;
      v12sum += v12*weight;
      v21sum += v21*weight;

      fi++;
      ci++;
    }

    if (debug)
      cout << " +=> " << v11sum << "," << v22sum
           << ","     << v12sum << "," << v21sum << endl;

    res = sqr_sum ? sqr_term ? v22sum : v12sum : sqr_term ? v21sum : v11sum;

//     bool sum_res_pos = sum_res>0, sum_res_err = sum_res_pos!=is_pos;
//     if (sum_res_err)
//       (is_pos?pos_err:neg_err)++;
//     (is_pos?pos_all:neg_all)++;

    return true;
  }

///////////////////////////////////////////////////////////////////////////////


cox_knn_set_t Analysis::PrepareDataSet(size_t i, const ground_truth& select,
                                       const string& lab) {
  string msg = "PrepareDataSet() : ";

  bool may_add_labels = false;  // set to true with caution...

  cox_knn_set_t ret;

  if (!TsSom(i).SetDataSetNumbers(false, may_add_labels&&addlabels)) {
    ShowError(msg+"setting data set numbers in <", IndexFullName(i),
              "> failed");
    return ret;
  }

  DataBase *db = CheckDB();

  const FloatVectorSet& data = TsSom(i).Data();
  ground_truth not_found = select;
  FloatVectorSet set;
  
  for (int j=0; j<data.Nitems(); j++) {
    int idx = data[j].Number();
    if (select[idx]==1) {
      set.AppendCopy(data[j]);
      if (not_found[idx]!=select[idx]) {
        stringstream ss;
        ss << TsSom(i).Name() << " j=" << j << " idx=" << idx
           << " lab=<" << lab << ">" 
           << " not_found[idx]=" << (int)not_found[idx]
           << " != select[idx]=" << (int)select[idx] << " "
           << db->ObjectDump(idx);
        ShowError(msg+ss.str());
        return ret;
      }
    }
    not_found[idx] = 0;
  }

  size_t nnfound = not_found.positives();
  if (nnfound) {
    ShowError(msg+ToStr(nnfound)+" vectors not found");
    return ret;
  }

  int setsize_was = set.Nitems();

  /// weird still...
  string fname;
  if (fname.length())
    fname += "-";
  fname += IndexFullName(i);

  if (!DataPreProcessing(set, fname)){
    ShowError(msg+"DataPreProcessing() failed");
    return ret;
  }

  if (set.Nitems()!=setsize_was) {
    ShowError(msg+"set size changed in DataPreProcessing()");
    return ret;
  }

  map<size_t,int> idxmap;
  for (int j=0; j<set.Nitems(); j++) {
    size_t idx = set[j].Number();
    if (select[idx]!=1) {
      ShowError(msg+"strange vector number");
      return ret;
    }
    if (idxmap.find(idx)!=idxmap.end()) {
      ShowError(msg+"duplicate vector number");
      return ret;
    }
    idxmap[idx] = j;
  }

  size_t vl = set.VectorLength();
  for (size_t j=0; j<select.size(); j++)
    if (select[j]==1) {
      const FloatVector& v = set[idxmap[j]];
      const float *fv = v;
      ret.push_back(cox::knn::lvector_t(vector<float>(fv, fv+vl), lab));
    }

  return ret;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseTwoClassOld(const vector<string>&
                                                        args){
  WriteLog("AnalyseTwoClass");

  const string& pos = query->Positive();
  list<string> classes = GetDataBase()->SplitClassNames(pos);
  if (classes.size()==1)
    return AnalyseTwoClassPerClass(args);

  return ShowError("AnalyseTwoClass() : "
                   "only implemented for exactly one positive class");
}

///////////////////////////////////////////////////////////////////////////////

typedef multiset<vector<float> > scatter_t;
typedef list<cox::knn::lvector_t> cox_knn_set_t;
typedef struct {
  string name;
  float w;
  cox::classifier* cfier;
  cox_knn_set_t test;
  cox_knn_set_t::const_iterator ti;
  scatter_t pos_all, pos_err, neg_all, neg_err;
} detect_fd_t;

Analysis::analyse_result
Analysis::AnalyseTwoClassPerClassOld(const vector<string>& /*args*/) {
  bool debug = verbose>2;

  WriteLog("AnalyseTwoClassPerClass");

  string err = "AnalyseTwoClassPerClass() failed : ";

  bool use_lsc = false;
  string knntmp = classifier!="" ? classifier : "knn3";
  if (knntmp.find("lsc")==0) {
    use_lsc = true;
    knntmp.erase(0, 3);
  }

  size_t knn_k = atoi(knntmp.c_str()), discard = 0;

  size_t p = knntmp.find_first_not_of("0123456789");
  string knnopt = p!=string::npos ? knntmp.substr(p) : "";
  if (knnopt[0]==',') {
    knnopt.erase(0, 1);
    discard = atoi(knnopt.c_str());
    p = knnopt.find_first_not_of("0123456789");
    knnopt = p!=string::npos ? knnopt.substr(p) : "";
  }
  bool sqr_avg  =  knnopt.find('q')!=string::npos;
  bool sqr_term =  knnopt.find('s')!=string::npos;
  bool sqr_sum  =  knnopt.find('S')!=string::npos;

  ReadFiles(false);

  const ground_truth& gt_tt  = TargetTypeGT();
  const ground_truth gt_posi = gt_tt&PositiveGT();
  const ground_truth gt_nega = gt_tt&NegativeGT();
  const ground_truth gt_test = gt_tt&DataBaseRestrictionGT();
  const ground_truth gt_view =
    ViewClassGT().empty() ? ground_truth() : gt_tt&ViewClassGT();

  ground_truth gt_testx = gt_test;
  for (size_t i=0; i<gt_testx.size(); i++)
    if (!gt_view.empty() && gt_view[i]==1 && gt_testx[i]!=1)
      return ShowError(err+"viewclass not fully in restriction");
    else
      gt_testx[i] = gt_testx[i]==1 ? gt_view[i]==1 ? 1 : -1 : 0;

  ground_truth_list gtl;
  AddGroundTruthInfo(gtl, "positive",    gt_posi);
  AddGroundTruthInfo(gtl, "negative",    gt_nega);
  AddGroundTruthInfo(gtl, "restriction", gt_test);
  AddGroundTruthInfo(gtl, "viewclass",   gt_view);

  CreateIndexData(false);

  string mstr;
  list<string> extra;
  AddExtraVariableInfo(extra, "knn",       knntmp);
  AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
  AddExtraVariableInfo(extra, "taskstack", TaskStack());
  CheckQuery()->WriteAnalyseVariablesNew("TwoClass", mstr, gtl, extra);

  list<detect_fd_t> fd;
  size_t test_size = 0;

  for (size_t j=0; j<Nfeatures(); j++) {
    typedef cox::classifier* cp;
    fd.push_back(detect_fd_t());
    fd.back().name  = IndexFullName(j);
    //fd.back().w   = CheckQuery()->FeatureWeight(j);  //should be this?
    fd.back().w     = CheckQuery()->Weight(j);
    fd.back().cfier = use_lsc?(cp)new cox::lsc(knn_k):(cp)new cox::knn(knn_k);
    fd.back().test  = PrepareDataSetOld(j, gt_testx, "neg", "pos");
    fd.back().ti    = fd.back().test.begin();

    if (j==0)
      test_size = fd.back().test.size();
    else if (test_size!=fd.back().test.size())
      return ShowError(err+"test_size differs");

    try {
      cox::classifier *c = fd.back().cfier;
      if (use_lsc) {
        cox::lsc& lsc = *(cox::lsc*)c;
        lsc.add(PrepareDataSetOld(j, gt_posi, "", "pos"));
        lsc.add(PrepareDataSetOld(j, gt_nega, "", "neg"));

      } else {
        cox::knn& knn = *(cox::knn*)c;
        knn.discard(discard);
        knn.sqr_avg(sqr_avg);
        knn.add(PrepareDataSetOld(j, gt_posi, "", "pos"));
        knn.add(PrepareDataSetOld(j, gt_nega, "", "neg"));
      }
      WriteLog(IndexFullName(j)+" : "+c->description()+" weight="+
               ToStr(fd.back().w)+" sqr_term="+ToStr(sqr_term)
               +" sqr_sum="+ToStr(sqr_sum));
    }
    catch (const char *e) {
      return ShowError(err+e);
    }
  }

  size_t pos_all = 0, pos_err = 0, neg_all = 0, neg_err = 0;
  multimap<float,size_t> best;

  for (size_t i=0; i<gt_test.size(); i++) {
    if (gt_test[i]!=1)
      continue;

    if (debug)
      cout << i << " :";

    bool is_pos = false;

    float v11sum = 0, v12sum = 0,  v21sum = 0, v22sum = 0;
    for (list<detect_fd_t>::iterator f = fd.begin(); f!=fd.end(); f++) {
      bool is_pos_f = f->ti->label()=="pos";
      if (f==fd.begin())
        is_pos = is_pos_f;
      else if (is_pos!=is_pos_f)
        return ShowError(err+"is_pos!=is_pos_f");

      if (debug)
        cout << " " << f->name << "(" << f->test.front().size()
             << "/" << f->cfier->vector_length()
          // << "x" << ((cox::knn*)f->cfier)->n() 
             << ")";

      string cres = f->cfier->classify(*f->ti);
      if (debug)
        cout << " [" << f->ti->label() << "->" << cres << "]";

      typedef vector<pair<string,double> > cdist_t;
      cdist_t cdist = f->cfier->class_distances(*f->ti);

      float pos = 0, neg = 0;
      for (cdist_t::const_iterator c=cdist.begin(); c!=cdist.end(); c++) {
        if (debug)
          cout << " " << c->first << ":" << c->second;
        if (c->first=="pos")
          pos = c->second;
        else
          neg = c->second;
      }

      float ne2 = neg*neg, po2 = pos*pos;
      float v11 = (neg-pos)/(neg+pos);
      float v22 = (ne2-po2)/(ne2+po2);
      float v12 = v11*v11*(v11<0?-1:1);
      float v21 = v22<0 ? -sqrt(-v22) : sqrt(v22);

      if (debug)
        cout << " -> " << v11 << "," << v22 << "," << v12 << "," << v21
             << " * " << f->w;

      bool res_pos = neg>pos, res_err = res_pos!=is_pos;

      float vx[6] = { neg, pos, v11, v22, v12, v21 };
      vector<float> vvv(vx, vx+6);
      (is_pos?f->pos_all:f->neg_all).insert(vvv);
      if (res_err)
        (is_pos?f->pos_err:f->neg_err).insert(vvv);

      v11sum += v11*f->w;
      v22sum += v22*f->w;
      v12sum += v12*f->w;
      v21sum += v21*f->w;

      f->ti++;
    }

    if (debug)
      cout << " +=> " << v11sum << "," << v22sum
           << ","     << v12sum << "," << v21sum << endl;

    float sum_res = sqr_sum ?
      sqr_term ? v22sum : v12sum :
      sqr_term ? v21sum : v11sum;

    best.insert(pair<float,size_t>(sum_res, i));
    
    bool sum_res_pos = sum_res>0, sum_res_err = sum_res_pos!=is_pos;
    if (sum_res_err)
      (is_pos?pos_err:neg_err)++;
    (is_pos?pos_all:neg_all)++;
  }

  ofstream os;
  if (MatlabName()!="")
    os.open((ExpandedMatlabName()+"_scat.m").c_str());

  cout << "[TOTAL] : "
       << " pos->pos " << pos_all-pos_err << " neg->neg " << neg_all-neg_err
       << " pos->neg " << pos_err << " neg->pos " << neg_err << endl;

  for (list<detect_fd_t>::iterator f = fd.begin(); f!=fd.end(); f++) {
    cout << "[" << f->name << "] :"
         << " pos->pos " << f->pos_all.size()-f->pos_err.size()
         << " neg->neg " << f->neg_all.size()-f->neg_err.size()
         << " pos->neg " << f->pos_err.size()
         << " neg->pos " << f->neg_err.size()
         << endl;
    
    if (MatlabName()=="")
      continue;

    string hdr = ExpandedMatlabName()+"_"+
      Simple::MakeMatlabCompliant(f->name)+"_scat";

    using cox::matlab::write;
    os << hdr+"_pos_all = ["; write(f->pos_all, os); os << " ];" << endl;
    os << hdr+"_neg_all = ["; write(f->neg_all, os); os << " ];" << endl;
    os << hdr+"_pos_err = ["; write(f->pos_err, os); os << " ];" << endl;
    os << hdr+"_neg_err = ["; write(f->neg_err, os); os << " ];" << endl;
  }

  ofstream res;
  string resnam = resultname!="" ? resultname+".txt" : "";
  if (resnam!="")
    res.open(resnam.c_str());

  DataBase *db = CheckDB();

  objectlist_t bestidxval;
  multimap<float,size_t>::reverse_iterator b = best.rbegin();
  for (size_t i=0; i<best.size(); i++, b++) {
    bestidxval.push_back(make_pair(b->second, b->first)); 
    if (resnam!="") {
      map<string,string> hash = db->ReadOriginsInfo(b->second,
                                                    false, true);
      string url = hash["url"]; 
      size_t dpos = url.find('.');
      if (dpos!=string::npos)
        url.erase(dpos);

      if (url=="")
        return ShowError("origins file does not contain url of <"+
                         Label(b->second)+">");

      res << url << " " << b->first << endl;
    }
  }

  if (resnam!="") {
    if (res)
      WriteLog("Wrote results in <"+resnam+">");
    else
      return ShowError("Failed to write results in <"+resnam+">");
  }

  return AnalyseResultsCommon(bestidxval, gt_view, mstr);
}

///////////////////////////////////////////////////////////////////////////////

cox_knn_set_t Analysis::PrepareDataSetOld(size_t i, const ground_truth& select,
                                       const string& neg, const string& pos) {
  string msg = "PrepareDataSetOld() : ";

  bool may_add_labels = false;  // set to true with caution...

  cox_knn_set_t ret;

  if (!TsSom(i).SetDataSetNumbers(false, may_add_labels&&addlabels)) {
    ShowError(msg+"setting data set numbers in <", IndexFullName(i),
              "> failed");
    return ret;
  }

  DataBase *db = CheckDB();

  bool useneg = neg!="";

  const FloatVectorSet& data = TsSom(i).Data();
  ground_truth not_found = select;
  FloatVectorSet set;
  
  for (int j=0; j<data.Nitems(); j++) {
    int idx = data[j].Number();
    if (select[idx]==1 || (useneg && select[idx]==-1)) {
      set.AppendCopy(data[j]);
      if (not_found[idx]!=select[idx]) {
        stringstream ss;
        ss << TsSom(i).Name() << " j=" << j << " idx=" << idx
           << " useneg=" << useneg << " pos=<" << pos << ">" 
           << " not_found[idx]=" << (int)not_found[idx]
           << " != select[idx]=" << (int)select[idx] << " "
           << db->ObjectDump(idx);
        ShowError(msg+ss.str());
        return ret;
      }
    }
    not_found[idx] = 0;
  }

  size_t nnfound = not_found.positives()+useneg*not_found.negatives();
  if (nnfound) {
    ShowError(msg+ToStr(nnfound)+" vectors not found");
    return ret;
  }

  int setsize_was = set.Nitems();

  /// weird still...
  string fname;
  if (fname.length())
    fname += "-";
  fname += IndexFullName(i);

  if (!DataPreProcessing(set, fname)){
    ShowError(msg+"DataPreProcessing() failed");
    return ret;
  }

  if (set.Nitems()!=setsize_was) {
    ShowError(msg+"set size changed in DataPreProcessing()");
    return ret;
  }

  map<size_t,int> idxmap;
  for (int j=0; j<set.Nitems(); j++) {
    size_t idx = set[j].Number();
    if (select[idx]==0 || (!useneg && select[idx]==-1)) {
      ShowError(msg+"strange vector number");
      return ret;
    }
    if (idxmap.find(idx)!=idxmap.end()) {
      ShowError(msg+"duplicate vector number");
      return ret;
    }
    idxmap[idx] = j;
  }

  size_t vl = set.VectorLength();
  for (size_t j=0; j<select.size(); j++)
    if (select[j]==1 || (useneg && select[j]==-1)) {
      const FloatVector& v = set[idxmap[j]];
      const float *fv = v;
      ret.push_back(cox::knn::lvector_t(vector<float>(fv, fv+vl),
                                        select[j]==1?pos:neg));
    }

  return ret;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::DataPreProcessing(FloatVectorSet& set, string& str,
                                 xmlDocPtr xml) const {
  bool debug_z = true;
  string msg = "Analysis::DataPreProcessing(...,"+str+") : ";

  if (!set.Nitems())
    return ShowError(msg+"empty data set");

  if (!ComponentOrder(set, str))
    return ShowError(msg+"ComponentOrder() failed");

  stringstream nsstr;
  nsstr << set.Nitems() << "x" << set.VectorLength();
  string d = "\nOriginal data set size: "+nsstr.str();
  d += "\nPreProcessing: "+preprocess+"\n";

  bool ok = true;
  string pp = preprocess;
  while (ok && pp!="") {
    string m, arg;
    bool m_ok = false;

    if (CheckSwitch("none", pp, m, str)) {
      m_ok = true;

    } else if (CheckSwitch("components%s", pp, m, str, &arg)) {
      IntVector comps;
      if (arg.find('.')!=string::npos) {
        int a, b;
        if (sscanf(arg.c_str(), "%d.%d", &a, &b)!=2 || a<0 || b<=a)
          return ShowError(msg+"parsing components%d.%d failed");
        if (set.VectorLength()%b)
          return ShowError(msg+"vector length dot divisible by b");
        comps.Lengthen(set.VectorLength()/b);
        for (int i=0; i<comps.Length(); i++)
          comps[i] = a*set.VectorLength()/b+i;

      } else
        return ShowError(msg+"no / in components");

      m_ok = set.Components(comps);
      d += "  components"+arg+" = selection of components\n";

    } else if (CheckSwitch("z", pp, m, str)) {
      m_ok = set.Normalize(debug_z, xml);
      d += "  z = Z-normalization to (0,1)-normal\n";

    } else if (CheckSwitch("polar", pp, m, str)) {
      int n = set.PolarizeComponents();
      m_ok = n>0;
      stringstream nstr;
      nstr << n;
      d += "  polar = "+nstr.str()+" components have been polarized\n";

    } else if (CheckSwitch("nonzero", pp, m, str)) {
      int nold = set.Nitems();
      m_ok = set.RemoveZeroVectors();
      WriteLog("Removed "+ToStr(nold-set.Nitems())+" zero vectors");
      stringstream nstr;
      nstr << nold-set.Nitems();
      d += "  nonzero = zero vectors (n="+nstr.str()+") have been removed\n";

    } else if (CheckSwitch("001", pp, m, str)) {
      m_ok = set.MapNegativeZeroPositive(0.0, 0.0, 1.0);
      d += "  001 = negative values mapped to zero, positives to one\n";
      
    } else if (CheckSwitch("pca%d", pp, m, str, &arg)) {
      int l;
      stringstream(arg) >> l;
      m_ok = PerformPCA(set, l);
      d += "  pca"+arg+" = principal componenents\n";

    } else if (CheckSwitch("noise%f", pp, m, str, &arg)) {
      float stddev;
      stringstream(arg) >> stddev;
      m_ok = AddGaussianNoise(set, stddev);
      d += "  noise"+arg+" = addifive gaussian noise\n";
      
    } else if ((pp.substr(0, 3)=="min" || pp.substr(0, 3)=="max")
               && atoi(pp.substr(3).c_str())>0) {
      bool is_min = pp.substr(0, 3)=="min";
      size_t i = pp.substr(3).find_last_of("0123456789")+1;
      int v = atoi(pp.substr(3).c_str());
      string r = pp.substr(3+i);
      if (r!="" && r.substr(0, 1)!="-")
        goto unknown;
      m = pp.substr(0, 3+i);
      str += "-"+m;
      pp = r.substr(0, 1)=="-" ? r.substr(1) : "";
      int nold = set.VectorLength();
      IntVector idx;
      m_ok = is_min ? set.RemoveComponentsSumBelow(v, idx) :
        set.RemoveComponentsSumAbove(v, idx);
      stringstream nstr;
      nstr << nold-set.VectorLength();
      d += "  "+m+" = removed columns (n="+nstr.str()+") with too "+
        (is_min?"rare":"frequent")+" ones\n";

    } else {
    unknown:
      return ShowError(msg+"preprocess==\""+pp.c_str()+"\" unknown");
    }
    
    WriteLog("DataPreProcessing() <", m, "> ", m_ok ? "performed" : "FAILED");
    ok &= m_ok;
  }

  if (ok) {
    stringstream nstr;
    nstr << set.Nitems() << "x" << set.VectorLength();
    d += "Data set size after PreProcessing: " + nstr.str();
    string dd = set.Description() ? set.Description() : "";
    set.Description((dd+d).c_str());
  }

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::CheckSwitch(const string& swin, string& pp,
                                   string& m, string& str, string *arg) const {
  string swtmp = swin;
  size_t ap = swtmp.find("%"); // ie. %d or %f etc.
  if (ap!=string::npos) {
    if (!arg)
      return ShowError("Analysis::CheckSwitch() failed 1");
    swtmp.erase(ap);
  }
  else if (arg)
    return ShowError("Analysis::CheckSwitch() failed 2");

  if (pp.find(swtmp)!=0)
    return false;

  size_t i = swtmp.size();
  if (arg) {
    size_t l = pp.find_first_not_of("0123456789.", i);
    if (l==string::npos)
      l = pp.size();
    if (l==i)
      return ShowError("Analysis::CheckSwitch() failed 3");

    *arg = pp.substr(i, l-i);  // this might be delayed ...
    i = l;
  }
  string swarg = pp.substr(0, i);

  size_t j = i;
  if (pp.size()!=j) {
    if (pp.substr(j, 1)!="-")
      return ShowError("Analysis::CheckSwitch() failed 4");
    else
      j++;
  }

  m = swarg;
  str += string("-")+swarg;
  pp.erase(0, j);
  
  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::PerformPCA(FloatVectorSet& set, int len) const {
#ifndef _MSC_VER
  using namespace cox;

  typedef float real_t;
  typedef vector<real_t> vec_t;
  typedef labeled<vec_t> lvec_t;
  typedef list<lvec_t> data_t;
  data_t data;

  for (int i=0; i<set.Nitems(); i++) {
    const FloatVector& v = set[i];
    const float *fp = v;
    data.push_back(lvec_t(fp, fp+v.Length(), v.Label()));
  }
  WriteLog("Copied data for PCA");

  typedef matrix<real_t> mat_t;
  typedef list<vec_t> veclist_t;
  typedef subspace<real_t> ss_t;

  pair<vec_t,mat_t> mean_cov = cox::stat::mean_covariance(data);

  WriteLog("Calculated mean and covariance");
  
  pair<veclist_t,vec_t> evec_eval = mean_cov.second.eigenvectors(len);
  WriteLog("Calculated eigenvalues and vectors");
    
  ss_t ss = ss_t(mean_cov.first,
                 mat_t(evec_eval.first.begin(), evec_eval.first.end()),
                 evec_eval.second);
  
  int j = 0;
  for (data_t::const_iterator v=data.begin(); v!=data.end(); v++) {
    lvec_t pv = lvec_t(ss.projection_coeff(*v), v->label());
    FloatVector& fv = set[j++];
    fv.Length(pv.size());
    fv = &pv.front();
  }
  WriteLog("Calculated PCA projected vectors");
#endif // _MSC_VER

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::AddGaussianNoise(FloatVectorSet& set, float stddev) const {
  for (int i=0; i<set.Nitems(); i++) {
    FloatVector& v = set[i];
    for (int j=0; j<v.Length(); j++)
      v[j] += GaussianNoise(0, stddev); 
  }
  WriteLog("Added (0,"+ToStr(stddev)+") Gaussian noise");
  return true;
}

///////////////////////////////////////////////////////////////////////////////

float Analysis::GaussianNoise(float mean, float stddev) {
  static const int n = 100;
  static const float mul = sqrt(12.0*n);

  static int seed = 0;

  FloatVector v = RandVar::UniformZeroOne(n, seed++);
  float s = float(v.Sum())/n-0.5;
  float m = s*mul;
  float r = stddev*m+mean;
  
  //cout << "GaussianNoise() : " << s << " -> " << m << " -> " << r << endl;

  return r;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ComponentOrder(FloatVectorSet& set, string& str) const {
  if (!componentorder.length())
    return true;

  char allinone[100];
  sprintf(allinone, "0-%d:*", set.VectorLength()-1);

  bool ao = false, px = true;
  string co = componentorder, add;
  if (co.substr(co.length()-2)=="-1") {
    co = co.substr(0, co.length()-2);
    add = "1";
    px = false;

  } else if (co.substr(co.length()-2)=="-0") {
    co = co.substr(0, co.length()-2);
    add = "0";
    ao = true;
    px = false;
  }

  if (co=="dispersal-all") {
    if (!ao && set.VectorLength()!=198 && set.VectorLength()!=200) {
      ShowError("Analysis::ComponentOrder() VectorLength()!=198|200 ",
                ToStr(set.VectorLength()));
      return false;
    }
    str += "-Dall"+add;
    char l200[] = "0-49:*,50-99:*,100-149:*,150-199:*";
    char l198[] = "0-49:*,50-99:*,100-147:*,148-197:*";
    const char *d = ao ? allinone : set.VectorLength()==200?l200:l198;
    return ComponentOrderDispersal(set, d, px);
  }

  if (co=="dispersal-per") {
    if (!ao && set.VectorLength()!=198 && set.VectorLength()!=200) {
      ShowError("Analysis::ComponentOrder() VectorLength()!=198|200 ",
                ToStr(set.VectorLength()));
      return false;
    }
    str += "-Dper"+add;
    char l200[] = "0-49:city,50-99:open,100-149:indoor,150-199:closed";
    char l198[] = "0-49:city,50-99:open,100-147:indoor,148-197:closed";
    const char *d = ao ? allinone : set.VectorLength()==200?l200:l198;
    return ComponentOrderDispersal(set, d, px);
  }

  if (co=="dispersal-oth") {
    if (!ao && set.VectorLength()!=198 && set.VectorLength()!=200) {
      ShowError("Analysis::ComponentOrder() VectorLength()!=198|200 ",
                ToStr(set.VectorLength()));
      return false;
    }
    str += "-Doth"+add;
    char l200[] = "0-49:~city,50-99:~open,100-149:~indoor,150-199:~closed";
    char l198[] = "0-49:~city,50-99:~open,100-147:~indoor,148-197:~closed";
    const char *d = ao ? allinone : set.VectorLength()==200?l200:l198;
    return ComponentOrderDispersal(set, d, px);
  }

  if (co=="dispersal-rat") {
    if (!ao && set.VectorLength()!=198 && set.VectorLength()!=200) {
      ShowError("Analysis::ComponentOrder() VectorLength()!=198|200 ",
                ToStr(set.VectorLength()));
      return false;
    }
    str += "-Drat"+add;
    char l200[] = "0-49:~city/city,50-99:~open/open,"
      "100-149:~indoor/indoor,150-199:~closed/closed";
    char l198[] = "0-49:~city/city,50-99:~open/open,"
      "100-147:~indoor/indoor,148-197:~closed/closed";
    const char *d = ao ? allinone : set.VectorLength()==200?l200:l198;
    return ComponentOrderDispersal(set, d, px);
  }

  if (co=="dispersal-frac") {
    if (!ao && set.VectorLength()!=198 && set.VectorLength()!=200) {
      ShowError("Analysis::ComponentOrder() VectorLength()!=198|200 ",
                ToStr(set.VectorLength()));
      return false;
    }
    str += "-Dfrac"+add;
    char l200[] = "0-49:*/city,50-99:*/open,100-149:*/indoor,150-199:*/closed";
    char l198[] = "0-49:*/city,50-99:*/open,100-147:*/indoor,148-197:*/closed";
    const char *d = ao ? allinone : set.VectorLength()==200?l200:l198;
    return ComponentOrderDispersal(set, d, px);
  }

  if (co=="dispersal-ofrac") {
    if (!ao && set.VectorLength()!=198 && set.VectorLength()!=200) {
      ShowError("Analysis::ComponentOrder() VectorLength()!=198|200 ",
                ToStr(set.VectorLength()));
      return false;
    }
    str += "-Dofrac"+add;
    char l200[] = "0-49:~city/*,50-99:~open/*,"
      "100-149:~indoor/*,150-199:~closed/*";
    char l198[] = "0-49:~city/*,50-99:~open/*,"
      "100-147:~indoor/*,148-197:~closed/*";
    const char *d = ao ? allinone : set.VectorLength()==200?l200:l198;
    return ComponentOrderDispersal(set, d, px);
  }

  ShowError("Analysis::ComponentOrder() order <", componentorder,
            "> not known");

  return false;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ComponentOrderDispersal(FloatVectorSet& set,
                                               const string& def,
                                               bool pmax) const {
  FloatVector disp(set.VectorLength());

  const char *ptr = def.c_str();
  while (*ptr) {
    char tmp[10000];
    strcpy(tmp, ptr);
    char *com = strchr(tmp, ',');
    if (com)
      *com = 0;
    ptr += strlen(tmp)+(com!=NULL);

    char errmsg[20000];
    sprintf(errmsg, "Analysis::ComponentOrderDispersal() <%s> ", tmp);

    int cb, ce, n = 0;
    if (sscanf(tmp, "%d-%d:%n", &cb, &ce, &n)!=2)
      return ShowError(errmsg, "failed");

    if (!disp.IndexOK(cb) || !disp.IndexOK(ce))
      return ShowError(errmsg, "bad component index");

    FloatVector dpart = DispersalCalculus(set, tmp+n, cb, ce);
    if (!dpart.Length())
      return ShowError(errmsg, "calculus failed");

    // dpart.Dump(Simple::DumpLong);
    if (pmax) {
      double m = dpart.Maximum();
      if (m)
        dpart /= m;
    }

    disp += dpart;
  }
  // disp.Dump(Simple::DumpLong);

  IntVector idx(set.VectorLength());
  idx.SetIndices();
  disp.SortDecreasingly(idx);
  // disp.Dump(Simple::DumpLong);
  // idx.Dump(Simple::DumpLong);

  // set[0].Dump(Simple::DumpLong);
  set.ArrangeComponents(idx);
  // set[0].Dump(Simple::DumpLong);

  WriteLog("ComponentOrder <dispersal> set");

  return true;
}

///////////////////////////////////////////////////////////////////////////////

FloatVector Analysis::DispersalCalculus(const FloatVectorSet& set,
                                                const char *str,
                                                int cb, int ce) const {
  const char *slash1 = strchr(str, '/');
  if (slash1) {
    char tmp[1000];
    strcpy(tmp, str);
    char *slash = strchr(tmp, '/');
    *slash = 0;
    FloatVector nom = DispersalCalculus(set, tmp,     cb, ce);
    FloatVector den = DispersalCalculus(set, slash+1, cb, ce);
    if (!nom.Length() || !den.Length())
      return FloatVector();

    FloatVector ret(nom.Length());
    for (int i=0; i<ret.Length(); i++)
      if (den[i])
        ret[i] = nom[i]/den[i];

    return ret;
  }

  FloatVectorSet part;
  
  if (isdigit(*str)) {
    int vb, ve;
    if (sscanf(str, "%d-%d", &vb, &ve)!=2) {
      ShowError("Analysis::DispersalCalculus() failed <", str, ">");
      return FloatVector();
    }

    if (!set.IndexOK(vb) || !set.IndexOK(ve)) {
      ShowError("Analysis::DispersalCalculus() bad vector index in <",str,">");
      return FloatVector();
    }
    part.AppendSharedRange(set, vb, ve);

  } else {

    if (strcmp(str, "*")) {
      ground_truth cls = GroundTruthExpression(str, query->Target(),-1,expand);
      FloatVectorSet bylabel = set.SubsetByIndex(cls.indices(1));
      if (!bylabel.Nitems()) {
        ShowError("Analysis::DispersalCalculus() empty class <", str, ">");
        return FloatVector();
      }
      part.AppendShared(bylabel);

    } else
      part.AppendShared(set);
  }
  
  IntVector idx(set.VectorLength());
  idx.SetRange(cb, ce, 1);

  return Dispersal(part, idx);
}

///////////////////////////////////////////////////////////////////////////////

FloatVector Analysis::Dispersal(const FloatVectorSet& set,
                                        const IntVector& idx) const {
  if (set.VectorLength()!=idx.Length()) {
    ShowError("Analysis::Dispersal() vector length differ");
    return FloatVector();
  }

  simple::StatVarVector sv(set.VectorLength());

  for (int i=0; i<sv.Length(); i++)
    if (idx[i])
      for (int j=0; j<set.Nitems(); j++) {
//         cout << "Analysis::Dispersal() " << i << " " << set[j].Label()
//              << " " << set[j].Number() << endl; 
        sv[i] += set[j][i];
      }

  // sv[0].Dump();
  // cout << sv[0].Variance() << endl;

  // return StatVar::StandDev(sv);

  return simple::StatVar::Variance(sv);
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result::analyse_result(const vector<float>& v)
  : recall(v.size()), precision(v.size()), avgprecision(v.size()),
    instprecision(v.size()), maxpr(v.size()), apriori(v.size()),
    false_pos(v.size()), true_pos(v.size()) {

  isok = true;
  tau = tauord = birds = firsthitadv = roc_auc = 0.0; 
  seen = found = firstpos = 0;
  roc_eer = 1.0;
  firsthit = -1;
  rescount = 1;

  ranking = old_ranking = appoint = -1;
  avgprec = old_avgprec = inferredap = -1.0;
  avgprecbl = avgprecadv_a = avgprecadv_g = 0.0;

  mean_inv_rank = 0.0;

  time_real = time_user = time_sys = time_cpu = 0.0;

  rounds = v.size();
  double sum = 0.0, cum = 0.0, apsum = 0.0;
  for (size_t i=0; i<v.size(); i++)
    sum += v[i];

  corr = sum;
  tot  = v.size();
  bias = 0.0;
          
  if (!sum)
    return;

  for (size_t i=0; i<v.size(); i++) {
    cum += v[i];
    recall[i]        = cum/sum;
    precision[i]     = cum/(i+1);
    instprecision[i] = v[i];

    if (v[i])
      apsum += precision[i];
    avgprecision[i]  = apsum/sum;

    // true_pos[i]  = recall[i];
    // false_pos[i] = (1.0+i-cum)/(v.size()-sum); // not checked...

    maxpr[i]         = 0; // obs!
    apriori[i]       = 0; // obs!

    if (v[i] && firsthit==-1) {
      firsthit    = i;
      firsthitadv = Analysis::FirstHitAdv(i, corr, tot);
    }
  }

  set_roc_from_recall(recall, sum, tot);

  if (firsthit==-1)
    firsthit = 0;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::operator==(const
                                          Analysis::analyse_result& a) const {
  return
    isok == a.isok  &&  corr == a.corr  &&  tot == a.tot  && bias == a.bias &&
    rescount == a.rescount  &&  rounds == a.rounds  &&  seen == a.seen  &&  
    found == a.found  &&  firstpos == a.firstpos  &&
    ranking == a.ranking  &&  old_ranking == a.old_ranking  &&  
    appoint == a.appoint &&
    avgprec == a.avgprec  &&  old_avgprec == a.old_avgprec  &&
    avgprecbl == a.avgprecbl  &&  avgprecadv_a == a.avgprecadv_a  &&
    avgprecadv_g == a.avgprecadv_g  &&
    tau == a.tau  &&  tauord == a.tauord &&
    birds == a.birds  &&  firsthit == a.firsthit  &&
    firsthitadv == a.firsthitadv  &&
    recall == a.recall && precision == a.precision  && 
    avgprecision == a.avgprecision  &&
    inferredap == a.inferredap &&
    instprecision == a.instprecision  &&  
    maxpr == a.maxpr  &&  apriori == a.apriori  && 
    false_pos == a.false_pos  &&  true_pos == a.true_pos  &&  
    minaccrec == a.minaccrec && threshold == a.threshold &&
    roc_eer == a.roc_eer  &&  roc_auc == a.roc_auc  &&
    mean_inv_rank  == a.mean_inv_rank &&
    time_real == a.time_real && time_user == a.time_user &&
    time_sys == a.time_sys && time_cpu == a.time_cpu &&
    optval == a.optval  &&  params == a.params  &&  
    batchloop == a.batchloop  &&  sortval == a.sortval  &&
    best == a.best && sub_result == a.sub_result;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::read(const string& nin) {
  string err = "analyse_result::read("+nin+") : ";

  clear();

  vector<string> nparts = SplitInSomething("|", false, nin);
  string n = nparts.size() ? nparts[0] : "";

  XmlDom xml = XmlDom::Parse(n);
  if (!xml.DocOK())
    return ShowError(err+"XmlDom::Parse() failed");

  XmlDom r = xml.Root();
  if (!r)
    return ShowError(err+"XmlDom::Root() failed");
  
  if (!from_xml(r))
    return ShowError(err+"from_xml() failed");

  if (nparts.size()>1)
    params = nparts[1];
  if (nparts.size()>2)
    params += "|"+nparts[2];

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::from_xml(XmlDom& r) {
  string err = "analyse_result::from_xml() : ";

  if (r.NodeName()!="analyse_result")
    return ShowError(err+"node is not analyse_result");

  bool ok = true;
  for (XmlDom e = r.FirstChild(); ok && e; e=e.Next())
    if (e.IsElement()) {
      const string n = e.NodeName();
      if      (n=="isok")            isok            = e.Value<bool>();
      else if (n=="corr")            corr            = e.Value<double>();
      else if (n=="tot")             tot             = e.Value<double>();
      else if (n=="bias")            bias            = e.Value<double>();
      else if (n=="rescount")        rescount        = e.Value<int>();
      else if (n=="rounds")          rounds          = e.Value<int>();
      else if (n=="seen")            seen            = e.Value<int>();
      else if (n=="found")           found           = e.Value<int>();
      else if (n=="firstpos")        firstpos        = e.Value<int>();
      else if (n=="appoint")         appoint         = e.Value<int>();
      else if (n=="ranking")         ranking         = e.Value<int>();
      else if (n=="old_ranking")     old_ranking     = e.Value<int>();
      else if (n=="avgprec")         avgprec         = e.Value<float>();
      else if (n=="old_avgprec")     old_avgprec     = e.Value<float>();
      else if (n=="avgprecbl")       avgprecbl       = e.Value<float>();
      else if (n=="avgprecadv")      avgprecadv_g    = e.Value<float>();
      else if (n=="avgprecadv_a")    avgprecadv_a    = e.Value<float>();
      else if (n=="avgprecadv_g")    avgprecadv_g    = e.Value<float>();
      else if (n=="tau")             tau             = e.Value<float>();
      else if (n=="tauord")          tauord          = e.Value<float>();
      else if (n=="birds")           birds           = e.Value<float>();
      else if (n=="firsthit")        firsthit        = e.Value<float>();
      else if (n=="firsthitadv")     firsthitadv     = e.Value<float>();
      else if (n=="firsthitadv_geo") firsthitadv_geo = e.Value<float>();
      else if (n=="roc_eer")         roc_eer         = e.Value<float>();
      else if (n=="roc_auc")         roc_auc         = e.Value<float>();
      else if (n=="mean_inv_rank")   mean_inv_rank   = e.Value<float>();
      else if (n=="time_real")       time_real       = e.Value<float>();
      else if (n=="time_user")       time_user       = e.Value<float>();
      else if (n=="time_sys")        time_sys        = e.Value<float>();
      else if (n=="time_cpu")        time_cpu        = e.Value<float>();
      else if (n=="optval")          optval          = e.Value<float>();
      else if (n=="sortval")         sortval         = e.Value<float>();
      else if (n=="inferredap")      inferredap      = e.Value<float>();
      else if (n=="batchloop")       batchloop       = e.Value<int>();
      else if (n=="params")          params          = e.Value<string>();
      else if (n=="sub_result_type") sub_result_type = e.Value<string>();
      else if (n=="recall")          recall          = e.VectorValue<float>();
      else if (n=="precision")       precision       = e.VectorValue<float>();
      else if (n=="avgprecision")    avgprecision    = e.VectorValue<float>();
      else if (n=="instprecision")   instprecision   = e.VectorValue<float>();
      else if (n=="maxpr")           maxpr           = e.VectorValue<float>();
      else if (n=="apriori")         apriori         = e.VectorValue<float>();
      else if (n=="false_pos")       false_pos       = e.VectorValue<float>();
      else if (n=="true_pos")        true_pos        = e.VectorValue<float>();
      else if (n=="threshold")       threshold       = e.VectorValue<float>();
      else if (n=="minaccrec")       minaccrec       = e.VectorValue<float>();
      else if (n=="best") {
        best.clear();
        for (XmlDom s = e.FirstChild(); ok && s; s=s.Next())
          if (s.IsElement()) {
            if (s.NodeName()=="object") {
              size_t idx = atoi(s.Property("idx").c_str());
              double val = atof(s.Property("val").c_str());
              best.push_back(make_pair(idx, val));
            }
            else ok = ShowError(err+"failed with ["+s.Dump()+"]");
	  }

      } else if (n=="sub_result") {
        for (XmlDom s = e.FirstChild(); ok && s; s=s.Next())
          if (s.IsElement()) {
            sub_result.push_back(analyse_result());
            ok = sub_result.back().from_xml(s);
          }

      } else ok = ShowError(err+"failed with ["+e.Dump()+"]");
    }

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::write(const string& n) const {
  bool test = false; // true;

  // XmlDom xml = XmlDom::Doc("picsom:analyse_result");
  XmlDom xml = Connection::XMLstub(true, false);

  if (!to_xml(xml, true))
    return false;

  if (!xml.Write(n, true))
    return false;

  if (!test || *this==analyse_result(n))
    return true;

  // analyse_result xx(n);

  return ShowError("analyse_result::write("+n+") failed to compare");
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::to_xml(XmlDom& xml, bool to_root) const {
  string n     = "analyse_result";
  string nsref = "http://www.cis.hut.fi/picsom/ns";
  string nsn   = "picsom";
  string nsp   = ""; // was "picsom:"; 
  //nsref = nsn = nsp = "";

  XmlDom rec = to_root ? xml.Root(nsp+n, nsref, nsn) : xml.Element(n);

  size_t acc = 9;

  rec.Element("isok", isok);
  rec.Element("corr", corr, acc);
  rec.Element("tot", tot, acc);
  rec.Element("bias", bias, acc);
  rec.Element("rescount", rescount);
  rec.Element("rounds", rounds);
  rec.Element("seen", seen);
  rec.Element("found", found);
  rec.Element("firstpos", firstpos);
  rec.Element("ranking", ranking);
  rec.Element("old_ranking", old_ranking);
  rec.Element("avgprec", avgprec, acc);
  rec.Element("old_avgprec", old_avgprec, acc);
  rec.Element("avgprecbl", avgprecbl, acc);
  rec.Element("avgprecadv_a", avgprecadv_a, acc);
  rec.Element("avgprecadv_g", avgprecadv_g, acc);
  rec.Element("appoint", appoint);
  rec.Element("tau", tau, acc);
  rec.Element("tauord", tauord, acc);
  rec.Element("birds", birds, acc);
  rec.Element("firsthit", firsthit, acc);
  rec.Element("firsthitadv", corr/firsthitadv, acc);
  rec.Element("firsthitadv_geo", exp(double(firsthitadv_geo/corr)), acc);
  rec.Element("roc_eer", roc_eer, acc);
  rec.Element("roc_auc", roc_auc, acc);
  rec.Element("mean_inv_rank", mean_inv_rank, acc);
  rec.Element("time_real", time_real, acc);
  rec.Element("time_user", time_user, acc);
  rec.Element("time_sys",  time_sys, acc);
  rec.Element("time_cpu",  time_cpu, acc);
  rec.Element("optval", optval, acc);
  rec.Element("sortval", sortval, acc);
  rec.Element("inferredap", inferredap, acc);
  rec.Element("batchloop", batchloop);
  rec.Element("params", params);

  to_xml(rec, "recall", recall, acc);
  to_xml(rec, "precision", precision, acc);
  to_xml(rec, "avgprecision", avgprecision, acc);
  to_xml(rec, "instprecision", instprecision, acc);
  to_xml(rec, "maxpr", maxpr, acc);
  to_xml(rec, "apriori", apriori, acc);
  to_xml(rec, "false_pos", false_pos, acc);
  to_xml(rec, "true_pos", true_pos, acc);
  to_xml(rec, "threshold", threshold, acc);
  to_xml(rec, "minaccrec", minaccrec, acc);

  to_xml(rec, "best", best, acc);

  rec.Element("sub_result_type", sub_result_type);

  XmlDom sub = rec.Element("sub_result");

  bool ok = true;
  for (list<analyse_result>::const_iterator i = sub_result.begin();
       i!=sub_result.end() && ok; i++)
    ok = i->to_xml(sub, false);

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::to_xml(XmlDom& rec, const string& n,
                                      const vector<float>& v,
                                      size_t acc) const {
  stringstream ss;
  if (acc) {
    ss.precision(acc);
    ss << scientific;
  }
  for (size_t i=0; i<v.size(); i++)
    ss << (i?" ":"") << v[i];

  XmlDom e = rec.Element(n, ss.str());
  e.Prop("size", v.size());

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::to_xml(XmlDom& rec, const string& n,
                                      const list<pair<size_t, double> >& v,
                                      size_t acc) const {
  XmlDom e = rec.Element(n);
  e.Prop("size", v.size());

  for (list<pair<size_t, double> >::const_iterator i=v.begin();
       i!=v.end(); i++) {
    XmlDom o = e.Element("object");
    o.Prop("idx", i->first);

    stringstream ss;
    if (acc) {
      ss.precision(acc);
      ss << scientific;
    }
    ss << i->second;

    o.Prop("val", ss.str());
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::analyse_result::dump(ostream& os, const string& h, bool rec,
                                    bool det) const {
  os << "[" << h << "] : " << rescount << " "
     << batchloop << " " << optval
     << " <" << params << ">" << endl;

  if (!rec)
    return os.good();

  bool ok = os.good();
  size_t j = 0;
  for (list<analyse_result>::const_iterator i=sub_result.begin();
       ok && i!=sub_result.end(); i++, j++) {
    stringstream ss;
    ss << h << (h!=""?".":"") << j;
    ok = i->dump(os, ss.str(), rec, det);
  }

  return ok;
}

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::analyse_result::set_roc_from_hits(const vector<float>& rvec,
						   double csum, double dbsize,
						   size_t bias) {
    vector<double> recall(rvec.size()-bias);
    double cum = 0;
    for (size_t i=0; i<recall.size(); i++)
      recall[i] = (cum+=rvec[i+bias])/(csum-bias);

    if (cum>csum-bias || rvec.size()>dbsize || dbsize<csum ||
	(rvec.size()==dbsize && cum!=csum-bias))
      ShowError("set_roc_from_hits() error?");

    set_roc_from_recall(recall, csum-bias, dbsize-bias);
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::analyse_result::set_roc_from_recall(const vector<double>& rvec,
						     double csum, double dbsz) {
    true_pos  = vector<float>(rvec.begin(), rvec.end());
    false_pos = vector<float>(true_pos.size());
    // cout << "setting ROC: csum=" << csum << " dbsz=" << dbsz
    //      <<" fp.size()=" << false_pos.size() << endl;
    for (size_t i=0; i<false_pos.size(); i++)
      false_pos[i] = (1.0+i-true_pos[i]*csum)/(dbsz-csum);

    if (true_pos.back()==1) {
      set_roc_eer();
      set_roc_auc();
    }
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::analyse_result::set_roc_eer() {
    if (rescount==0) {
      roc_eer = 1.0;
      return;
    }

    if (rescount!=1)
      ShowError("analyse_result::set_roc_eer() : not checked with rescount!=1");

    size_t i = 1;
    for (; i<false_pos.size(); i++)
      if (false_pos[i]-(rescount-true_pos[i])>=0)
	break;

    if (i==false_pos.size()) {
      ShowError("analyse_result::set_roc_eer() : error");
      roc_eer = 1.0;
      return;
    }

    typedef pair<float,float> xy_t;
    xy_t a(false_pos[i-1], rescount-true_pos[i-1]);
    xy_t b(false_pos[i],   rescount-true_pos[i]);
    xy_t c = b;

    float x = (a.first*b.second-b.first*a.second)/
      (a.first-b.first-a.second+b.second);
    xy_t d(x, x);

    bool debug = false;
    for (int j=0; j<100; j++) {
      if (debug)
	cout << j << "   "
	     << a.first << " " << a.second << "   "
	     << c.first << " " << c.second << "   "
	     << b.first << " " << b.second << "   d = "
	     << d.first << " " << d.second << endl;

      if (c.first==c.second)
	break;

      c = xy_t((a.first+b.first)/2, (a.second+b.second)/2);
      if (c.first<c.second)
	a = c;
      else
	b = c;
    }

    roc_eer = (c.first+c.second)/(2*rescount);
  }

  ///////////////////////////////////////////////////////////////////////////

  void Analysis::analyse_result::set_roc_auc() {
    if (rescount==0) {
      roc_auc = 0.0;
      return;
    }

    double sum = 0;
    for (size_t i = 0; i<false_pos.size(); i++)
      sum += (false_pos[i]-(i?false_pos[i-1]:0))*
	(true_pos[i]+(i?true_pos[i-1]:0))/2;

    roc_auc = sum/rescount;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseQuery(const vector<string>& args) {
    if (!GetDataBase()) {
      SetXmlResultError("database not set");
      return false;
    }

    if (false && !CheckQuery()->HasAlgorithmAndFeatures()) { // was !Nindices()
      SetXmlResultError("algorithm or indices not set");
      return false;
    }

    if (Target()==target_no_target) {
      SetXmlResultError("target not set");
      return false;
    }

    if (query->Identity()=="") { // from Connection::SoapServer_execute()
      query->SetIdentity();
      query->SetLastAccessTimeNow();
      // query->SetAnalysis(NULL); // this was perhaps needed at some point?
      Picsom()->AppendQuery(query, true);
      query->CbirStages();

    } else if (args.size()) {
      Query *old_query = query;
      query = old_query->CreateChild(NULL);
      // to copy positive, negative, viewclass (not really needed now...)
      // query->CopySome(*old_query, false, true, false);

      vector<string> oi = SplitInCommas(args[0]);
      for (size_t i=0; i<oi.size(); i++)
	query->ProcessObjectInfo(oi[i].substr(0, 1), oi[i].substr(1), true);

      query->CbirStages();
    }

    ErfRelevancesToROC();

    InitializeXmlResult(true);
    XmlDom xml_root = xml_result.Root();
    GetQuery()->AddToXMLqueryinfo(xml_root, true, false, false, false, NULL);

    if (Query::DebugLists()) {
      GetQuery()->ShowObjectListsRecursively();
    }

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseObsProb(const vector<string>& args) {
  list<string> p = GetDataBase()->SplitClassNames(classname);

  string classname_saved  = classname;
  string matlabname_saved = MatlabName();
  string mname = MatlabName();
  if (mname!="")
    mname += "_";

  bool ok = true;

  ground_truth train(classname_saved), test(testsetname);

  for (size_t m=0; m<Nindices(); m++) {
    TsSom(m).ReadDataFile();

    if (!TsSom(m).SetDataSetNumbers(false, false)) {
      ShowError("Setting data set numbers in <", IndexFullName(m), "> failed");
      ok = false;
      continue;
    }

    string mstr;
    query->WriteAnalyseVariablesOld("ObsProb", m, &train, &test, 0, false, mstr);

    string matlabname_permap = mname+IndexFullName(m);

    if (p.size()==1) {
      MatlabName(matlabname_permap+"_"+classname);
      if (AnalyseObsProbPerClass(m, args).empty())
        return ShowError("AnalyseObsProb() : failed with ", IndexFullName(m));
      continue;
    }
    
    analyse_result finalresult;

    for (list<string>::const_iterator ip=p.begin(); ip!=p.end(); ip++) {
      classname = *ip;
      MatlabName(matlabname_permap+"_"+classname);
      analyse_result res = AnalyseObsProbPerClass(m, args);
      if (res.empty())
        return ShowError("AnalyseObsProb() : per class <", *ip,
                         "> failed with ", IndexFullName(m));
      
      AddToResult(res, finalresult);
    }

    MatlabName(matlabname_permap);
    if (!finalresult.empty())
      WriteAnalyseResults("ObsProb", finalresult, mstr, true, true);
  }
  
  classname  = classname_saved;
  MatlabName(matlabname_saved);

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseObsProbPerClass(int m, const vector<string>&) {
  analyse_result tres;

  ground_truth correct = GroundTruthExpression(classname, query->Target(), -1,
                                               expand);
  if (!correct.NumberOfEqual(1)) {
    ShowError("AnalyseObsProbPerClass() : empty ground truth <",
              classname, ">");
    return tres;
  }

  ground_truth tested = TestSet(correct, query->Target(), -1);

  int tot = tested.NumberOfEqual(1);
  if (!tot) {
    ShowError("AnalyseObsProbPerClass() : empty ground truth <",
              testsetname, ">");
    return tres;
  }

  string mstr;
  query->WriteAnalyseVariablesOld("ObsProb", m, &correct,
                               &tested, 0, false, mstr);

  //Tic(tt, "CalculateDataBaseSelfDots");
  // TsSom(0).CalculateDataBaseSelfDots();
  //Tac(tt, "CalculateDataBaseSelfDots");

  /*
  cout << "HasLinpack()=" << HasLinpack() << endl;
  cout << "UseLinpack()=" << UseLinpack() << endl;
  cout << "HasSelfDot()=" << data[0].HasSelfDot() << endl;
  */

  const DataBase *db = CheckDB();
  ground_truth rest_corr = db->RestrictionGT().TernaryAND(correct);
  int ncorr = rest_corr.NumberOfEqual(1);

  int idxlen = -1; // obs! vague logic
  FloatVectorSet data;
  target_type tt = target_any_target; // obs! added when a type was required...
  if (db->RestrictionSize(tt)==DataBaseSize()) {
    data = TsSom(m).Data();
    idxlen = data.Nitems()-1; // obs! vague logic

  } else {
    const FloatVectorSet& all = TsSom(m).Data();
    for (int i=0; i<all.Nitems(); i++)
      if (db->OkWithRestriction(i))
        data.Append(all.Get(i), false);

    idxlen = data.Nitems(); // obs! vague logic
  }

  IntVectorSet idx(idxlen);
  
  IntVector final(idx.VectorLength(), NULL, "");

  vector<float> result_v(idx.VectorLength());
  
  int k=0;
  
  for (int j=0; j<tested.Length(); j++)
    if (tested[j]==1) {
      const FloatVector *vecp = TsSom(m).DataVector(j);
      if (!vecp) {
        ShowError("vecp==NULL");
        continue;
      }
      const FloatVector& vec = *vecp;

      int nncorr = ncorr-db->OkWithRestriction(j);
        
      if (verbose>1)
        cout << "j=" << j << " vec.Label()=" << vec.Label()
             << " vec.Number()=" << vec.Number()
             << " nncorr=" << nncorr << endl;

      IntVector res(idx.VectorLength(), NULL, vec.Label());
      FloatVector dist;
      
      if (simulate=="") {
        // Tic("NearestNeighbors");
        data.NearestNeighbors(vec, res, dist);      
        // Tac("NearestNeighbors");
      }

      int count = 0;
      // Change to 0 and 1 and add to final
      for (int i=0; i<res.Length(); i++) {
        bool r = false;
        int index = 0;

        if (simulate=="") {
          index = data[res[i]].Number();
          r = correct[index]==1;    

        } else if (simulate=="best") {
          r = i<nncorr;
        }

        final[i]    += r;
        result_v[i] += r;
        count       += r;

        if (verbose>2)
          cout << "  i=" << i << " res[i]=" << res[i]
               << " data[res[i]].Label()=" << data[res[i]].Label()
               << " index=" << index << " Label(index)=" << Label(index)
               << " r=" << r << " count=" << count
               << " dist[i]=" << dist[i]
               << endl;
      }
        
      TsSom(m).WriteLog("Calculated distances, class="+classname,
                        " tested="+string(tested.Label()),
                        " found="+ToStr(count)+"/"+ToStr(res.Length()),
                        " round=", ToStr(k)+"/"+ToStr(tot));
      k++;

      if (count!=nncorr)
        ShowError("AnalyseObsProbPerClass() : count!=nncorr count=",
                  ToStr(count), " nncorr=", ToStr(nncorr));

      // if (GetKeyValue("idx"))
      //   idx.AppendCopy(res);    
    }

  string filename = IndexFullName(m)+"."+classname+".obsprob";
  WriteLog("Writing obsprob vector: ", filename);
  final.Write(filename);

  if (k) {
    vector<float> mresult = multiply(result_v, float(1.0/k));
    tres = analyse_result(mresult);
    WriteAnalyseResults("ObsProb", tres, mstr, true, true);
  }

  // if (GetKeyValue("idx")) {
  //   WriteLog("Writing idx");
  //   idx.Write("idx");
  // }
  
  // if (GetKeyValue("gnuplot")) {
  //   AppendString(filename, ".gnuplot");
  //   WriteLog("Writing gnuplot output: ", filename);
  //   final.WriteGnuPlot(filename);
  // }

  return tres;
}

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseRetrieve(const vector<string>& /*args*/) {
    string msg = "AnalyseRetrieve() : ";

    if (classname=="")
      return ShowError(msg+"class should be defined");

    if (detections.size()!=1)
      return ShowError(msg+"exactly one detections should be defined");

    DataBase *db = CheckDB();
    list<string> classes = db->SplitClassNames(classname);

    const ground_truth& qr = QueryRestrictionGT();
    vector<size_t> idxs = qr.indices(1);

    analyse_result result;
    for (auto c=classes.begin(); c!=classes.end(); c++) {
      ground_truth corr = db->GroundTruthExpression(*c).TernaryAND(qr);
      if (verbose>1)
	cout << "class <" << *c << "> has " << corr.indices(1).size()
	     << " positives, queryrestriction <" << qr.label()
	     << "> has " << idxs.size() << " positives" << endl;

      string detname = detections[0];
      for (;;) {
	size_t p = detname.find("%c");
	if (p==string::npos)
	  break;
	detname.replace(p, 2, *c);
      }

      multimap<double,size_t> det;
      for (size_t i=0; i<idxs.size(); i++) {
	size_t idx = idxs[i];
	const string& label = db->Label(idx);
	bool dummy = true, allow_incore = true;
	map<string,vector<float> >
	  detects = db->RetrieveOrProduceDetectionData(idx, detname, *c, true,
						       dummy, allow_incore);
	if (detects.size()!=1)
	  return ShowError(msg+" <"+detname+"> for #"+ToStr(idx)+" <"+label+
			   "> is empty");
	if (detects.begin()->second.size()!=1)
	  return ShowError(msg+" <"+detname+"> for #"+ToStr(idx)+" <"+label+
			   "> is "+ToStr(detects.begin()->second.size())+
			   "-dimensional");
	double v = detects.begin()->second[0];
	det.insert(make_pair(v, idx));
      }

      vector<float> h;
      size_t r = 0, npos = 0, nneg = 0;
      for (auto i=det.rbegin(); i!=det.rend(); i++, r++) {
	bool hit = corr[i->second]==1;
	h.push_back(hit?1:0);
	(hit?npos:nneg)++;
	if (verbose>2)
	  cout << r << " #" << i->second << " <" << db->Label(i->second)
	       << "> " << i->first << " " << (hit?"HIT":"MISS") << endl;
      }

      if (verbose>1)
	cout << "  found " << npos << " positives and "
	     << nneg << " negatives" << endl;

      analyse_result res(h);
      res.avgprec = res.avgprecision.back();
      if (verbose>1)
	cout << *c << " " << detections[0] << " AP=" << res.avgprecision.back()
	     << " Prec@50=" <<  res.precision[49] << " AUC=" << res.roc_auc
	     << " n=" << res.corr << endl;
      
      res.params = "class="+*c;
      result.add_sub_result(res);
      AddToResult(res, result, true);
    }

    if (verbose) {
      double map    = result.avgprecision.back()/result.rescount;
      double prec50 = result.precision[49]/result.rescount;
      double auc    = result.roc_auc/result.rescount;
      double mapstd = 0, prec50std = 0, aucstd = 0;

      double sm = 0, sm2 = 0, sp = 0, sp2 = 0, sa = 0, sa2 = 0;
      size_t n = 0;
      for (auto i=result.sub_result.begin(); i!=result.sub_result.end();
	   i++, n++) {
	double v = i->avgprecision.back()/i->rescount;
	sm  += v;
	sm2 += v*v;

	v = i->precision[49]/i->rescount;
	sp  += v;
	sp2 += v*v;

	v = i->roc_auc/i->rescount;
	sa  += v;
	sa2 += v*v;
      }
      if (n>1) {
	sm /= n;
	sm2 = sqrt((sm2-n*sm*sm)/(n-1));
	sp /= n;
	sp2 = sqrt((sp2-n*sp*sp)/(n-1));
	sa /= n;
	sa2 = sqrt((sa2-n*sa*sa)/(n-1));
	cout << sm << " " << sm2 << " " << sp << " " << sp2
	     << " " << sa << " " << sa2 << endl;
	mapstd    = sm2;
	prec50std = sp2;
	aucstd    = sa2;
      }

      cout << classname << " " << detections[0] << " MAP="
	   << map << " (" << mapstd
	   << ") Prec@50=" << prec50
	   << " (" << prec50std << ") AUC=" << auc
	   << " (" << aucstd << ")" << endl;
    }

    return result;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseBest(const vector<string>& args) {
  string msg = "AnalyseBest() : ";

  if (classname!="")
    return ShowError(msg+"class should NOT be defined.",
                     " Instead, define positive, negative, and viewclass");

  if (!query->HasPositive())
    return ShowError(msg+"positive should be defined.");

  // return AnalyseBestPerClass(args);

  skipobjectlists = true;

  list<string> p = GetDataBase()->SplitClassNames(query->Positive());
  list<string> n = GetDataBase()->SplitClassNames(query->Negative());

  if (n.size()!=0 && n.size()!=p.size())
    return ShowError(msg+"positive and negative lists differ in size");

  if (p.size()==1)
    return AnalyseBestPerClass(args);

  target_type t = query->Target();
  int o = -1;
  
  string view_class;
  list<string> px, pa;
  for (list<string>::const_iterator ipi=p.begin(); ipi!=p.end(); ipi++) {
    string ipx = *ipi, ipa;
    SplitParentheses(*ipi, ipx, ipa);
    view_class += (view_class=="" ? "" : "&") + ipx;
    px.push_back(ipx);
    pa.push_back(ipa);
  }

  ground_truth view = GroundTruthExpression(view_class, t, o, expand);

  Query *myquery = query;

  list<vector<float> > scores;

  bool ok = true, view_posi = true;

  for (list<string>::const_iterator
	 ipx=px.begin(), ipa=pa.begin(), in=n.begin();
       ok && ipx!=px.end(); ipx++) {
    Query q(Picsom());
    q.CopySome(*myquery, true, false, false);
    q.SetViewClass(view_posi ? "" : myquery->ViewClass());

    if (*ipx!="") {
      vector<string> alv = SplitInCommasObeyParentheses(*ipa);
      list<string> all(alv.begin(), alv.end());
      script_exp_t ascr = ScriptExpand(all, false);
      Picsom()->Interpret(ascr.begin(), ascr.end(), &q, this, NULL);
    }

    q.SetPositive(*ipx);
    q.SetNegative(in!=n.end() ? *in : "");

    query = &q;

    vector<float> *scorevec = NULL;
    if (scoredat!="") {
      scores.push_back(vector<float>());
      scorevec = &scores.back();
    }

    analyse_result res = AnalyseBestPerClass(args, scorevec);
    ok = !res.errored()||scoredumponly; 
    if (!ok)
      ShowError(msg+"per class <", *ipx, "> failed");

    // The following was needed when we had positive=red,trousers
    // and we wanted to find the best segment in the additive sense.
    //
    // myquery->SetOrSumNewImages(q);
    //
    // Perhaps its implementation has been broken since NEW_OBJECT_INDICES
    // was implemented.  Last version where OLD_OBJECT_INDICES code was present
    // was Query.C v. 2.273.

    if (ipa!=pa.end())
      ipa++;

    if (in!=n.end())
      in++;
    
//     Picsom()->PossiblyShowDebugInformation("AnalyseBest() after class "+*ip);

  }

  query = myquery;

  if (!ok)
    return false;

  if (scoredat!="" && scores.size()) {
    ofstream dat(scoredat.c_str());
    dat << "#" << endl;
    dat << "# score values from AnalyseBest()" << endl;
    dat << "#" << endl;
    dat << "#";
    for (list<string>::const_iterator ip=p.begin(); ip!=p.end(); ip++)
      dat << " " << *ip;
    dat << endl << "#" << endl;
    dat << scores.size() << endl;
    for (size_t i=0, nn=scores.begin()->size(); i<nn; i++) {
      for (list<vector<float> >::const_iterator j=scores.begin();
           j!=scores.end(); j++)
        dat << (*j)[i] << " ";
      dat << Label(i) << endl;
    }
    if (!dat)
      return ShowError(msg+"writing to <"+scoredat+"> failed");
    
    WriteLog("Stored scores in data file <"+scoredat+">");
  }

  if (skipresults)
    return true;
  
  aspect_map_t posi, nega;
  posi[""] = make_pair(view, 1.0);

  if (verbose) {
    AnalyseBestWriteHeader(posi, nega, ground_truth(0, 0));

    *aout
      << "=================================================================="
      << endl;
  }

  return AnalyseBestResults(args, view, posi, nega, "", false);
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseBestPerClass(const vector<string>& args,
                              vector<float> *scorevec) {

  if (crossval!="" && crossval!="none")
    return AnalyseBestCrossVal(args);

  if (verbose)
    WriteLog("AnalyseBestPerClass");
  else
    ScriptShow();

  target_type t = query->Target();
  //target_type t = target_any_target; // would follow the new convention...
  int o = -1;

  ground_truth view = GroundTruthExpression(query->ViewClassOrPositive(),
                                            t, o, expand);

  aspect_map_t posi = query->PositiveAspectsMap(t, o, expand);
  aspect_map_t nega = query->NegativeAspectsMap(t, o, expand);

  if (!posi[""].first.NumberOfEqual(1))
    return ShowError("AnalyseBestPerClass() : Found no [", TargetTypeString(t),
                     "] objects of class <", query->Positive(), ">");

  if (DataBase::DebugGroundTruth())
    *aout << "Analysis::AnalyseBestPerClass() : "
         << "ground truth expressions constructed." << endl;

  if (InServer())
    htmlfile = "";

  ReadFiles(true);

  DataBase *seendb = NULL;
  query->MarkAsSeenAspects(posi, nega, seendb); // MarkAsSeenEmptyAspect() ?

  return AnalyseBestFinalPart(posi, nega, view, args, scorevec);
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseBestFinalPart(const aspect_map_t& posi,
                               const aspect_map_t& nega,
                               const ground_truth& view,
                               const vector<string>& args,
                               vector<float> *scorevec) {
  string msg = "AnalyseBestFinalPart() : ";

  if (query->PerMapObjects()==0 && query->DataBaseSize()>100000)
    *aout << endl << msg << "Database is quite LARGE, consider setting "
         << "permapobjects=1000 or something ?" << endl << endl;

  string imgname;
  if (htmlfile!="") {
    imgname = BaseName(htmlfile);
    StripLastWord(imgname, '.');
    query->MapImageName(imgname);
  }

  string scorefile_orig = query->ScoreFile();
  if (scorefile_orig!="")
    query->ScoreFile(scorefile_orig + "_"+query->Positive());

  if (verbose)
    AnalyseBestWriteHeader(posi, nega, view);

  int mq_was = query->MaxQuestions();
  if (mq_was==0)
    query->MaxQuestions(query->DataBaseSize());

  query->CanShowSeen(true);
  query->DefaultMatrixCount(3);
  query->CalculateEntropy(true);
    
  if (prfrounds>0) // Pseudo Relevance Feedback (PRF):
    query->ExpansionByPRF(prfrounds, prfobjects);

  CbirStages();

  if (scorevec)
    query->StoreScores(*scorevec);

  query->MaxQuestions(mq_was);
  query->ScoreFile(scorefile_orig);

  if (skipresults)
    return true;

  SetElapsedTime(query);

  return AnalyseBestResults(args, view, posi, nega, imgname, true);
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseBestCrossVal(const vector<string>&
                                                       args) {
  return Obsoleted("Analysis::AnalyseBestCrossVal()");

  WriteLog("AnalyseBestCrossVal ["+crossval+"]");

  if (query->HasViewClass())
    return ShowError("AnalyseBestCrossVal() : "
                     "cannot handle non-empty viewclass");

  size_t nfold = 0;
  bool do_H = false, do_V = false;
  
  if (crossval!="LOO") {
    size_t p = crossval.find_first_not_of("0123456789");
    if (p)
      nfold = atoi(crossval.substr(0, p).c_str());
    if (crossval.size()!=p+1 && crossval.size()!=p+2)
      return ShowError("AnalyseBestCrossVal() : unable to interpret [",
                     crossval, "] A");
    if (crossval[p]=='H' || crossval[p+1]=='H')
      do_H = true;
    if (crossval[p]=='V' || crossval[p+1]=='V')
      do_V = true;

    if (!p || (!do_H && !do_V))
      return ShowError("AnalyseBestCrossVal() : unable to interpret [",
                       crossval, "] B");
  } else {
    // some logic is certainly still missing...
    ground_truth all = GroundTruthExpression(query->Positive());
    nfold = all.number_of_equal(1);
    do_H = true;
  }

  const string posi = query->Positive();
  const string nega = query->Negative();  // cannot handle this yet...
  const string rstr = CheckDB()->RestrictionName();

  const string crossval_was = crossval;
  crossval = "";

  const string nfoldstr = ToStr(nfold);
  const string rstrhdr = rstr=="" ? "~" : rstr+"\\";
  string mstr;

  analyse_result total;

  bool ok = true;
  for (size_t i=0; ok && i<2*nfold; i++) {
    if ((i%2==0 && !do_H) || (i%2==1 && !do_V))
      continue;

    const string ii = ToStr(i/2), hv = i%2==0?"H":"V", hvx = hv+"x";
    string tsetname = "cross-val-"+nfoldstr+"-"+ii+"-"+hvx;
    string tsetexpr = "$split("+posi+","+TargetTypeString(Target())+","
      +ToStr(nfold)+","+ii+","+hvx+")";

    CheckDB()->SetGroundTruth(tsetname, tsetexpr);

    string tsetexpname = tsetname+"-exp";
    string tsetexpexpr = "$exp("+tsetname+")";
    CheckDB()->SetGroundTruth(tsetexpname, tsetexpexpr);

    query->SetPositive(tsetname);
    query->SetNegative(nega);  // cannot handle this yet...
    query->SetViewClass(posi+"\\"+tsetname);
    CheckDB()->Restriction(rstrhdr+tsetexpname);

    analyse_result res = AnalyseBestPerClass(args);
    if (!res.empty()) {
      AddToResult(res, total, false);
      //corrsum += res.corr*res.rescount;
      //totsum  += res.tot*res.rescount;
      //nres    += res.rescount;
      //*aout << res.corr << " " << res.tot << " " << res.rescount << endl;

    } else
      ok = false;

    query->DeleteSeen();
    query->DeleteNew();
    //    query->DeleteFeatureData();
  }

  query->SetPositive(posi);
  query->SetNegative(nega);
  query->SetViewClass("");
  CheckDB()->Restriction(rstr);
  crossval = crossval_was;

  ground_truth_list gtl; // something could be put in here too...
  list<string> extra;
  AddExtraVariableInfo(extra, "crossval",  crossval);
  AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
  AddExtraVariableInfo(extra, "taskstack", TaskStack());
  query->WriteAnalyseVariablesNew("Best", mstr, gtl, extra);

  query->DoubleLogSeparator(mstr);
  SolveAndWriteAnalyseResults("Best", total, mstr, true, true);

  return ok ? total : false;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::AnalyseBestWriteHeader(const aspect_map_t& posi,
                                      const aspect_map_t& nega,
                                      const ground_truth& view) {
  CreateXHTML();
  PicSOM::HTMLh1(xhtml, "AnalyseBest results");

  DataBase *db = CheckDB();

  stringstream ss;
  // most of this logging is useless because AnalyseBestResults() is called
  // anyway and it in turn calls query->WriteAnalyseVariablesNew().

  ss << "Database " << DataBaseName() << " contains "
     << query->DataBaseSize() << " objects";
  *aout << endl << ss.str() << endl;
  PicSOM::HTMLp(xhtml, ss.str());
  
  if (query->TextQuery()!="") {
    ss.str("");
    ss << "textquery=[" << query->TextQuery() << "]";
    *aout << endl << ss.str() << endl;
    PicSOM::HTMLp(xhtml, ss.str());
  }

  target_type t = query->Target();

  ss.str("");
  ss << "Marked " << query->NpositiveSeenObjects() << " objects ["
     << TargetTypeString(t) << "] of classes <" << AspectNames(posi)
     << "> as positive";
  *aout << endl << ss.str() << endl;
  PicSOM::HTMLp(xhtml, ss.str());

  db->GroundTruthSummaryTable(posi, true, true, *aout);

  ss.str("");
  ss << "Marked " << query->NnegativeSeenObjects() << " objects ["
     << TargetTypeString(t) << "] of classes <" << AspectNames(nega)
     << "> as negative";
  *aout << endl << ss.str() << endl;
  PicSOM::HTMLp(xhtml, ss.str());

  db->GroundTruthSummaryTable(nega, true, true, *aout);

  ss.str("");
  ss << "Database restriction is <" << db->RestrictionName()
     << "> and contains " << db->RestrictionSize(t)
     << " objects of type [" << TargetTypeString(t) << "]";
  *aout << endl << ss.str() << endl;
  PicSOM::HTMLp(xhtml, ss.str());

  db->GroundTruthSummaryTable(db->RestrictionGT(), true, true, *aout);

  if (!view.empty()) {
    ss.str("");
    ss << "Correctness of retrieval is assessed by viewclass <" 
       << view.Label() << ">";
    *aout << endl << ss.str() << endl;
    PicSOM::HTMLp(xhtml, ss.str());
    
    db->GroundTruthSummaryTable(view, true, true, *aout);
  }

  *aout << endl;

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseBestResults(const vector<string>&,
                                                      const ground_truth& view,
                                                      const aspect_map_t& posi,
                                                      const aspect_map_t& nega,
                                                      const string& imgname,
                                                      bool do_maps) {
  string msg = "Analysis::AnalyseBestResults() : ";

  bool debug = false;
  string mstr;

  if (verbose && !scoredumponly) {
    mstr = string("% ") + TimeStamp() + "\n%\n";

    ground_truth_list gtl;
    AddAspectInfo(gtl, "positive", posi);
    AddAspectInfo(gtl, "negative", nega);
    AddGroundTruthInfo(gtl, "viewclass", view);

    list<string> extra;
    AddExtraVariableInfo(extra, "batchparameters", batchparameters);
    AddExtraVariableInfo(extra, "depth",           ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack",       TaskStack());

    query->WriteAnalyseVariablesNew("Best", mstr, gtl, extra);
    query->DoubleLogSeparator(mstr);
  }

  DataBase *db = GetDataBase();
  size_t mq = query->NnewObjects(), corr = 0, ll = 8;
  ground_truth gt_mq(query->DataBaseSize());
  ground_truth gt_mqret(query->DataBaseSize());
  ground_truth gt_corr(query->DataBaseSize());
  gt_mq = gt_mqret = gt_corr.Set(-1);

  vector<size_t> forced;
  if (forcedbest!="")
    forced = CheckDB()->ReadOrderedClassFile(forcedbest);

  // This should be the primary data object from this point on.
  // Thus NewImage() should not be called anymore.
  //  typedef list<pair<size_t,double> > bestidxval_t;
  objectlist_t bestidxval, res_corrval, res_incorrval;

  size_t maxq = query->MaxQuestions()>0 ? query->MaxQuestions() : string::npos;

  ofstream scdump;
  if (scoredump!="") {
    string dumpname=scoredump+"_"+query->Positive();
    scdump.open(dumpname.c_str());
  }
  size_t scd_t = 0, scd_p = 0, scd_n = 0;
  bool dump_only = scoredumponly;

  const double maxd = numeric_limits<double>::max();

  // cout << TimeStamp() << msg << "A" << endl;

  for (int i=-forced.size(); i<(int)mq; i++) {
    if (i==0 && forcedonly)
      break;

    size_t idx = i>=0 ? query->NewObject(i).Index() : forced[forced.size()+i];
    //const string& lab = i>=0 ? query->NewImage(i).Label() : Label(idx);
    const string& lab = Label(idx);
    string dbg = i>=0 ? query->NewObject(i).DumpString(i) :
      "Forced object #"+ToStr(idx)+" <"+lab+">";

    if (debug)
      *aout << "i=" << i << " " << dbg << endl;

    bool found = false;
    if (i>=0)
      for (size_t j=0; !found && j<forced.size(); j++)
        if (forced[j]==size_t(idx))
          found = true;
    if (found)
      continue;

    if (!dump_only) {
      if (gt_mq[idx]==1)
        ShowError("AnalyseBest() : object repeated : ", dbg);
      gt_mq[idx] = 1;
    }

    // in AnalyseBestResultsTrecvid():
    //
    // if (o.SelectType()==select_show)
    //   continue;
    //
    // should it be here too?

    if (i>=0 && !query->NewObject(i).Retained())
      continue;

    if (!dump_only) {
      gt_mqret[idx] = 1;
      double val = i>=0 ? query->NewObject(i).Value() : maxd;
      const pair<size_t,double> idxval = make_pair(idx, val);
      bestidxval.push_back(idxval);

      if (!view.empty()) {
        if (view[idx]==1) {
          corr++;
          gt_corr[idx] = 1;
          res_corrval.push_back(idxval);
        } else
          res_incorrval.push_back(idxval);
      }

      if (lab.size()>ll)
        ll = lab.size();

      if (bestidxval.size()>=maxq)
        dump_only = true;
    }
    
    if (!scdump) {
      if (scoredump!="")
        break;
      else
        continue;
    }

    scdump << "#" << idx << "\t" << lab << "\t"
           << query->NewObject(i).Value() << "\t"
           << (view.empty() ? "?" : view[idx]==1 ? "1" : "-1") << "\t"
           << ++scd_t;
    if (!view.empty()) 
      scdump << "\t" << (view[idx]==1 ? ++scd_p : scd_p)
             << "\t" << (view[idx]!=1 ? ++scd_n : scd_n);
    scdump << endl;
  }

  // cout << TimeStamp() << msg << "B" << endl;

  if (resultname!="") {
    bool sval = true, app = false;
    string txt = "Result of AnalyseBest() in descending order of score";
    string fn = ExpandedResultName();
    WriteOrderedClassFile(bestidxval,    fn+"-all",    txt, sval, app);
    WriteOrderedClassFile(res_corrval,   fn+"-corr",   txt, sval, app);
    WriteOrderedClassFile(res_incorrval, fn+"-incorr", txt, sval, app);
  }

  if (verbose && !scoredumponly) {
    size_t mqret = bestidxval.size();

    stringstream ss;
    ss << "CbirStages() returned " << mq << " objects of which " << mqret
       << " were of interest and " << corr << " belonged to the correct class";
    if (scoredump!="")
      ss << " (scoredump: " << scd_t << " " << scd_p << " " << scd_n << ")";

    *aout << endl << ss.str() << endl;
    PicSOM::HTMLp(xhtml, ss.str());
    db->GroundTruthSummaryTable(gt_mq, false, false, *aout);

    *aout << endl << "Of interest were:" << endl;
    db->GroundTruthSummaryTable(gt_mqret, false, false, *aout);

    *aout << endl << "To viewclass <" << view.label() << "> belonged:" << endl;
    db->GroundTruthSummaryTable(gt_corr, false, false, *aout);

    if (mq>DataBaseSize())
      ShowError("AnalyseBest() : number of returned objects exceeds ",
                "the size of the database !!!???");

    size_t pos = view.positives(), neg = view.negatives();

    ss.str("");
    ss << "viewclass <" << view.label() << "> has " << pos
       << " positives and " << neg << " negatives";
    *aout << endl << ss.str() << endl;
    PicSOM::HTMLp(xhtml, ss.str());

    if (mqret<pos && query->PerMapObjects()==0) {
      int show_n = 5;
      
      ground_truth miss(view.size(), -1);
      *aout << endl;
      for (size_t i=0; i<view.size(); i++)
        if (view[i]==1 && gt_mqret[i]!=1) {
          if (show_n-->0)
            *aout << "In viewclass, but missing from CBIR output: "
                 << db->ObjectDump(i) << endl;
          miss[i] = 1;
        }

      *aout << endl << "All missed objects:" << endl;
      db->GroundTruthSummaryTable(miss, false, false, *aout);
      
      ShowError("AnalyseBest() : number of returned objects of interest "
                "(mqret="+ToStr(mqret)+") is "+ToStr(miss.positives())+
                " below the number of objects in viewclass (pos="+ToStr(pos)+
                ")");
    }
    
    if (corr!=pos && query->PerMapObjects()==0)
      ShowError("AnalyseBest() : number of returned correct class objects ",
                corr<pos ? "is below" : "exceeds",
                " the number of objects in the class, corr="
                +ToStr(corr)+" pos="+ToStr(pos));

    if (do_maps)
      AnalyseBestResultsMaps(imgname);

    AnalyseBestResultsThreeLists(bestidxval, view);
  }

  analyse_result res;
  if (!scoredumponly)
    res = AnalyseResultsCommon(bestidxval, view, mstr);

  if (htmlfile!="")
    AnalyseBestResultsHTML();

  if (trecvid!="")
    AnalyseBestResultsTrecvid(query, bestidxval);

  if (treceval!="")
    AnalyseBestResultsTrecEval(query, bestidxval);

  return res;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::AnalyseBestResultsMaps(const string& imgname) {
  bool matrix0_only = true;

  for (size_t mi=0; mi<query->Nindices(); mi++) {
    if (!query->IsTsSom(mi))
      continue;

    for (size_t li=0; li<query->TsSom(mi).Nlevels(); li++)
      if (query->Convolved(mi, li, 0).MaximumAbsolute()>0.0)
        for (size_t ki=0; ki<query->GetMatrixCount(mi); ki++)
          if (!matrix0_only || ki==0) {
            xmlNodePtr p = PicSOM::HTMLp(xhtml);
            if (InServer())
              PicSOM::HTMLserverMap(p, query, mi, li, ki);
            else if (htmlfile!="")
              PicSOM::HTMLlocalMap(p, query, mi, li, ki, imgname);

            AddTag(p, NULL, "br");
            AddTag(p, NULL, "b", query->MapName(true, mi, li,
                                                query->GetMatrixCount(mi)!=1?
                                                (int)ki:-1));
            stringstream entss;
            if (matrix0_only || ki==1) {
              const TSSOM::State& fd = query->IndexDataTSSOM(mi);
              if (fd.tssom_level_weight.size()>(size_t)li)
                entss << " weight=" << fd.tssom_level_weight[li];
              if (fd.entropy.size()>(size_t)li)
                entss << " entropy=" << fd.entropy[li];
              if (fd.entropy_r.size()>(size_t)li)
                entss << " entropy_r=" << fd.entropy_r[li];
              if (fd.entropy_p.size()>(size_t)li)
                entss << " entropy_p=" << fd.entropy_p[li];
              if (fd.entropy_n.size()>(size_t)li)
                entss << " entropy_n=" << fd.entropy_n[li];
              
              AddText(p, entss.str());
            }
          }
  }
  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::AnalyseBestResultsThreeLists(const objectlist_t& /*bestidxval*/,
                                            const ground_truth& view) {
  DataBase  *db = CheckDB();
  target_type t = query->Target();

  size_t pos = view.positives(), neg = view.negatives();

  int mq = query->NnewObjects(); // bestidxval should be used !!!

  list<pair<string,string> > extra;
  string spec = imagespec!="" ? imagespec : "nz:d";
  if (t==target_segment)
    extra.push_back(pair<string,string>("spec", spec));
  
  stringstream ss;

  for (int l=0; l<3; l++) {
    if (view.empty() && l==1)
      break;

    int n = l==0?bestall : l==1?bestpositive : bestother;
    int m = l==0?mq      : l==1?pos          : neg;
    if (n>m)
      n = m;
    if (!n)
      continue;

    ss.str("");
    ss << "Best " << n << " objects [" << TargetTypeString(t) << "] ";
    ss << (l==0?"of all" : l==1?"of class " : "not in class ");
    ss << (l>0 ? "<"+view.label()+">" : "");
    *aout << endl << ss.str() << endl;
    PicSOM::HTMLh2(xhtml, ss.str());

    for (int i=0, j=0, k=0; i<mq && j<n; i++) {
      const Object& img = query->NewObject(i);
      if (!img.Retained())
        continue;

      int gt = view.empty() ? 0 : view[img.Index()];
      bool ok = ((l==0) || ((l==1)&&(gt==1)) || ((l==2)&&(gt==-1)));
      if (ok) {
        char tmp[100];
        sprintf(tmp, "%4d: %4d (%4d) %2d ", j++, k, i, gt);
        *aout << tmp << img.DumpString(-1, 8) << endl;

        string stmp = string(tmp)+img.Label();
        sprintf(tmp, " #%d ", img.Index());
        stmp += tmp;

        xmlNodePtr p = PicSOM::HTMLp(xhtml, stmp);
        if (InServer()) {
          PicSOM::HTMLserverTnAndImage(p, img.Label(), db, query, extra);
        } else if (htmlfile!="") {
          string outdir = htmlfile;
          StripLastWord(outdir,'/');
          PicSOM::HTMLlocalTnAndImage(p, img.Label(), db, outdir,
                                      htmlfile_linkimages);
        }
        stringstream score;
        score << " " << img.Value();
        AddTag(p, NULL, "b", score.str());
      }
      k++;
    }
  }

  *aout << endl;

  return true;
}

///////////////////////////////////////////////////////////////////////////////

void Analysis::AnalyseBestResultsHTML() {
  xmlNodePtr head = NULL, body = NULL;
  xmlDocPtr html = PicSOM::HTMLfile(&head, &body);
  PicSOM::HTMLtitle(head, "AnalyseBest results");
  xmlNodePtr n = xmlCopyNode(xhtml, 1);
  xmlNodeSetName(n, (XMLS)"body");
  xmlReplaceNode(body, n);
  xmlFreeNode(body);

  string dump = Connection::XML2String(html, true);
  string htmlname = htmlfile;
  if (!StringEnds(htmlname, ".html") && !StringEnds(htmlname, ".xml"))
    htmlname += ".html";
  ofstream os(htmlname.c_str());
  os << dump;
  xmlFreeDoc(html);

  WriteLog("Stored results as HTML in <"+htmlname+">");
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseResultsCommon(const objectlist_t& bestidxval, 
                               const ground_truth& view, string& mstr) {
  string msg = "Analysis::AnalyseResultsCommon() : ";

  // cout << TimeStamp() << msg << "entered" << endl;

  size_t mqret = bestidxval.size();

  if (!mqret)
    return false;

  bool limit_dbsize=true;

  target_type tt = query->Target();
  int dbsize = query->DataBaseRestrictionSize(tt);  // was DataBaseSize()
  // dbsize==mqret if all objects are in newimage[]

  IntVector hits(mqret);
  vector<float> ivec(mqret);

  DoubleVector dvec(mqret);

  objectlist_t::const_iterator bestit = bestidxval.begin();
  if (!view.empty()) {
    for (size_t i=0, l=bestidxval.size(); i<l; i++) {
      size_t idx = (bestit++)->first;
      dvec[i] = view[idx];
      if (view.isImplicit(idx))
        dvec[i] = -2;
      ivec[i] = hits[i] = view[idx]==1;
    }
  }
  int csum  = view.NumberOfEqual(1);
  int found = hits.Sum();
  int maxq  = query->MaxQuestions()>0 ? query->MaxQuestions() : mqret;
  // found==csum if all objects are in newimage[]

  vector<float> rvec, pvec, avec;
  int bias = 0;
  Recall(hits, csum, bias, &rvec);
  Precision(hits, bias, &pvec);
  AveragePrecision(hits, AveragePrecisionDivider(csum, maxq), bias, &avec);
  float infap = -1.0;
  if (view.hasImplicit())
    infap = InferredAveragePrecision(dvec, 
                                     AveragePrecisionDivider(csum, maxq));

  // *aout << "dbsize=" << dbsize << " rvec.size()=" << rvec.size() << endl;

  if (limit_dbsize && dbsize>(int)rvec.size())
    dbsize = rvec.size();

  analyse_result results(csum, dbsize);
  results.recall        = rvec;
  results.precision     = pvec;
  results.avgprecision  = avec;
  results.instprecision = ivec;

  results.rescount   = 1;
  results.rounds     = mqret;
  results.seen       = mqret;
  results.found      = found;
  results.firstpos   = !view.empty() && ivec[0]==1;
  results.tau        = 1; // foolish
  results.tauord     = 1; // foolish
  results.birds      = 0; // foolish
  results.inferredap = infap;
  // results.avgprec = xxx; // should this be set too?
  // results.appoint = xxx; // should this be set too?

  results.set_roc_from_recall(rvec, csum, dbsize);

  results.maxpr   = vector<float>(mqret);
  results.apriori = vector<float>(mqret); // obs! dummy values

  if (!view.empty())
    for (size_t i=0; i<bestidxval.size(); i++)
      if (ivec[i]==1) {
        results.firsthit    = i;
        results.firsthitadv = FirstHitAdv(i, csum, dbsize);
        break;
      }

  if (verbose)
    SolveAndWriteAnalyseResults("Best", results, mstr, true, true);

  // cout << TimeStamp() << msg << "ready" << endl;

  if (resultcount) {
    size_t n = (size_t)resultcount;
    if (n>bestidxval.size())
      n = bestidxval.size();
    objectlist_t::const_iterator i = bestidxval.begin(), j = i;
    while (j!=bestidxval.end() && n--)
      j++;

    results.best.assign(i, j);
  }

  return results;
}

///////////////////////////////////////////////////////////////////////////////

  void Analysis::AnalyseBestResultsTrecvid(Query *qqq,
                                           const objectlist_t& /*bestidxval*/) {
    // OBS! bestidxval should be used here too!!!

    if (trecvid_runid.empty()) {
      ShowError("AnalyseBestResultsTrecvid() : trecvid_runid not set!");
      return;
    }

    if (trecvid_priority.empty()) {
      ShowError("AnalyseBestResultsTrecvid() : trecvid_priority not set!");
      return;
    }

    if (!qqq)
      qqq = query;

    bool feature = false, search = false;
    DataBase *db = GetDataBase();
    string dbname = db->BaseName();
    const string keyframe_postfix = 
      dbname=="trecvid2005"?":2":
      dbname=="trecvid2006"?":kf1":
      "";

    string posset = qqq->Positive();
    if (posset=="")
      posset = classname;

    string fnum, tnum;
    size_t fnumpos = posset.find("fNum");
    if (fnumpos!=string::npos) {
      feature = true;
      fnum = posset.substr(fnumpos+4);
      size_t dash = fnum.find('-');
      if (dash!=string::npos)
        fnum.erase(dash);

    } else if (posset.find("tNum")==0) {
      search = true;
      tnum = posset.substr(4);
    }

    if (!feature && !search) {
      feature = true;
      fnum = posset;
    }

    string txt = search ? "Search" : "FeatureExtraction";
    string ext = search ? "Topic"  : "Feature";

    XmlDom doc = XmlDom::Doc("video"+txt+"Results", "",
			     "video"+txt+"Results.dtd");
    XmlDom results   = doc.Root("video"+txt+"Results");
    XmlDom runresult = results.Element("video"+txt+"RunResult");
    XmlDom resulte   = runresult.Element("video"+txt+ext+"Result");

    if (search)
      runresult.Prop("pType",  "I");

    runresult.Prop("trType",   "A");
    runresult.Prop("sysId",    "PicSOM_"+trecvid_runid);
    runresult.Prop("priority", trecvid_priority);

    if (search)
      runresult.Prop("condition", "1");

    runresult.Prop("desc",     "descriptive text missing");

    if (feature)
      resulte.Prop("fNum", fnum);

    if (search) {
      resulte.Prop("tNum",        tnum);
      resulte.Prop("elapsedTime", elapsed_time!=""?elapsed_time:"5.5");
      resulte.Prop("searcherId",  "A");
    }

    for (size_t i=0, j=0; i<qqq->NnewObjects(); i++) {
      const Object& obj = qqq->NewObject(i);
      if (!obj.Retained())
        continue;

      if (obj.SelectType()==select_show)
        continue;

      if (++j>qqq->MaxQuestions())
        break;

      const string& label = obj.Label();
      string shotid = TrecvidShotIdFromOrigins(label);
      if (shotid=="")
        shotid = TrecvidShotIdFromOrigins(label+keyframe_postfix);
      if (shotid=="")
        shotid = TrecvidShotId(label);
      if (shotid=="") {
        ShowError("AnalyseBestResultsTrecvid() : could not evaluate shot id!");
        return;
      }

      XmlDom item = resulte.Element("item");
      item.Prop("seqNum", j);
      item.Prop("shotId", shotid);
    }

    string xmlname = trecvid+".xml";
    doc.Write(xmlname, true);
    doc.DeleteDoc();

    WriteLog("Stored trecvid results in <"+xmlname+">");
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::AnalyseBestResultsTrecEval(Query *qqq,
                                            const objectlist_t&
					    /*bestidxval*/) {
    const string msg = "AnalyseBestResultsTrecEval() : ";
    // OBS! bestidxval should be used here too!!!

    if (!qqq)
      qqq = query;

    bool feature = false, search = false;
    DataBase *db = GetDataBase();
    string dbname = db->BaseName();

    const string keyframe_postfix = ":kf1";

    string posset = qqq->Positive();
    if (posset=="")
      posset = classname;

    string fnum, tnum;
    size_t fnumpos = posset.find("fNum");
    if (fnumpos!=string::npos) {
      feature = true;
      fnum = posset.substr(fnumpos+4);
      size_t dash = fnum.find('-');
      if (dash!=string::npos)
        fnum.erase(dash);

    } else if (posset.find("tNum")==0) {
      search = true;
      tnum = posset.substr(4);
    } else if (posset.find("lscom") != string::npos) {
      feature = true;

      string lscom_numstr = posset.substr(posset.find("lscom"));
      size_t stoppos = lscom_numstr.find_first_not_of("0123456789", 5);
      if (stoppos != string::npos)
        lscom_numstr.erase(stoppos);

      string lscom_str = db->LscomName(lscom_numstr, true, "trecvid2011");

      pair<string, string> lscom_pair = DataBase::SplitLscomName(lscom_str);
      fnum = lscom_pair.second;
    }

    if (!feature && !search) {
      feature = true;
      fnum = posset;
    }

    ofstream os(treceval.c_str(), ios_base::app | ios_base::out);

    for (size_t i=0, j=0; i<qqq->NnewObjects(); i++) {
      const Object& obj = qqq->NewObject(i);
      if (!obj.Retained())
        continue;

      if (obj.SelectType()==select_show)
        continue;

      if (++j>qqq->MaxQuestions())
        break;

      const string& label = obj.Label();
      string shotid = TrecvidShotId(label);
      if (shotid=="") {
        ShowError(msg, " could not evaluate shot id for label \""+label+"\"");
        return;
      }

      os << (1000+atoi(fnum.c_str())) << " "
         << 0 << " " 
         << shotid << " "
         << j << " " 
         << 10000-j << " "
         << treceval << endl;
      
      if (!os)
        ShowError(msg, "failed to write in class file <"+treceval+">");

    }
    os.close();
    WriteLog("Stored treceval results in <"+treceval+">");
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidSINdevel(const vector<string>& /*args*/) {
    const string msg = "AnalyseTrecvidSINdevel() : ";

    DataBase *db = CheckDB();

    ground_truth pos(db->Size(), -1);
    ground_truth neg = pos, all = pos;

    list<string> clist = db->SplitClassNames("tv14concepts");
    for (auto c=clist.begin(); c!=clist.end(); c++) {
      string sp = "develimage&$children($lscom2trecvid("+*c+",ann-,-pos))";
      string sn = "develimage&$children($lscom2trecvid("+*c+",ann-,-neg))";
      ground_truth p = db->GroundTruthExpression(sp);
      ground_truth n = db->GroundTruthExpression(sn);
      db->GroundTruthSummary(p);
      db->GroundTruthSummary(n);
      pos = pos.TernaryOR(p);
      neg = neg.TernaryOR(n);
    }

    all = pos.TernaryOR(neg);
    db->GroundTruthSummary(pos);
    db->GroundTruthSummary(neg);
    db->GroundTruthSummary(all);

    if (filename!="") {
      if (db->WriteClassFile(filename, vector<string>(), "", all,
			     "All positive "
			     "and negative training samples for 60 classes.",
			     false, false))
	WriteLog("Wrote class file <"+filename+">");
      else 
	return ShowError(msg+"failed to write class file <"+filename+">");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidIframes(const vector<string>& /*args*/) {
    const string msg = "AnalyseTrecvidIframes() : ";

    DataBase *db  = CheckDB();

    const ground_truth& gt = QueryRestrictionGT();
    vector<size_t> idxs = gt.indices(1);

    map<string,size_t> n, first;
    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];
      string label = db->Label(idx);
      size_t p = label.find(":kf");
      if (p!=string::npos) {
	label.erase(p);
	if (n.find(label)==n.end())
	  n[label] = 0;
	continue;
      }
      p = label.find(":if");
      if (p==string::npos)
	continue;
      size_t a = atoi(label.substr(p+3).c_str());
      label.erase(p);
      n[label]++;

      if (first.find(label)==first.end())
	first[label] = a;
    }

    map<size_t,size_t> h;
    for (auto i=n.begin(); i!=n.end(); i++)
      h[i->second]++;
    
    map<size_t,size_t> red;

    size_t nsum = 0, tot = 0, totm = 0;
    for (auto i=h.begin(); i!=h.end(); i++) {
      size_t step = 4;

      nsum += i->second;
      size_t a = i->first*i->second;
      tot += a;

      size_t mod = red[i->first];
      if (!mod) {
	size_t div = 1, v = i->first;
	for (;;) {
	  if (v<=step) {
	    mod += v/div;
	    break;
	  }
	  mod += step/div;
	  v -= step;
	  div *= 2;
	  step *= 2;
	}
	red[i->first] = mod;
      }
      size_t amod = mod*i->second;
      totm += amod;

      cout << i->first << " : " << i->second
	   << " = " << a << " (" << nsum << " " << tot << ") "
	   << mod << " = " << amod << " (" << totm << ")"
	   << endl;
    }

    if (filename!="") {
      ofstream out(filename);
      for (auto i=n.begin(); i!=n.end(); i++) {
	size_t a = i->second, b = red[a];
	cout << i->first << " " << a << " -> " << b << " :";
	double r = double(a)/b;
	for (size_t j=0; j<b; j++) {
	  size_t k = floor((j+0.5)*r);
	  cout << " " << k;
	  out << i->first << ":if" << first[i->first]+k << endl;
	}
	cout << endl;
      }
    }
    
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::TrecvidSINweightsEval(const list<string>& classes,
				       const string& year, const string& fp,
				       const string& moomin,
				       const string& trType,
				       const string& priority,
				       const string& description,
				       size_t nres, bool tolerate_missing,
				       bool to_parent,
				       vector<pair<size_t,double> >& det) {
    const string msg = "TrecvidSINweightsEval() : ";

    DataBase *db = CheckDB();

    const ground_truth& gt = QueryRestrictionGT();
    vector<size_t> idxs = gt.indices(1);

    map<string,vector<size_t> > sel;
    list<pair<string,vector<size_t> > > res;

    string ofname;
    if (nres==(size_t)-1) { // trecvid2015 LOC
      ofname = "detections-"+gt.label()+".txt";
      for (;;) {
	size_t p = ofname.find_first_of("$(),&/:");
	if (p==string::npos)
	  break;
	ofname[p] = '_';
      }
    }

    double sum = 0;
    for (auto i=classes.begin(); i!=classes.end(); i++) {
      vector<pair<string,double> > detw;
      map<string,double> varmap;
      map<string,double> cnsmap;
      map<string,string> eqnmap;
      if (!DetectionsWithClasswiseWeights(detections, *i, filename,
					  detw, varmap, cnsmap, eqnmap))
	return ShowError(msg+"DetectionsWithClasswiseWeights() failed");

      bool all_zero = true;
      for (auto j=detw.begin(); all_zero && j!=detw.end(); j++)
	if (j->second!=0)
	  all_zero = false;

      if (all_zero)
	detw = TrecvidSINweightSolveMath(detw, varmap, cnsmap, eqnmap);

      vector<pair<string,double> > detwcls = detw;
      for (auto j=detwcls.begin(); j!=detwcls.end(); j++) {
	size_t p = j->first.find("#%c");
	if (p!=string::npos)
	  j->first.replace(p+1, 2, *i);
      }

      if (verbose>2) {
	for (auto j=detw.begin(); j!=detw.end(); j++)
	  cout << year << " " << *i << " " << j->first << " " << j->second
	       << endl;
	cout << endl;
      }

      double iap = TrecvidSINevaluate(idxs, ofname, detw, *i, year, fp, nres,
				      tolerate_missing, to_parent);
      cout << *i << " " << year << " " << gt.label() << " " << iap << endl;
      sum += iap;

      string flab = db->LscomNameToTrecvidId(*i);
      vector<pair<size_t,double> > hits = db->TrecvidSIN(idxs, detwcls, nres,
							 tolerate_missing,
							 to_parent);
      vector<size_t> hitsi;
      for (size_t j=0; j<hits.size(); j++) {
	size_t idx = hits[j].first;
	hitsi.push_back(idx);
	sel[flab].push_back(idx);
      }
      res.push_back(make_pair(*i, hitsi));

      if (classes.size()==1)
	det = hits;
    }

    if (nres==(size_t)-1 && classes.size()==1) // trecvid2015 LOC
      return true;

    cout << "avg.  " << year << " " << gt.label() << " "
	 << sum/classes.size() << endl;

    string dname = "hello";
    size_t nresx = 0;
    double mxiap = TrecvidInfAP(dname, sel, nresx, year, fp, verbose>1);

    cout << "mxiap " << year << " " << gt.label() << " " << mxiap << endl;

    if (year=="2015")
      return TrecvidSinOutputInner(year, moomin, trType, priority,
				   description, res);
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool 
  Analysis::DetectionsWithClasswiseWeights(const vector<string>& detsin,
					   const string& cname,
					   const string& fnamein,
					   vector<pair<string,double> >& detw,
					   map<string,double>& vmap,
					   map<string,double>& cmap,
					   map<string,string>& emap) {
    const string msg = "DetectionsWithClasswiseWeights() : ";

    DataBase *db = CheckDB();
    vector<string> dets = detsin;

    if (dets.size()==1) {
      dets.clear();
      auto m = db->DescribedDetection(detsin[0]);
      if (m.find("detectors")!=m.end())
	dets = SplitInCommas(m["detectors"]);
      else
	dets.push_back(detsin[0]);
      WriteLog("Detector <"+detsin[0]+"> expands to "+
	       CommaJoin(dets));
    }
    // no expansion here but later...
    // for (size_t i=0; i<dets.size(); i++) {
    //   string& det = dets[i];
    //   size_t p = det.find("#%c");
    //   if (p==string::npos) {
    // 	p = det.size();
    // 	det += "#%c";
    //   }
    //   det.replace(p+1, 2, cname);
    // }

    vector<float> w(dets.size());
    for (size_t i=0; i<w.size(); i++)
      w[i] = 1.0/w.size();

    if (fnamein!="") {
      string fname = fnamein, line;
      size_t p = fname.find("%c");
      if (p!=string::npos)
	fname.replace(p, 2, cname);
      bool iscomplete = false;
      ifstream txt(fname);
      while (txt) {
	string l;
	getline(txt, l);
	if (l!="")
	  line = l;
	if (l.find("<classwiseweights class")!=string::npos)
	  iscomplete = true;
      }
      if (iscomplete && line!="") {
	if (line.find("<classwiseweights class=\""+cname+"\">")!=0)
	  return ShowError(msg+"last line of <"+fname+
			   "> doesn't start right");
	p = line.find('>');
	line.erase(0, p+1);
	p = line.find('<');
	line.erase(p);
	vector<string> ws = SplitInSpaces(line);
	if (ws.size()!=w.size())
	  return ShowError(msg+"dimensionality mismatch in <"+fname+">");
	for (size_t i=0; i<w.size(); i++)
	  w[i] = atof(ws[i].c_str());

	if (verbose>1)
	  WriteLog("Read class-specific detector weights from <"+fname+">");
      }

      if (!iscomplete) {
	for (size_t i=0; i<w.size(); i++)
	  w[i] = 0;

	// the direction of %c substitutions is now reversed...
	map<string,string> exmap; 
	if (!ReadEquationFile(fname, exmap, vmap, cmap))
	  return ShowError(msg+"ReadEquationFile("+fname+") failed");

	WriteLog("Successfully read <"+fname+"> : "
		 +ToStr(exmap.size())+" equations, "
		 +ToStr( vmap.size())+" variables, "
		 +ToStr( cmap.size())+" constants.");

	for (auto i=exmap.begin(); i!=exmap.end(); i++) {
	  string s = i->first;
	  size_t p = s.find("#%c");
	  if (p==string::npos) {
	    p = s.find("#"+cname); // obs! partial match lscom123 vs lscom 1234??
	    if (p==string::npos)
	      return ShowError(msg+"#%c nor #"+cname+" found in <"+s+">");
	    s.replace(p+1, cname.size(), "%c");
	  }
	  emap[s] = i->second;
	} 
      }
    }

    for (size_t i=0; i<w.size(); i++)
      detw.push_back(make_pair(dets[i], w[i]));

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<double>
  Analysis::TrecvidSINweightSolveMath(const vector<pair<string,double> >& dw,
				      const vector<string>& varn,
				      const vector<double>& varv,
				      const map<string,double>& cns,
				      const map<string,string>& eqn) {
    string msg = "TrecvidSINweightSolveMath() 2x vec : ";

    if (varn.size()!=varv.size()) {
      ShowError(msg+"dimensionality mismatch 1");
      return vector<double>();
    }
    
    map<string,double> var;
    for (size_t i=0; i<varn.size(); i++)
      var[varn[i]] = varv[i];

    auto rr = TrecvidSINweightSolveMath(dw, var, cns, eqn);

    vector<double> r;
    for (auto i=rr.begin(); i!=rr.end(); i++)
      r.push_back(i->second);

    return r;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<pair<string,double> > 
  Analysis::TrecvidSINweightSolveMath(const vector<pair<string,double> >& dw,
				      const map<string,double>& var,
				      const map<string,double>& cns,
				      const map<string,string>& eqn) {
    string msg = "TrecvidSINweightSolveMath() map : ";

    vector<string> n;
    for (auto i=dw.begin(); i!=dw.end(); i++)
      n.push_back(i->first);

    vector<pair<string,double> > detw;

    map<string,string> ev = eqn;
    for (auto i=var.begin(); i!=var.end(); i++) {
      if (ev.find(i->first)!=ev.end()) {
	ShowError(msg+"variable name <"+i->first+"> duplicates");
	return detw;
      }
      ev[i->first] = ToStr(i->second);
    }
    for (auto i=cns.begin(); i!=cns.end(); i++) {
      if (ev.find(i->first)!=ev.end()) {
	ShowError(msg+"constant name <"+i->first+"> duplicates");
	return detw;
      }
      ev[i->first] = ToStr(i->second);
    }

    // cout << "[" << eqn.begin()->first << "] = [" << eqn.begin()->second << "]"
    // 	 << endl;

    vector<double> v = SolveMath(n, ev, true);
    if (v.size()!=dw.size()) {
      ShowError(msg+"dimensionality error");
      return detw;
    }
      
    for (size_t i=0; i<dw.size(); i++)
      detw.push_back(make_pair(n[i], v[i]));

    return detw;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidSINweights(const vector<string>& args) {
    const string msg = "AnalyseTrecvidSINweights() : ";

    if (args.size()<2)
      return ShowError(msg+"two arguments expected: <2013|2014|2015> "
		       "<eval|randomwalk|gradient>");

    const string year = args[0], method = args[1], fp = "F";
    if (year!="2013" && year!="2014" && year!="2015")
      return ShowError(msg+"the first argument should be: 2013|2014|2015");

    if (year=="2015" && method=="eval" && args.size()!=6)
      return ShowError(msg+"6 arguments expected:"
		       " eval 2015 moomin trType priority \"description\"");

    DataBase *db  = CheckDB();
    
    if (classname=="")
      return ShowError(msg+"class should be specified");
    
    if (detections.size()==0)
      return ShowError(msg+"detections should be specified");

    if (method!="eval" && method!="randomwalk" && method!="gradient")
      return ShowError(msg+"the second argument should be either \"eval\", "
		       "\"randomwalk\" or \"gradient\"");

    list<string> classes = db->SplitClassNames(classname);
    if (/*classes.size()>1 ||*/ method=="eval") {
      if (false && classes.size()>1 && method!="eval")
	return ShowError(msg+"multiple classes allowed only with \"eval\"");
      
      size_t nres = 2000;
      bool tolerate_missing = true;
      vector<pair<size_t,double> > dummy;
      return TrecvidSINweightsEval(classes, year, fp,
				   args[2], // moomin
				   args[3], // trType
				   args[4], // priority
				   args[5], // description
				   nres, tolerate_missing, true, dummy);
    }

    const ground_truth& gt = QueryRestrictionGT();
    vector<size_t> idxs = gt.indices(1);

    vector<pair<string,double> > detw;
    map<string,double> varmap;
    map<string,double> cnsmap;
    map<string,string> eqnmap;
    if (!DetectionsWithClasswiseWeights(detections, classname, filename,
					detw, varmap, cnsmap, eqnmap))
      return ShowError(msg+"DetectionsWithClasswiseWeights() failed");

    return method=="randomwalk"
      ? TrecvidSINweightsRandomWalk(idxs, detw, varmap, cnsmap, eqnmap,
				    classname, year, fp)
      : TrecvidSINweightsGradient(  idxs, detw, varmap, cnsmap, eqnmap,
				    classname, year, fp);
  }

  /////////////////////////////////////////////////////////////////////////////

  bool 
  Analysis::TrecvidSINweightsRandomWalk(const vector<size_t>& idxs,
					const vector<pair<string,double> >&
					detwin,
					const map<string,double>& /*varmap*/,
					const map<string,double>& /*cnsmap*/,
					const map<string,string>& /*eqnmap*/,
					const string& cname,
					const string& year,
					const string& fp) {
    const string msg = "TrecvidSINweightsRandomWalk() : ";

    double delta = 0.01;
    double best = 0.0;

    WriteLog(msg+"starting");

    vector<double> w, dw;
    for (size_t i=0; i<detwin.size(); i++)
      w.push_back(detwin[i].second);
    vector<double> bestvec = w;
    set<vector<double> > bestset;

    for (size_t r=0; r<1001; r++) {
      vector<pair<string,double> > detw;
      for (size_t i=0; i<detwin.size(); i++)
	detw.push_back(make_pair(detwin[i].first, w[i]));

      size_t nres = 2000;
      bool tolerate_missing = true, to_parent = true;
      double infap = TrecvidSINevaluate(idxs, "", detw, cname, year, fp, nres,
					tolerate_missing, to_parent);

      cout << "TrecvidInfAP ";
      bool hit = false;
      if (infap>best) {
	hit = true;
	cout << "BEST ";
	bestset.clear();

      } else if (infap==best)
	cout << "best ";

      if (infap>=best)
	bestset.insert(w);

      cout << r << " " << infap << " " << bestset.size();
      if (infap>best) {
	cout << " <classwiseweights class=\"" << classname << "\">"
	     << ToStr(w) << "</classwiseweights>";
	best = infap;
	bestvec = w;
      }
      cout << endl;

      if (infap<best)
	w = bestvec;

      vector<double> wold = w;
      double sum = 0;
      if (hit && dw.size()) {
	for (size_t i=0; i<w.size(); i++) {
	  w[i] += dw[i];
	  sum += w[i];
	}

      } else {
	for (size_t i=0; i<w.size(); i++) {
	  bool plus = rand()%2;
	  if (plus)
	    w[i] *= 1+delta;
	  else
	    w[i] /= 1+delta;
	  sum += w[i];
	}
      }

      dw.clear();
      for (size_t i=0; i<w.size(); i++) {
	w[i] /= sum;
	dw.push_back(w[i]-wold[i]);
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool 
  Analysis::TrecvidSINweightsGradient(const vector<size_t>& idxs,
				      const vector<pair<string,double> >&
				      detwin,
				      const map<string,double>& varmap,
				      const map<string,double>& cnsmap,
				      const map<string,string>& eqnmap,
				      const string& cname,
				      const string& year,
				      const string& fp) {
    const string msg = "TrecvidSINweightsGradient() : ";

    // double delta = 0.001; // ok with direct
    double delta0 = 0.05, deltad = 0.05, delta1 = 0.2; // ok??? with equations
    double admaxlimit = 0.001;
    double rmul  = 1e-6;
    double rexp  = 1;
    size_t n_below_thr = 7;

    bool allow_negative = false;
    size_t nres = 2000;
    bool tolerate_missing = true, to_parent = true;

    DataBase *db = CheckDB();
    list<string> flab = db->SplitClassNames(cname);
    for (auto i=flab.begin(); i!=flab.end(); i++)
      *i = db->LscomNameToTrecvidId(*i);

    WriteLog(msg+"starting with year="+year
	     +" class="+cname+" ("+ToStr(flab)+")"
	     +" delta0="+ToStr(delta0)
	     +" deltad="+ToStr(deltad)
	     +" delta1="+ToStr(delta1)
	     +" allow_negative="+ToStr((int)allow_negative)
	     +" admaxlimit="+ToStr(admaxlimit));

    bool with_eqns = true;
    for (auto j=detwin.begin(); with_eqns && j!=detwin.end(); j++)
      if (j->second!=0)
	with_eqns = false;
    if (with_eqns) {
      WriteLog(msg+"WITH EQUATIONS : "+ToStr(eqnmap.size())
	       +" equations, "+ToStr(varmap.size())+" variables, "
	       +ToStr(cnsmap.size())+" constants");
      if (detwin.size()!=eqnmap.size())
	return ShowError(msg+ToStr(detwin.size())+" variables vs. "
			 +ToStr(eqnmap.size())+" equations");
      for (auto i=detwin.begin(); i!=detwin.end(); i++)
	if (eqnmap.find(i->first)==eqnmap.end())
	  return ShowError(msg+"equation for variable not found");

    } else
      WriteLog(msg+"DIRECT OPTIMIZATION : "+ToStr(detwin.size())+" variables");

    vector<double> wopt;
    vector<string> nopt;
    vector<pair<string,double> > detw;
    if (with_eqns) {
      for (auto i=varmap.begin(); i!=varmap.end(); i++) {
	wopt.push_back(i->second);
	nopt.push_back(i->first);
      }
      detw = TrecvidSINweightSolveMath(detwin, varmap, cnsmap, eqnmap);

    } else
      for (size_t i=0; i<detwin.size(); i++) {
	wopt.push_back(detwin[i].second);
	nopt.push_back(detwin[i].first);
	detw.push_back(make_pair(detwin[i].first, wopt[i]));
      }

    vector<pair<string,double> > detwx = detw;
    double best = TrecvidSINevaluate(idxs, "", detw, cname, year, fp, nres,
				     tolerate_missing, to_parent);

    for (size_t l=0; l<1001; l++) {
      if (with_eqns) {
	vector<double> xxx
	  = TrecvidSINweightSolveMath(detwin, nopt, wopt, cnsmap, eqnmap);
	cox::blas::normalize(xxx, 1.0);
	for (size_t i=0; i<xxx.size(); i++)
	  detw[i].second = xxx[i];
      }

      multimap<double,size_t> detwval;
      cout << endl << "round=" << l << " " << best << " " << classname;
      for (size_t i=0; i<wopt.size(); i++)
	cout << " " << nopt[i] << "=" << wopt[i];
      cout << endl;

      for (size_t i=0; i<detw.size(); i++)
	detwval.insert(make_pair(detw[i].second, i));

      if (filename!="") {
	string fname = filename;
	size_t p = fname.find("%c");
	if (p!=string::npos)
	  fname.replace(p, 2, classname);
	if (!with_eqns) {
	  ofstream result(fname, ios::app);
	  result << "<classwiseweights class=\"" << classname << "\">"
		 << ToStr(wopt) << "</classwiseweights>" << endl;
	} else {
	  map<string,double> vars;
	  for (size_t i=0; i<wopt.size(); i++)
	    vars[nopt[i]] = wopt[i];
	  WriteEquationFile(fname+"."+ToStr(l), eqnmap, vars, cnsmap);
	}
      }

      vector<double> grad;
      bool non_zero_gradient_found = false;
      for (double deltav=delta0; deltav<=delta1; deltav+=deltad) {
	multimap<double,size_t> wval, gval;
	vector<double> grad1, grad2;
	for (size_t i=0; i<wopt.size(); i++) {
	  vector<double> woptx = wopt, wusex;
	  woptx[i] += deltav;
	  if (!with_eqns)
	    wusex = woptx;
	  else
	    wusex = TrecvidSINweightSolveMath(detwin, nopt, woptx, cnsmap, eqnmap);
	  cox::blas::normalize(wusex, 1.0);
	  for (size_t j=0; j<detwx.size(); j++)
	    detwx[j].second = wusex[j];

	  double infap_p = TrecvidSINevaluate(idxs, "", detwx, cname, year, fp, nres,
					      tolerate_missing, to_parent);

	  woptx = wopt;
	  woptx[i] -= deltav;
	  if (!with_eqns)
	    wusex = woptx;
	  else
	    wusex = TrecvidSINweightSolveMath(detwin, nopt, woptx, cnsmap, eqnmap);
	  cox::blas::normalize(wusex, 1.0);
	  for (size_t j=0; j<detwx.size(); j++)
	    detwx[j].second = wusex[j];
	  double infap_m = TrecvidSINevaluate(idxs, "", detwx, cname, year, fp, nres,
					      tolerate_missing, to_parent);
	
	  double v2 = (infap_p-infap_m)/(2*deltav);
	  grad2.push_back(v2);

	  double v1 = 0;
	  if (infap_p>infap_m && infap_p>best)
	    v1 = (infap_p-best)/deltav;
	  else if (infap_m>infap_p && infap_m>best)
	    v1 = (best-infap_m)/deltav;
	  grad1.push_back(v1);

	  cout << "component #" << i << " " << nopt[i] << " " << wopt[i] 
	       << " delta=" << deltav
	       << " change_-0=" << best-infap_m << " change_0+=" << infap_p-best
	       << " grad1=" << v1 << " grad2=" << v2 << endl;

	  double v = v1;

	  wval.insert(make_pair(wopt[i], i));
	  gval.insert(make_pair(v,       i));
	}

	grad = grad1;

	size_t nc = 5;
	cout << "max optw components:" << endl;
	for (auto i=wval.rbegin(); i!=wval.rend() && nc--; i++)
	  cout << "  " << i->first << " " << nopt[i->second] << endl;
	nc = 5;
	cout << "min optw components:" << endl;
	for (auto i=wval.begin(); i!=wval.end() && nc--; i++)
	  cout << "  " << i->first << " " << nopt[i->second] << endl;
	nc = 5;
	cout << "max optg components:" << endl;
	for (auto i=gval.rbegin(); i!=gval.rend() && nc--; i++)
	  cout << "  " << i->first << " " << nopt[i->second] << endl;
	nc = 5;
	cout << "min optg components:" << endl;
	for (auto i=gval.begin(); i!=gval.end() && nc--; i++)
	  cout << "  " << i->first << " " << nopt[i->second] << endl;
	nc = 5;
	cout << "max usew components:" << endl;
	for (auto i=detwval.rbegin(); i!=detwval.rend() && nc--; i++)
	  cout << "  " << i->first << " " << detw[i->second].first << endl;
	nc = 5;
	cout << "min usew components:" << endl;
	for (auto i=detwval.begin(); i!=detwval.end() && nc--; i++)
	  cout << "  " << i->first << " " << detw[i->second].first << endl;

	if (gval.begin()->first!=0 || gval.rbegin()->first!=0) {
	  non_zero_gradient_found = true;
	  break;
	}
	cout << "ZERO GRADIENT, incresing delta..." << endl;
      }

      if (!non_zero_gradient_found) {
	cout << "ENDING with ZERO GRADIENT, round=" << l << " final best=" << best << endl;
	break;
      }

      bool found_in_two = false;
      for (size_t t=0; t<2; t++) {
	vector<double> gg = grad;
	if (t==1) {
	  double maxa = 0;
	  for (size_t i=0; i<gg.size(); i++) {
	    double a = fabs(gg[i]);
	    if (a>maxa)
	      maxa = a;
	  }
	  for (size_t i=0; i<gg.size(); i++) {
	    double a = fabs(gg[i]);
	    if (a==maxa)
	      maxa = -1;
	    else
	      gg[i] = 0;
	  }
	}

	if (gg.size()!=wopt.size())
	  return ShowError(msg+"dimensionality error 123");

	map<double,double> res;
	double r0 = 1, r1 = 1e10, newbest = 0;
	vector<double> neww;

	size_t better_not_found = 0;
	bool done_with_admax = false;
	for (size_t i=0; i<20; i++) {
	  double dr = pow(0.5, i);
	  if (r0<=0)
	    r0 = dr;
	  cout << "t=" << t << " i=" << i << " r0=" << r0 << " r1=" << r1
	       << " dr=" << dr << endl;

	  size_t n_below_best = 0;
	  bool found = false, admax_exceeded = false;
	  vector<double> woptx_last;
	  for (double r=r0; r<=r1; r+=dr) {
	    double infap = res[r];
	    if (infap==0) {
	      double rx = rmul*exp(r*rexp);
	      vector<double> woptx = wopt, wusex;
	      for (size_t j=0; j<wopt.size(); j++) {
		woptx[j] += rx*gg[j];
		if (woptx[j]<0 && !allow_negative)
		  woptx[j] = 0;
	      }

	      if (!with_eqns)
		wusex = woptx;
	      else
		wusex = TrecvidSINweightSolveMath(detwin, nopt, woptx, cnsmap, eqnmap);

	      cox::blas::normalize(wusex, 1.0);
	      if (detwx.size()!=wusex.size())
		return ShowError(msg+"dimensionality error 234");
	      for (size_t j=0; j<detwx.size(); j++)
		detwx[j].second = wusex[j];

	      double admax = 0;
	      for (size_t j=0; j<detw.size(); j++) {
		double ad = fabs(detw[j].second-wusex[j]);
		if (ad>admax)
		  admax = ad;
	      }
	      admax_exceeded = admax>admaxlimit;
	      infap = TrecvidSINevaluate(idxs, "", detwx, cname, year, fp, nres,
					 tolerate_missing, to_parent);
	      cout << "  r=" << r << " rx=" << rx << " admax=" << admax
		   << " infap=" << infap;
	      if (admax_exceeded) {
		cout << " admax exceeded";
		infap = 0;
	      }
	      if (infap>=newbest)
		woptx_last = woptx;
	      res[r] = infap;
	      if (infap>newbest) {
		cout << "  NEWBEST";
		newbest = infap;
		neww = woptx;
		n_below_best = 0;
		found = true;
	      } else if (infap<newbest)
		n_below_best++;
	      cout << endl;
	    }

	    if ((i==0 && n_below_best>=n_below_thr) || admax_exceeded)
	      break;
	  }

	  if (found)
	    better_not_found = 0;
	  else
	    better_not_found++;
	  
	  if (better_not_found>2 && newbest>best)
	    break;

	  if (better_not_found>4)
	    break;

	  if (i==0 && admax_exceeded && newbest==best) {
	    done_with_admax = true;
	    neww = woptx_last;
	    cout << "NO IMPROVEMENT FOUND WITHIN admaxlimit, taking the longest jump"
		 << endl;
	    break;
	  }

	  multimap<double,double> ires;
	  for (auto j=res.begin(); j!=res.end(); j++)
	    ires.insert(make_pair(j->second, j->first));
	
	  auto br = ires.equal_range(newbest);
	  double minr = br.first->second, maxr = minr;
	  size_t brsize = 0;
	  cout << "    i=" << i << " BEST " << newbest << " :";
	  for (auto j=br.first; j!=br.second; j++, brsize++) {
	    if (j->second<minr)
	      minr = j->second;
	    if (j->second>maxr)
	      maxr = j->second;
	    cout << " " << j->second;
	  }
	  cout << " minr=" << minr << " maxr=" << maxr << endl;

	  r0 = minr-dr;
	  r1 = maxr+dr;

	  if (brsize>25) {
	    cout << "EXCEEDED brsize>25" << endl;
	    break;
	  }
	}

	if (newbest>best || done_with_admax) {
	  found_in_two = true;
	  best = newbest;
	  wopt = neww;
	  break;
	}
      }

      if (!found_in_two) {
	cout << "IMPROVEMENT NOT FOUND, final best=" << best << endl;
	break;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////
  
  double Analysis::TrecvidSINevaluate(const vector<size_t>& idxs,
				      const string& ofnamein,
				      const vector<pair<string,double> >& detw,
				      const string& cname, const string& year,
				      const string& fp, size_t nres,
				      bool tolerate_missing, bool to_parent) {
    string msg = "Analysis::TrecvidSINevaluate(...,"+cname+","+year+") : ";

    if (verbose>2)
      WriteLog(msg+"starting cname="+cname);

    DataBase *db = CheckDB();
    
    map<string,vector<size_t> > sel;
    
    list<string> flab = db->SplitClassNames(cname);

    string ofname;
    ofstream of;
    if (nres==(size_t)-1 && flab.size()==1 && ofnamein!="") {
      // LOC task in trecvid2015
      // ofname = "detvalues-"+*flab.begin()+".txt";
      ofname = ofnamein;
      of.open(ofname);
    }

    for (auto i=flab.begin(); i!=flab.end(); i++) {
      string flabx = db->LscomNameToTrecvidId(*i);

      if (verbose>2) {
	WriteLog(msg+"  starting");
	for (size_t j=0; j<detw.size(); j++)
	  cout << cname << " -> " << *i << " -> " << flabx << " " << year
	       << " " << detw[j].first << " = " << detw[j].second << endl;
      }

      vector<pair<string,double> > detwcls = detw;
      for (auto j=detwcls.begin(); j!=detwcls.end(); j++) {
	size_t p = j->first.find("%c");
	if (p==string::npos)
	  return ShowError(msg+"%c not found in \""+j->first+"\"");
	j->first.replace(p, 2, *i);
      }

      vector<pair<size_t,double> > hits =
	db->TrecvidSIN(idxs, detwcls, nres, tolerate_missing, to_parent);
    
      for (size_t i=0; i<hits.size(); i++) {
	size_t idx = hits[i].first;
	sel[flabx].push_back(idx);

	if (ofname!="") // LOC task in trecvid2015
	  of << db->Label(hits[i].first) << " " << hits[i].second << endl;
      }
    }

    if (ofname!="") {
      WriteLog("Stored detection values in <"+ofname+">");
      return 0;
    }

    string dname = "hello";
    size_t nresx = 0;

    return TrecvidInfAP(dname, sel, nresx, year, fp, verbose>1);
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecEval(const vector<string>& args) {
    const string msg = "AnalyseTrecEval() : ";

    if (args.size()!=2)
      return ShowError(msg+"shoud have two arguments: - <year> <F|P>");

    const string& year = args[0], fp = args[1];
    
    DataBase *db  = CheckDB();
    
    if (classname=="")
      return ShowError(msg+"class should be specified");
    
    if (detections.size()==0)
      return ShowError(msg+"detections should be specified");

    list<string> clslist = db->SplitClassNames(classname);
    const ground_truth& gt = QueryRestrictionGT();
    vector<size_t> idxs = gt.indices(1);

    analyse_result res;
    res.rescount = 0;
    res.inferredap = 0;

    for (size_t d=0; d<detections.size(); d++) {
      size_t nres = 0;

      string alldname = detections[d]+"#"+classname, dname = alldname;
      size_t p = dname.find('(');
      if (p!=string::npos) {
	dname.erase(p);
	dname += "-"+ToStr(getpid())+"-"+ToStr(d);
      }

      map<string,vector<size_t> > sel;

      for (auto c=clslist.begin(); c!=clslist.end(); c++) {
	const string& clsname = *c;
	string onedname = detections[d]+"#"+clsname;
	string lscom_str = db->LscomName(clsname, true, "lscom/trecvid2011");
	pair<string,string> lscom_pair = DataBase::SplitLscomName(lscom_str);
	string fnum = lscom_pair.second;
	string flab = ToStr(1000+atoi(fnum.c_str()));

	multimap<float,size_t> v;

	for (size_t i=0; i<idxs.size(); i++) {
	  target_type tt = db->ObjectsTargetType(idxs[i]);
	  if (PicSOM::TargetTypeFileFullMasked(tt)!=target_videosegment)
	    continue;

	  float val = 0.0;

	  bool dummy = true, allow_incore = false;
	  map<string,vector<float> >
	    detects = db->RetrieveOrProduceDetectionData(idxs[i], detections[d],
							 clsname, true, dummy,
							 allow_incore);
	  if (detects.size()>1) 
	    ShowError(msg+"detects.size()>1 for #"+ToStr(idxs[i])
		      +" <"+db->Label(idxs[i])+"> with detection \""+
		      onedname+"\"");
	
	  if (detects.size()<1)
	    ShowError(msg+"detects.size()<1 for #"+ToStr(idxs[i])
		      +" <"+db->Label(idxs[i])+"> with detection \""+
		      onedname+"\"");
	
	  if (detects.size()==1) {
	    if (detects.begin()->second.size()!=1)
	      ShowError(msg+"detection dimensionality != 1");
	    else
	      val = detects.begin()->second[0];
	  }

	  v.insert(make_pair(val, idxs[i]));
	  nres++;
	}
	
	size_t nmax = 2000, n = 0;
	for (auto i=v.rbegin(); i!=v.rend() && n<nmax; i++, n++)
	  sel[flab].push_back(i->second);
      }

      double infap = TrecvidInfAP(dname, sel, nres, year, fp, verbose>1);

      res.rescount++;
      res.inferredap += infap;
    }
    
    return res;
  }

  /////////////////////////////////////////////////////////////////////////////
  
  double Analysis::TrecvidInfAP(const string& dname,
				const map<string,vector<size_t> >& sel,
				size_t nres, const string& year,
				const string& fp, bool verb) const {
    string msg = "Analysis::TrecvidInfAP() : ";

    string current = ""; // "2015"

    string randomstr = Picsom()->HostName()+"-"+ToStr(getpid())+"-";

    string ename = "PicSOM:"+dname;
    string ofbase = "eval-"+dname;
    string ofname = randomstr+ofbase+".treceval";

    DataBase *db  = CheckDB();
    map<string,float> infap;

    ofstream os(ofname);

    size_t nlines = 0;
    for (auto c=sel.begin(); c!=sel.end(); c++) {
      size_t n = 0;
      for (auto i=c->second.begin(); i!=c->second.end(); i++, n++) {
	target_type tt = db->ObjectsTargetType(*i);
	if (PicSOM::TargetTypeFileFullMasked(tt)!=target_videosegment)
	  return ShowError(msg, "target type of <"+db->Label(*i)+
			   "> is not videosegment but "+TargetTypeString(tt));

	const string& label = Label(*i);
	string shotid = TrecvidShotId(label);
	if (shotid=="")
	  return ShowError(msg, "could not evaluate shot id for label \""+
			   label+"\" of #"+ToStr(*i));
	
	os << c->first << " " << 0 << " " << shotid << " " << n+1 << " " 
	   << 10000-n-1 << " " << ename << endl;
	nlines++;

	if (!os)
	  return ShowError(msg, "failed to write in result file <"+
			   ofname+">");
      }
    }

    os.close();
    if (verb || year==current)
      WriteLog("Stored "+ToStr(nlines)+" treceval result lines out of "+
	       ToStr(nres)+" detections in <"+ofname+"> in "+
	       ToStr(FileSize(ofname))+" bytes");

    if (year==current)
      return 0.0;

    string nstr, singlec;
    // if (sel.size()==38 || sel.size()==60) // 2013 2014
    //   nstr = ToStr(sel.size())+".";
    if (sel.size()==1)
      singlec = "."+sel.begin()->first;
    else
      if (year=="2013")
	nstr = "60."; // 38 cannot be selected this way anymore...

    string yy = year.size()==4 ? year.substr(2) : "XX";
    string dbdir       = Picsom()->RootDir("databases", true);
    string dbdirtv14   = dbdir+"/trecvid2014";
    string dbdirtvxx   = dbdir+"/trecvid"+year;
    string sample_eval = dbdirtv14+"/scripts/sample_eval.pl";
    string qrels = "qrels-not-specified";
    if (year=="2012")
      qrels = dbdirtvxx+"/results/sin/feature"+fp+".qrels.tv12";
    else // 2013 2014 2015
      qrels = dbdirtvxx+"/results/"+nstr+"feature"+fp+".qrels.tv"+yy+singlec;
    string resfile     = randomstr+"sample_eval-"+ofbase+".out";
    vector<string> cmd { sample_eval, "-q", qrels, ofname, "1>"+resfile };

    ((PicSOM*)Picsom())->ExecuteSystem(cmd, verb, verb, true);
    
    ifstream rf(resfile);
    for (;;) {
      string line;
      getline(rf, line);
      if (!rf)
	break;
      vector<string> comp = SplitInSpaces(line);
      if (comp.size()!=3)
	return ShowError(msg+"failed to parse ["+line+"] of <"+resfile+">");
      if (comp[0]=="infAP")
	infap[dname+"-"+comp[1]] = atof(comp[2].c_str());
    }

    if (!keeptmp) {
      Unlink(ofname);
      Unlink(resfile);
    }

    for (auto i=infap.begin(); i!=infap.end(); i++) {
      if (verb)
	cout << "infAP : " << i->first << " = " << i->second << endl;
      if (i->first.substr(i->first.size()-4)=="-all")
	return i->second;
    }

    return 0;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidMedOutput2013(const vector<string>& a) {
    const string msg = "AnalyseTrecvidMedOutput() : ";
    
    bool tolerate_missing_detections = true, binary_gt = true;

    bool debug1 = verbose>1, debug2 = verbose>2;

    DataBase *db  = CheckDB();
    
    if (classname=="")
      return ShowError(msg+"class should be specified");

    if (thresholds=="")
      return ShowError(msg+"thresholds should be specified");
    
    vector<string> thresh = SplitInCommas(thresholds);

    list<string> clslist = db->SplitClassNames(classname);
    
    size_t nargs = 6;
    if (a.size()!=nargs+clslist.size())
      return ShowError(msg+ToStr(a.size())+" arguments found while "+
		       ToStr(nargs+clslist.size())+" expected : "
		       "<do_mer> <sys> <search> <eventset> <extype> <version>"
		       " <E00x,...> <E00y,...> <E00z,...> ... "
		       "like: yes FullSys MED13DRYRUN PS 10Ex 1"
		       " Exxx,89.138,64.125,39.092,97.521,45.67 ...");

    float tpttotalval = 0, tptmetaval = 0;

    auto clslisti = clslist.begin();
    vector<vector<string> > infol;
    for (size_t i=nargs; i<a.size(); i++, clslisti++) {
      size_t ninfov = 6;
      vector<string> thr = SplitInCommas(a[i]);
      if (thr.size()!=ninfov)
	return ShowError(msg+"\""+a[i]+"\" should have "+ToStr(ninfov)+
			 " components");
      if (thr[0].find("E0")!=0)
	return ShowError(msg+"first component of \""+a[i]+"\" should "
			 "start with E0");

      string clsname = *clslisti;
      if (classprefix!="" && clsname.find(classprefix)!=0)
	return ShowError(msg+"class name \""+clsname+
			 "\" does not start with \""+classprefix+"\"");
      clsname.erase(0, classprefix.size());
      if (clsname!=thr[0])
	return ShowError(msg+"class name mismatch between \""+clsname+
			 "\" and \""+thr[0]+"\"");

      for (size_t j=1; j<ninfov; j++) {
	float v = atof(thr[j].c_str());
	if (!v)
	  return ShowError(msg+"component "+ToStr(j)+" of \""+a[i]+"\" should "
			   "be a float value");
	if (j<ninfov-2 || i==nargs)
	  tpttotalval += v;
	if (j==3 || (i==nargs && (j==4 || j==5)))
	  tptmetaval += v;
      }
      infol.push_back(thr);
    }

    string team     = "PicSOM";
    bool   do_mer   = IsAffirmative(a[0]);
    string sys      = a[1]; // "FullSys"
    string search   = a[2]; // "MED13DRYRUN"
    string eventset = a[3]; // "PS"
    string ektype   = a[4]; // "10Ex"
    string version  = a[5]; // "1"

    if (sys!="FullSys" && sys!="VisualSys" && sys!="AudioSys")
      return ShowError(msg+"eventset (now "+sys+") should be"
		       "FullSys|VisualSys|AudioSys|...");

    if (eventset!="AH" && eventset!="PS")
      return ShowError(msg+"eventset (now "+eventset+") should be PS|AH");

    if (ektype!="0Ex" && ektype!="10Ex" && ektype!="100Ex")
      return ShowError(msg+"ektype (now "+ektype+") should be 0Ex|10Ex|100Ex");

    int version_i = atoi(version.c_str());
    if (version!=ToStr(version_i) || version_i<1)
      return ShowError(msg+"version (now "+version+") "
		       "should be a positive integer");

    if (!do_mer && detections.size()!=1)
      return ShowError(msg+"exactly one detection (without #class)"
		       " should be specified when not doing MER");

    if (!do_mer && thresh.size()!=1)
      return ShowError(msg+"exactly one thresholds (without #class)"
		       " should be specified when not doing MER");

    if (do_mer && detections.size()!=2)
      return ShowError(msg+"exactly two detections (without #class)"
		       " should be specified when doing MER");

    if (do_mer && thresh.size()!=2)
      return ShowError(msg+"exactly two thresholds (without #class)"
		       " should be specified when doing MER");

    string expid = team+"_MED13_"+sys+"_"+search+"_"+
      eventset+"_"+ektype+"_"+version;
    
    string dir = "output/"+expid, mer_dir = dir+"/MER";;
    if (!Picsom()->MkDirHier(dir, 0755))
      return ShowError(msg+"failed to mkdir \""+dir+"\"");
    if (do_mer && !Picsom()->MkDirHier(mer_dir, 0755))
      return ShowError(msg+"failed to mkdir \""+mer_dir+"\"");

    string resfile = "MED13_"+team+"_"+search+"_"+eventset+"_"+version+".tgz";

    string detcsvf = dir+"/"+expid+".detection.csv";
    string thrcsvf = dir+"/"+expid+".threshold.csv";
    string destxtf = dir+"/"+expid+".txt";

    WriteLog("Writing detections  in <"+detcsvf+">");
    WriteLog("Writing thresholds  in <"+thrcsvf+">");
    WriteLog("Writing description in <"+destxtf+">");

    ofstream detcsv(detcsvf);
    ofstream thrcsv(thrcsvf);
    ofstream destxt(destxtf);

    string desfilename = db->ExpandPath("doc/descriptions/"+sys+".txt");
    string desfiletxt = FileToString(desfilename);
    WriteLog("Reading description from <"+db->ShortFileName(desfilename)+">");

    size_t tpt = desfiletxt.find("<TPTTOTAL>");
    if (tpt==string::npos)
      ShowError(msg+"<TPTTOTAL> not found in <"+
		db->ShortFileName(desfilename)+">");
    else {
      string tptvalstr = ToStr(tpttotalval);
      desfiletxt.replace(tpt, 10, tptvalstr);
      WriteLog("<TPTTOTAL> value "+tptvalstr+" inserted");
    }

    tpt = desfiletxt.find("<TPTMETA>");
    if (tpt==string::npos)
      ShowError(msg+"<TPTMETA> not found in <"+
		db->ShortFileName(desfilename)+">");
    else {
      string tptvalstr = ToStr(tptmetaval);
      desfiletxt.replace(tpt, 9, tptvalstr);
      WriteLog("<TPTMETA> value "+tptvalstr+" inserted");
    }

    destxt << "Section 1 Experiment Identifier" << endl << endl
	   << "  " << expid << endl << endl
	   << desfiletxt;
    destxt.close();

    thrcsv << "\"EventID\",\"DetectionThreshold\",\"DetectionTPT\","
	   << "\"EAGTPT\",\"EMDTPT\",\"EBGMDTPT\",\"SEARCHMDTPT\""
	   << endl;

    vector<float> thrval0, thrval1;
    for (size_t i=0; i<infol.size(); i++) {
      string thrfile = thresh[0], ctxt = infol[i][0];
      for (;;) {
	size_t p = thrfile.find("%c");
	if (p==string::npos)
	  break;
	thrfile.replace(p, 2, ctxt);
      }
      float thr = db->ThresholdValue(thrfile);
      if (thr<0)
	return ShowError(msg+"reading main threshold file <"+thrfile+
			 "> failed");
      string thrvalstr = ToStr(thr);
      float thrvaleff = atof(thrvalstr.c_str());
      thrval0.push_back(thrvaleff);
      WriteLog("Threshold main value "+ToStr(thr)+" read from <"+
	       db->ShortFileName(thrfile)+">");

      if (do_mer) {
	thrfile = thresh[1];
	for (;;) {
	  size_t p = thrfile.find("%c");
	  if (p==string::npos)
	    break;
	  thrfile.replace(p, 2, ctxt);
	}
	thr = db->ThresholdValue(thrfile);
	if (thr<0)
	  return ShowError(msg+"reading MER threshold file <"+thrfile+
			   "> failed");
	thrval1.push_back(thr);
	
	WriteLog("Threshold MER value "+ToStr(thr)+" read from <"+
		 db->ShortFileName(thrfile)+">");
      }

      vector<string> infox = infol[i];
      infox.insert(infox.begin()+1, thrvalstr);
      thrcsv << "\"" << JoinWithString(infox, "\",\"") << "\"" << endl;
    }
    thrcsv.close();

    if (thrval0.size()!=clslist.size())
      return ShowError(msg+"thrval0.size()!=clslist.size()");

    detcsv << "\"TrialID\",\"Score\"" << endl;

    set<string> detect;
    
    size_t thri = 0;
    for (auto c=clslist.begin(); c!=clslist.end(); c++, thri++) {
      ground_truth gt = db->GroundTruthExpression(*c, target_video, -1, false);

      string eventid = *c;
      size_t p = eventid.rfind("-E");
      if (p==string::npos)
	return ShowError(msg+"failed to parse ["+eventid+"]");
      eventid.erase(0, p+1);

      string dname   = detections.front()+"#"+eventid, dnamech;
      if (do_mer)
	dnamech = detections[1]+"#"+eventid;

      if (debug1) {
	cout << "STARTING " << *c << " with binary_gt="
	     << (binary_gt?"true":"false") << endl;
	db->GroundTruthSummary(gt);
	cout << endl;
      }

      for (size_t i=0; i<db->Size(); i++) {
	if (gt[i]==0 || (gt[i]==-1&&binary_gt))
	  continue;

	target_type tt = db->ObjectsTargetType(i);
	if (PicSOM::TargetTypeMasked(tt, true)!=target_video)
	  continue;

	bool dummy = true;
	map<string,vector<float> >
	  detects = db->RetrieveDetectionData(i, dname, true, dummy);
	if (detects.size()>1)
	  return ShowError(msg+"detects.size()>1 for #"+ToStr(i)
			   +" with detection \""+dname+"\"");
	
	if (detects.size()<1) {
	  ShowError(msg+"detects.size()<1 for #"+ToStr(i)
		    +" with detection \""+dname+"\"");
	  if (!tolerate_missing_detections)
	    return false;
	}

	if (detects.size() && detects.begin()->second.size()!=1)
	  ShowError(msg+"detection dimensionality != 1");

	float val = detects.size() ? detects.begin()->second[0] : 0.0;

	string label = Label(i);

	if (debug2)
	  cout << dname << " #" << i << " " << label << " " << val << endl;

	string clipid = label;
	if (clipid.size()>6)
	  clipid.erase(0, clipid.size()-6);
	string trialid = clipid+"."+eventid;
	string line = "\""+trialid+"\",\""+ToStr(val)+"\"";
	detect.insert(line);

	float effval = atof(ToStr(val).c_str());

	if (do_mer && effval>thrval0[thri]) {
	  float merthreshold = thrval1[thri];

	  map<string,string> event_name {
	    { "E001", "Attempting a board trick" },
	    { "E002", "Feeding an animal" },
	    { "E003", "Landing a fish" },
	    { "E004", "Wedding ceremony" },
	    { "E005", "Working on a woodworking project" },
	    { "E006", "Birthday party" },
	    { "E007", "Changing a vehicle tire" },
	    { "E008", "Flash mob gathering" },
	    { "E009", "Getting a vehicle unstuck" },
	    { "E010", "Grooming an animal" },
	    { "E011", "Making a sandwich" },
	    { "E012", "Parade" },
	    { "E013", "Parkour" },
	    { "E014", "Repairing an appliance" },
	    { "E015", "Working on a sewing project" },
	    // E016 ... E020 missing...
	    { "E021", "Attempting a bike trick" },
	    { "E022", "Cleaning an appliance" },
	    { "E023", "Dog show" },
	    { "E024", "Giving directions to a location" },
	    { "E025", "Marriage proposal" },
	    { "E026", "Renovating a home" },
	    { "E027", "Rock climbing" },
	    { "E028", "Town hall meeting" },
	    { "E029", "Winning a race without a vehicle" },
	    { "E030", "Working on a metal crafts project" }
	  };

	  map<string,string> info = CheckDB()->ReadOriginsInfo(i, false,
								 true);
	  string dim = info["dimensions"];
	  int w = 0, h = 0, nfr = 0;
	  float fps = 0.0;
	  if (sscanf(dim.c_str(), "%dx%dx%d@%f", &w, &h, &nfr, &fps)!=4) {
	    string opath  = db->SolveObjectPath(Label(i));
	    string tmpdir = db->TempDir("objsubranges", true);
	    videofile fv(opath, false, tmpdir);
	    w   = fv.get_width();
	    h   = fv.get_height();
	    fps = fv.get_frame_rate();
	    float sec = fv.get_length();
	    nfr = sec*fps;
	    float a = fv.get_aspect();
	    if (a)
	      w = (size_t)floor(h*a+0.5);
	  }

	  if (w==0 || h==0 || nfr==0 || fps==0)
	    return ShowError(msg+"failed to read width x height x "
			     "nframes @ fps in <"+dim+"> for #"+ToStr(i));
	  
	  XmlDom xml = XmlDom::Doc();
	  XmlDom mer = xml.Root("mer");
	  mer.Prop("system_ID", team+"_"+sys+"_"+search+"_"+
		   eventset+"_"+ektype);
	  mer.Prop("clip_ID",    "HVC"+clipid);
	  mer.Prop("event_ID",   eventid);
	  mer.Prop("event_name", event_name[eventid]);

	  const object_info *oi = CheckDB()->FindObject(i);
	  const vector<int>& cl = oi->children;

	  map<float,float> childval; // time in seconds, score value
	  for (size_t ci=0; ci<cl.size(); ci++) {
	    bool dummy = true;
	    map<string,vector<float> > detects =
	      db->RetrieveDetectionData(cl[ci], dnamech, true, dummy);
	    if (detects.size()>1)
	      return ShowError(msg+"detects.size()>1 for #"+ToStr(cl[ci])
			       +" with detection \""+dnamech+"\"");
	    if (detects.size()<1) {
	      ShowError(msg+"detects.size()<1 for #"+ToStr(cl[ci])
			+" with detection \""+dnamech+"\"");
	      if (!tolerate_missing_detections)
		return false;
	      continue;
	    }

	    if (detects.begin()->second.size()!=1)
	      ShowError(msg+"detection dimensionality != 1");

	    float chval = detects.begin()->second[0];
	    string label = Label(cl[ci]);
	    if (debug2)
	      cout << dnamech << " child #" << cl[ci] << " " << label
		   << " " << chval << (chval>merthreshold?" **":"") << endl;
	    size_t p = label.find(":s");
	    if (p==string::npos) 
	      return ShowError(msg+"no \":s\" in <"+label+">");
	    int sec = atoi(label.substr(p+2).c_str());
	    if (childval.find(sec)!=childval.end())
	      return ShowError(msg+"sec "+ToStr(sec)+" multiply defined");
	    childval[sec] = chval;
	  }

	  vector<pair<float,float> > childvalvec(childval.begin(),
						 childval.end());
	  vector<pair<size_t,pair<size_t,size_t> > > seq;
	  bool on = false;
	  for (size_t j=0; j<childvalvec.size(); j++)
	    if (childvalvec[j].second>merthreshold) {
	      if (!on) {
		seq.push_back(make_pair(j, make_pair(j, j)));
		on = true;
	      } else {
		seq.back().second.second = j;
		size_t& x = seq.back().first;
		if (childvalvec[j].second>childvalvec[x].second)
		  x = j;
	      }
	    } else
	      on = false;

	  if (debug2)
	    for (auto i=seq.begin(); i!=seq.end(); i++)
	      cout << "seq (" << i->first << ",(" << i->second.first
		   << "," << i->second.second << "))" << endl;
		
	  vector<pair<float,pair<float,float> > > seqvec;
	  for (size_t j=0; j<seq.size(); j++) {
	    float v = childvalvec[seq[j].first].second;
	    float a = childvalvec[seq[j].second.first].first -2;
	    float b = childvalvec[seq[j].second.second].first+2;
	    if (a<0)
	      a = 0;
	    if (b>childval.rbegin()->first+1)
	      b = childval.rbegin()->first+1;

	    if (seqvec.empty() || seqvec.back().second.second<a-2)
	      seqvec.push_back(make_pair(v, make_pair(a, b)));
	    else {
	      if (v>seqvec.back().first)
		seqvec.back().first = v;
	      seqvec.back().second.second = b;
	    }
	  }
	  
	  if (debug2)
	    for (auto i=seqvec.begin(); i!=seqvec.end(); i++)
	      cout << "seqvec (" << i->first << ",(" << i->second.first
		   << "," << i->second.second << "))" << endl;
		
	  multimap<float,pair<float,float> > oseq(seqvec.begin(),
						  seqvec.end());
	  if (debug1)
	    cout << oseq.size() << " sequences out of " << seq.size()
		 << " used as evidence" << endl;

	  size_t ono = 0;
	  for (auto oi=oseq.rbegin(); oi!=oseq.rend(); oi++, ono++) {
	    if (debug2)
	      cout << "observation " << ono << " : val=" << oi->first
		   << " start=" << oi->second.first << " end="
		   << oi->second.second << endl;

	    char con[100], imp[100], sta[100], end[100];
	    sprintf(con, "%.2f", oi->first);
	    sprintf(imp, "%.2f", 1.0); // obs! no other values...
	    sprintf(sta, "%.2f", oi->second.first);
	    sprintf(end, "%.2f", oi->second.second);

	    string start_time = sta, end_time = end;

	    string descr = /*no ? "some strange sounds" :*/
	      "visual content matches examples";

	    XmlDom observation = mer.Element("observation");
	    observation.Prop("id", "Obs"+ToStr(ono));
	    observation.Prop("description", descr);
	    observation.Prop("confidence", con);
	    observation.Prop("importance", imp);
	    observation.Prop("presentation_order", ToStr(ono+1));
	    XmlDom sources_list = observation.Element("sources_list");
	    XmlDom source = sources_list.Element("source");
	    source.Prop("type", "video"); // "non_speech_audio"
	    XmlDom snippet = observation.Element("snippet");
	    snippet.Prop("type", "video"); // "audio"/"keyframe"?
	    snippet.Prop("start_time", start_time);
	    snippet.Prop("end_time",   end_time);
	    if (true) {
	      string upper_left  = "0:0";
	      string lower_right = ToStr(w-1)+":"+ToStr(h-1);
	      XmlDom bounding_box_1 = snippet.Element("bounding_box");
	      bounding_box_1.Prop("type", "initial");
	      bounding_box_1.Prop("upper_left",  upper_left);
	      bounding_box_1.Prop("lower_right", lower_right);
	      XmlDom bounding_box_2 = snippet.Element("bounding_box");
	      bounding_box_2.Prop("type", "final");
	      bounding_box_2.Prop("upper_left",  upper_left);
	      bounding_box_2.Prop("lower_right", lower_right);
	    }
	  }
	  string mer_dir_e = mer_dir+"/"+eventid;
	  if (!Picsom()->MkDirHier(mer_dir_e, 0755))
	    return ShowError(msg+"failed to mkdir \""+mer_dir_e+"\"");
	  string merfile = mer_dir_e+"/"+trialid+".mer.xml";
	  xml.Write(merfile);
	}
      }
    }

    for (auto l=detect.begin(); l!=detect.end(); l++)
      detcsv << *l << endl;

    detcsv.close();

    vector<string> tarcmd { "tar", "cfz", resfile, "./output" };
    Picsom()->ExecuteSystem(tarcmd, true, true, true);

    // WriteLog("Consider: tar -cvf - ./output | gzip > "+resfile);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidMedOutput(const vector<string>& a) {
    const string msg = "AnalyseTrecvidMedOutput() : ";

    if (a.size()<1)
      return ShowError(msg+"argument SQ|EQ|ES missing");

    vector<string> b = a;
    b.erase(b.begin());

    if (a[0]=="SQ")
      return AnalyseTrecvidMedOutputSQ(b);
    
    if (a[0]=="EQ")
      return AnalyseTrecvidMedOutputEQ(b);
    
    if (a[0]=="ES")
      return AnalyseTrecvidMedOutputES(b);
    
    return ShowError(msg+"argument \""+a[0]+"\" not understood");;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidMedOutputSQ(const vector<string>& a) {
    const string msg = "AnalyseTrecvidMedOutputSQ() : ";
    
    if (a.size()!=1 || a[0].size()!=4 || a[0][0]!='E' ||
	a[0].find_first_not_of("0123456789", 1)!=string::npos)
      return ShowError(msg+"exactly one argument like \"E031\" needed");

    string fn = a[0]+"_SQ.xml";

    XmlDom doc;
    AnalyseTrecvidMedXML("query", "", GetDataBase()->TrecvidMedEvent(a[0]),
			 trecvid_med_event_scores(), doc);
    doc.Write(fn, true);

    WriteLog("Wrote TRECVID 2014 MED SQ file <"+fn+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidMedOutputEQ(const vector<string>& a) {
    const string msg = "AnalyseTrecvidMedOutputEQ() : ";
    
    if (a.size()!=2 || a[0].size()!=4 || a[0][0]!='E' ||
	a[0].find_first_not_of("0123456789", 1)!=string::npos ||
	(a[1]!="000Ex" && a[1]!="010Ex" && a[1]!="100Ex"))
      return ShowError(msg+"exactly two arguments like \"E031 100Ex\" needed");

    GetDataBase()->TrecvidMedEvent(a[0]).show();

    // string ename = GetDataBase()->TrecvidMedEventName(a[0]);

    string fn = a[0]+"_"+a[1]+".xml";

    trecvid_med_event_scores scores;
    scores.push_back(vector<float>());
    XmlDom doc;
    AnalyseTrecvidMedXML("query", "", GetDataBase()->TrecvidMedEvent(a[0]),
			 scores, doc);
    doc.Write(fn, true);

    WriteLog("Wrote TRECVID 2014 MED EQ file <"+fn+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidMedOutputES(const vector<string>& a) {
    const string msg = "AnalyseTrecvidMedOutputES() : ";
    
    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection should be specified");

    if (a.size()<2 || a[0].size()!=4 || a[0][0]!='E' ||
	a[0].find_first_not_of("0123456789", 1)!=string::npos ||
	(a[1]!="SQ" && a[1]!="000Ex" && a[1]!="010Ex" && a[1]!="100Ex"))
      return ShowError(msg+"first two arguments like \"E031 SQ|100Ex\" needed");

    if (a.size()<3 || (a[2]!="1" && a[2]!="0"))
      return ShowError(msg+"third PRF argument should be either 0 or 1");

    if (a.size()!=4)
      return ShowError(msg+"fourt argument should be restriction "
		       "like \"MED14-Test\"");

    classname  = a[0];
    string ex  = a[1];
    bool   prf = IsAffirmative(a[2]);

    query->SetTemporalRestriction(a[3], target_video, -1);

    // bool debug1 = verbose>1, debug2 = verbose>2;

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("TrecvidMedOutputES", mstr,
				    gtl, extra);

    DataBase *db  = CheckDB();

    string detname = detections[0]+"#"+classname;

    multimap<float,size_t> val;
    for (size_t idx=0; idx<db->Size(); idx++) {
      if (restr[idx]!=1)
	continue;

      bool dummy = true;
      map<string,vector<float> > detects =
	  db->RetrieveDetectionData(idx, detname, true, dummy);
      if (detects.size()!=1)
	return ShowError(msg+"detects.size()!=1");
      if (detects.begin()->second.size()!=1)
	return ShowError(msg+"detects.begin()->size()!=1");
    
      val.insert(make_pair(-detects.begin()->second[0], idx));
    }

    // dry run stuff:
    float thrval = 0.99717;

    string tardir = classname+"_"+ex+".recountings";
    int mode = 02775;
    Picsom()->MkDir(tardir, mode);

    const DataBase::trecvid_med_event
      ev = GetDataBase()->TrecvidMedEvent(a[0]);

    string detfilename = classname+"_"+ex+".detections.csv";
    ofstream det(detfilename);
    det << "EventID,QueryType,PRF,VideoID,Score,Rank" << endl;

    size_t rank = 1, thrrank = 0;
    for (auto i=val.begin(); i!=val.end(); i++, rank++) {
      float val = -i->first;
      string videoid = Label(i->second).substr(2);
      det << classname << ","
	  << ex << ","
	  << (prf?"PRF":"noPRF") << ","
	  << videoid << ","
	  << val << ","
	  << rank << endl;

      if (val>thrval) { // or >= ???
	thrrank = rank;
	
	trecvid_med_event_scores scores;
	vector<float> vec { val };
	scores.push_back(vec);

	for (size_t j=1; j<5; j++) {
	  const vector<string>& evv = j==1 ? ev.scene :
	    j==2 ? ev.objects : j==3 ? ev.activities : ev.audio;
	  vector<float> vv;
	  for (size_t k=0; k<evv.size(); k++)
	    vv.push_back(val/(k+2));
	  scores.push_back(vv);
	}

	XmlDom doc;
	AnalyseTrecvidMedXML("recounting", videoid, ev, scores, doc);
	doc.Write(tardir+"/"+videoid+"."+classname+".mer.xml", true);
      }
    }

    string thrfilename = classname+"_"+ex+".threshold.csv";
    ofstream thr(thrfilename);
    thr << "EventID,QueryType,PRF,"
	<< "DetectionThresholdScore,DetectionThresholdRank" << endl
	<< classname << ","
	<< ex << ","
	<< (prf?"PRF":"noPRF") << ","
	<< thrval << ","
	<< thrrank << endl;
    
    string merfilename = tardir+".tgz";
    vector<string> tarcmd {
      "cd", tardir, ";",
	"tar", "cfz", "../"+merfilename, "*" };
    Picsom()->ExecuteSystem(tarcmd, true, true, true);

    WriteLog("Stored "+ToStr(rank-1)+" detections in <"+detfilename+
	     ">, threshold value "+ToStr(thrval)+" and rank "+
	     ToStr(thrrank)+" in <"+thrfilename+"> and recountings in <"+
	     merfilename+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AnalyseTrecvidMedXML(const string& type, const string& vid,
				      const DataBase::trecvid_med_event& ev,
				      const trecvid_med_event_scores& sc,
				      XmlDom& doc) {
    const string msg = "AnalyseTrecvidMedXML() : ";
    
    doc = XmlDom::Doc();
    XmlDom q = doc.Root(type);
    q.Prop("eventID", ev.event_id);
    if (vid!="")
      q.Prop("videoID", vid);
    XmlDom node = q.Element("node");
    node.Prop("id",   ev.event_id);
    node.Prop("name", ev.event_name);
    node.Prop("eq",   "MAX");
    
    if (sc.size()) {
      if (sc[0].size())
	node.Prop("score", ThreeDigits(sc[0][0]));
      XmlDom detector = node.Element("detector");
      detector.Prop("id",   "D");
      detector.Prop("name", "Detected "+ev.event_name);
      if (sc[0].size())
	detector.Prop("score", ThreeDigits(sc[0][0]));
      // detector.Cdata(XXX);
    }

    float max = 0;

    XmlDom node_S = node.Element("node");
    node_S.Prop("id", "S");
    node_S.Prop("name", "Semantic "+ev.event_name);
    node_S.Prop("eq", "MAX");

    for (size_t i=1; i<5; i++) {
      const vector<string>& evv = i==1 ? ev.scene :
	i==2 ? ev.objects : i==3 ? ev.activities : ev.audio;
      
      const string& evs= i==1 ? "Scene" :
	i==2 ? "Objects" : i==3 ? "Activities" : "Audio";

      XmlDom node_Si = node_S.Element("node");
      node_Si.Prop("id", "S"+ToStr(i));
      node_Si.Prop("name", ev.event_name+" "+evs);
      node_Si.Prop("eq", "MAX");
      if (sc.size()>i) {
	float nmax = 0;
	for (size_t j=0; j<sc[i].size() && j<evv.size(); j++)
	  if (sc[i][j]>nmax)
	    nmax = sc[i][j];
	node_Si.Prop("score", ThreeDigits(nmax));
	if (nmax>max)
	  max = nmax;
      }
      for (size_t j=0; j<evv.size(); j++) {
	float v = sc.size()>i && j<sc[i].size() ? sc[i][j] : 0;
	XmlDom tag = node_Si.Element("tag");
	tag.Prop("id",  "S"+ToStr(i)+"."+ToStr(j+1));
	tag.Prop("name", evv[j]);
	if (sc.size()>i) {
	  tag.Prop("score", ThreeDigits(v));
	  if (v) {
	    if (evs!="Audio") {
	      XmlDom visual_evidence = tag.Element("visual_evidence");
	      visual_evidence.Prop("key",  "yes");
	      visual_evidence.Prop("start", 5);
	      visual_evidence.Prop("end",   10);
	      visual_evidence.Prop("score", ThreeDigits(v));
	      visual_evidence.Prop("start_upper_left",  "10:20");
	      visual_evidence.Prop("start_lower_right", "180:240");
	      visual_evidence.Prop("end_upper_left",    "100:200");
	      visual_evidence.Prop("end_lower_right",   "280:340");

	      XmlDom ocr_evidence = tag.Element("ocr_evidence");
	      ocr_evidence.Prop("key",  "yes");
	      ocr_evidence.Prop("start", 5);
	      ocr_evidence.Prop("end",   10);
	      ocr_evidence.Prop("score", ThreeDigits(v/2));
	      ocr_evidence.Prop("start_upper_left",  "10:20");
	      ocr_evidence.Prop("start_lower_right", "180:240");
	      ocr_evidence.Prop("end_upper_left",    "100:200");
	      ocr_evidence.Prop("end_lower_right",   "280:340");
	      ocr_evidence.Prop("end_lower_right",   "280:340");
	      ocr_evidence.Prop("text", evv[j]);
	    } else {
	      XmlDom asr_evidence = tag.Element("asr_evidence");
	      asr_evidence.Prop("key",  "yes");
	      asr_evidence.Prop("start", 105.5);
	      asr_evidence.Prop("end",   110.1);
	      asr_evidence.Prop("score", ThreeDigits(v));
	      asr_evidence.Prop("text", evv[j]);
	    }
	  }
	}
      }
    }

    if (sc.size()>1)
      node_S.Prop("score", ThreeDigits(max));

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  string Analysis::ThreeDigits(float v) {
    v += 0.0005;
    if (v<0.001)
      return "0.000";

    string s = ToStr(v);
    size_t p = s.find('.');
    if (p==string::npos) {
      p = s.size();
      s += ".";
    }
    s += "000";
    s.erase(p+4);

    return s;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool 
  Analysis::TrecvidSinOutputInner(const string& year,
				  const string& moomin,
				  const string& trType,
				  const string& priority,
				  const string& desc,
				  const list<pair<string,vector<size_t> > >
				  &reslist) {
    const string msg = "TrecvidSinOutputInner() : ";
    
    // bool debug1 = verbose>0, debug2 = verbose>1;

    DataBase *db  = CheckDB();

    if (year.substr(0, 3)!="201")
      return ShowError(msg+"year argument should start as 201");

    if (trType!="A" && trType!="B" && trType!="C" && 
	trType!="D" && trType!="E" && trType!="F")
      return ShowError(msg+"trType argument should be one of A|B|C|D|E|F");

    if (priority.find_first_not_of("123456789")!=string::npos)
      return ShowError(msg+"priority argument should be numeric 1,...");

    string team    = "PicSOM";
    string xmlfile = team+"_TRECVID"+year+"_SIN_"+moomin+"_"
      +trType+"_"+priority+".xml";

    // notice the year here too...
    string dtd = "http://www-nlpir.nist.gov/projects/tv2015/"
      "dtds/videoFeatureExtractionResults.dtd";
    XmlDom xml = XmlDom::Doc("videoFeatureExtractionResults", "", dtd);

    XmlDom res = xml.Root("videoFeatureExtractionResults");
    XmlDom run = res.Element("videoFeatureExtractionRunResult");
    run.Prop("trType", trType);
    run.Prop("pid", "PicSOM");
    run.Prop("class", "M");
    run.Prop("targetData", "2C"); // 2A=2013, 2B=2014, 2C=2015
    run.Prop("priority", priority);
    // run.Prop("loc", "N"); // removed in 2015
    run.Prop("desc", desc);

    for (auto c=reslist.begin(); c!=reslist.end(); c++) {
      const string& cls = c->first;
      string lscomnum  = db->LscomName(cls, true, "lscom/trecvid2011");
      pair<string,string> lscom = DataBase::SplitLscomName(lscomnum);
      string fnum = lscom.second;

      XmlDom fea = run.Element("videoFeatureExtractionFeatureResult");
      fea.Prop("fNum", fnum);
      
      size_t n = 1, n_max = 2000;
      for (auto i=c->second.begin(); i!=c->second.end() && n<=n_max; i++, n++) {
	string label = Label(*i);
	string vid = label.substr(0, 5), sht = label.substr(5);
	while (vid[0]=='0')
	  vid.erase(0, 1);
	while (sht[0]=='0')
	  sht.erase(0, 1);
	string shotid = "shot"+vid+"_"+sht;

	XmlDom item = fea.Element("item");
	item.Prop("seqNum", ToStr(n));
	item.Prop("shotId", shotid);
      }
    }

    xml.Write(xmlfile);
    WriteLog("Stored TRECVID SIN results in <"+xmlfile+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidLocOutput(const vector<string>& a) {
    const string msg = "AnalyseTrecvidLocOutput() : ";
    
    // bool debug1 = verbose>0, debug2 = verbose>1;

    DataBase *db  = CheckDB();

    if (classname=="")
      return ShowError(msg+"class should be specified");

    if (a.size()!=1 && a.size()!=2)
      return ShowError(msg+"one or two arguments should be given: "
		       "avgbox|detposneg|...");

    if (a[0]=="avgbox") {
      vector<double> sum(4);

      auto l = db->ReadClassWithBoxesValues(classname);
      for (auto i=l.begin(); i!=l.end(); i++) {
	map<string,string> hash = db->ReadOriginsInfo(i->first, true, true);
	size_t w = atoi(hash["width" ].c_str());
	size_t h = atoi(hash["height"].c_str());

	if (w==0 || h==0) { // trecvid2015...
	  imagedata img = db->ImageData(i->first);
	  w = img.width();
	  h = img.height();
	}

	if (w==0 || h==0)
	  return ShowError(msg+"zero size for #"+ToStr(i->first));

	cout << "[" << i->first << "] "
	     << w << "x" << h << " "
	     << i->second.first[0] << " "
	     << i->second.first[1] << " "
	     << i->second.first[2] << " "
	     << i->second.first[3] << " "
	     << i->second.second << " "
	     << endl;

	if (i->second.first[2]>=w)
	  i->second.first[2] = w-1;
	if (i->second.first[3]>=h)
	  i->second.first[3] = h-1;

	sum[0] += i->second.first[0]/double(w-1);
	sum[1] += i->second.first[1]/double(h-1);
	sum[2] += i->second.first[2]/double(w-1);
	sum[3] += i->second.first[3]/double(h-1);
      }

      cout << classname << " total " << l.size() << " bboxes with avg";
      for (size_t j=0; j<4; j++) {
	sum[j] /= l.size();
	cout << " " << sum[j];
      }
      cout << endl;      

      return true;
    }

    if (a[0]=="detposneg") {
      if (a.size()!=2)
	return ShowError(msg+"detposneg required second argument"
			 " priority=-|1|2|3|4");

      if (detections.size()!=1)
	return ShowError(msg+"exactly one detections should be specified");

      string cstr = db->LscomNameToTrecvidId(classname, false);

      string priority = a[1];
      bool do_thr  = priority!="-";
      bool avgbbox = false, avgbboxthrx = false, constthr = false;
      bool insdet = false, comb_dpm = false;
      if (priority=="4")
	avgbbox = avgbboxthrx = insdet = true;
      if (priority=="3")
	constthr = comb_dpm = true;
      if (priority=="2")
	avgbboxthrx = insdet = comb_dpm = true;
      if (priority=="1")
	avgbboxthrx = constthr = insdet = comb_dpm = true;

      map<string,vector<float> > avgbboxmap;
      map<string,float>          avgbboxthrmap;
      float constthrval = 0.28;

      vector<pair<size_t,pair<vector<size_t>,float> > > det;

      if (insdet) {
	list<string> classes = { classname };
	vector<pair<size_t,double> > detins;
	TrecvidSINweightsEval(classes, "2015", "F", "moomin", "D", priority,
			      "description here...",
			      (size_t)-1, false, false, detins);

	for (auto i=detins.begin(); i!=detins.end(); i++)
	  det.push_back(make_pair(i->first, make_pair(vector<size_t>(),
						      i->second)));
      }

      if (comb_dpm) {
	map<size_t,pair<vector<size_t>,float> > detmap(det.begin(),
						       det.end());
	det.clear();

	string cbvname = "loc-testimage2015-"+classname+"-comb";

	list<pair<size_t,pair<vector<size_t>,float> > > cbv
	  = db->ReadClassWithBoxesValues(cbvname);

	WriteLog("Read "+ToStr(cbv.size())+" boxes&values from <"
		 +cbvname+">");

	for (auto i=cbv.begin(); i!=cbv.end(); i++) {
	  auto c = *i;
	  if (priority=="2" || priority=="1") {
	    if (detmap.find(i->first)==detmap.end())
	      return ShowError("not found in detmap");
	    if (priority=="2")
	      c.second.second =  detmap[i->first].second;
	    else
	      c.second.second += detmap[i->first].second;
	  }
	  det.push_back(c);
	}
      }

      size_t n = 0;
      string ofname = "submission-"+priority+"-"+classname+".out";
      ofstream of(ofname);
      for (auto i=det.begin(); i!=det.end(); i++) {
	const string& label = db->Label(i->first);
	string file = label.substr(0, 5);
	size_t p = label.find(":if");
	string frame = label.substr(p+3);

	cout << "[" << label << "][" << file << "][" << frame << "] "
	     << i->second.second << endl;

	size_t ulx = 0, uly = 0, lrx = 0, lry = 0;

	if (avgbbox || avgbboxthrx) {
	  if (avgbboxmap.find(classname)==avgbboxmap.end()) {
	    string bbf = db->ExpandPath("loc/avg-boxes.txt");
	    string bb = FileToString(bbf);
	    vector<string> ll = SplitInSomething("\n", false, bb);
	    bool found = false;
	    for (auto j=ll.begin(); j!=ll.end() && !found; j++) {
	      if ((*j)[0]=='#')
		continue;
	      size_t p = j->find_first_of(" \t");
	      if (p!=string::npos && j->substr(0, p)==classname) {
		p = j->find_first_not_of(" \t", p);
		vector<string> vs = SplitInSpaces(j->substr(p));
		if (vs.size()!=5)
		  return ShowError(msg+"should be 4 bb coordinates + "
				   "threshold for <"+classname+">");
		vector<float> v(4);
		for (size_t k=0; k<4; k++)
		  v[k] = atof(vs[k].c_str());
		avgbboxmap[classname] = v;
		avgbboxthrmap[classname] = atof(vs[4].c_str());
		found = true;
		WriteLog("Read avg bbox "+ToStr(v)+" with threshold "
			 +ToStr(avgbboxthrmap[classname])+" for <"+
			 classname+"> from <"+db->ShortFileName(bbf)+">");
	      }
	    }
	    if (!found)
	      return ShowError(msg+"should bb coordinates for <"
			       +classname+"> not found");
	  }
	}

	if (avgbbox) {
	  const vector<float>& v =  avgbboxmap[classname];
	  size_t par = i->first;
	  for (;;) {
	    int t = db->ParentObject(par, false);
	    if (t==-1)
	      break;
	    par = t;
	  }
	  map<string,string> hash = db->ReadOriginsInfo(par, true, true);
	  size_t w = atoi(hash["width" ].c_str());
	  size_t h = atoi(hash["height"].c_str());
	  ulx = (size_t)floor(v[0]*w+0.5);
	  uly = (size_t)floor(v[1]*h+0.5);
	  lrx = (size_t)floor(v[2]*w+0.5);
	  lry = (size_t)floor(v[3]*h+0.5);

	} else {
	  ulx = i->second.first[0];
	  uly = i->second.first[1];
	  lrx = i->second.first[2];
	  lry = i->second.first[3];
	}

	float thr = 0;
	if (do_thr) {
	  if (avgbboxthrx)
	    thr += avgbboxthrmap[classname];
	  if (constthr)
	    thr += constthrval;
	}
	if (i->second.second<thr)
	  continue;

	of << cstr << " " << file << " " << frame << " "
	   << ulx << " " << uly << " " << lrx << " " << lry << endl;
	n++;
      }

      WriteLog("Wrote "+ToStr(n)+" positive detections out of "+
	       ToStr(det.size())+" in <"+ofname+">");
    }

    return true;
  }
    
  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidVttOutput(const vector<string>& a) {
    const string msg = "AnalyseTrecvidVttOutput() : ";

    bool tolerate_missing = true;
    DataBase *db  = CheckDB();

    if (a.size()!=3)
      return ShowError(msg+"three arguments should be given: "
		       "<year> <textindex> <out-file-name>");

    const string& year   = a[0];
    const string& tindex = a[1];
    const string& outfn  = a[2];

    string tset, ev = db->ExpandPath("evaluation");
    if (year=="2016")
      tset = ev+"/vines.url.testingSet";
    if (year=="2017")
      tset = ev+"/testing.URLs.video.description.subtask";
    if (year=="2018")
      tset = ev+"/testing.URLs.video.description.subtask.18";
    if (tset=="")
      return ShowError(msg+"year=<"+year+"> is not known");
    
    if (!FileExists(tset))
      return ShowError(msg+"file <"+tset+"> does not exist");

    if (!db->HasTextIndex(tindex))
      return ShowError(msg+"textindex <"+tindex+"> does not exist");

    map<string,size_t> url2idx;
    for (size_t i=0; i<db->Size(); i++)
      if (db->ObjectsTargetTypeContains(i, target_videofile)) {
	auto m = db->ReadOriginsInfo(i, false, false);
	if (url2idx.find(m["url"])!=url2idx.end())
	  return ShowError(msg+"url=<"+m["url"]+"> already exists");
	url2idx[m["url"]] = i;
      }

    ofstream os(outfn);
    os << "runType=N" << endl;

    string t = FileToString(tset);
    vector<string> ll = SplitInSomething("\n", true, t);
    for (auto l : ll) {
      StripWhiteSpaces(l);
      if (l=="")
	continue;
      vector<string> bb = SplitInSpaces(l);
      if (bb.size()!=2)
	return ShowError(msg+"line <"+l+"> does not split in two");
      string x = bb[1];
      size_t p = x.rfind('/');
      if (p!=string::npos)
	x.erase(0, p+1);

      bool found = url2idx.find(x)!=url2idx.end();
      if (!found)
	cout << "FILE <" << x << "> not found" << endl;

      string ccc = "FILE NOT FOUND";
      if (found) {
	size_t idx1 = url2idx[x], idx2 = -1;
	ground_truth gt1(db->Size());
	gt1[idx1] = 1;
	auto cc = db->TextIndexLines(tindex, "text", gt1);
	if (cc.size()==0) {
	  idx2 = db->MiddleFrameTrick(idx1, false);
	  ground_truth gt2(db->Size());
	  gt2[idx2] = 1;
	  cc = db->TextIndexLines(tindex, "text", gt2);
	}
	if (cc.size()!=1) {
	  if (!tolerate_missing)
	    return ShowError(msg+"TextIndexLines() failed with "+tindex+
			     " #"+ToStr(idx1)+" #"+ToStr(idx2));
	  else {
	    textline_t l(db, int(idx2)!=-1?idx2:idx1);
	    l.add("** caption not found **", 0.0);
	    cc.push_back(l);
	  }
	}

	if (cc.front().txt_val.size()>1 &&
	    cc.front().txt_val[0].first=="") {
	  cc.front().txt_val.erase(cc.front().txt_val.begin());
	  cout << "SKIPPED EMPTY CAPTION" << endl;
	}

	if (cc.front().txt_val.size()<1)
	  return ShowError(msg+"<"+tindex+"> didn't contain value for #"+
			   ToStr(idx1)+" "+db->Label(idx1)+" nor #"+
			   ToStr(idx2)+" "+db->Label(idx2)+" nor #");
      
	ccc = cc.front().txt_val[0].first;
      }
      
      os   << bb[0] << " " << ccc << endl;
      cout << bb[0] << " " << ccc << endl;
    }

    WriteLog("Stored "+ToStr(ll.size())+" lines in <"+outfn+">");

    return true;
  }
    
  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrecvidSinOutput(const vector<string>& a) {
    /// OBS!!!
    /// OBS!!! This should call TrecvidSinOutputInner() 
    /// OBS!!! XML out-dated as of 2015 -- corresponds to 2014 settings
    /// OBS!!!

    const string msg = "AnalyseTrecvidSinOutput() : ";
    
    ShowError(msg+"out-dated, should be converted to use TrecvidSinOutputInner()");

    bool debug1 = verbose>0, debug2 = verbose>1;

    DataBase *db  = CheckDB();
    
    if (classname=="")
      return ShowError(msg+"class should be specified");
    
    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection (without #class)"
		       " should be specified");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("TrecvidSinOutput", mstr,
				    gtl, extra);

    list<string> clslist = db->SplitClassNames(classname);

    if (a.size()!=4)
      return ShowError(msg+"3 arguments expected:"
		       " <moomin_character> <trType> <priority> <desc>"
		       " like: stinky A 1 \"PicSOM run with...\"");

    string moomin   = a[0];
    string trType   = a[1];
    string priority = a[2];
    string desc     = a[3];

    if (trType!="A" && trType!="B" && trType!="C" && 
	trType!="D" && trType!="E" && trType!="F")
      return ShowError(msg+"the 2nd argument should be one of A|B|C|D|E|F");

    if (priority.find_first_not_of("123456789")!=string::npos)
      return ShowError(msg+"the 3rd argument should be numeric priority 1,...");

    string team    = "PicSOM";
    string xmlfile = team+"_TRECVID2014_SIN_"+moomin+"_"+trType+"_"+priority+".xml";

    string dtd = "http://www-nlpir.nist.gov/projects/tv2014/"
      "dtds/videoFeatureExtractionResults.dtd";
    XmlDom xml = XmlDom::Doc("videoFeatureExtractionResults", "", dtd);

    XmlDom res = xml.Root("videoFeatureExtractionResults");
    XmlDom run = res.Element("videoFeatureExtractionRunResult");
    run.Prop("trType", trType);
    run.Prop("pid", "PicSOM");
    run.Prop("class", "M");
    run.Prop("targetData", "2B");
    run.Prop("priority", priority);
    run.Prop("loc", "N");
    run.Prop("desc", desc);

    for (auto c=clslist.begin(); c!=clslist.end(); c++) {
      string lscomnum  = db->LscomName(*c, true, "trecvid2011");
      pair<string,string> lscom = DataBase::SplitLscomName(lscomnum);
      string fnum = lscom.second;

      XmlDom fea = run.Element("videoFeatureExtractionFeatureResult");
      fea.Prop("fNum", fnum);
      
      string dname = detections.front()+"#"+*c;

      if (debug1)
	cout << "STARTING " << *c << " = " << lscom.first << " = "
	     << fnum << " from " << dname << endl;

      multimap<float,string> validmap;

      for (size_t i=0; i<db->Size(); i++) {
	target_type tt = db->ObjectsTargetType(i);
	if (PicSOM::TargetTypeFileFullMasked(tt)!=target_videosegment)
	  continue;
	
	if (restr[i]!=1)
	  continue;

	bool dummy = true;
	map<string,vector<float> > detects =
	  db->RetrieveDetectionData(i, dname, true, dummy);
	if (detects.size()>1)
	  return ShowError(msg+"detects.size()>1 for #"+ToStr(i)
			   +" with detection \""+dname+"\"");
	
	if (detects.size()<1)
	  return ShowError(msg+"detects.size()<1 for #"+ToStr(i)
			   +" with detection \""+dname+"\"");
	
	if (detects.begin()->second.size()!=1)
	  ShowError(msg+"detection dimensionality != 1");

	float val = detects.begin()->second[0];

	string label = Label(i);
	string vid = label.substr(0, 5), sht = label.substr(5);
	while (vid[0]=='0')
	  vid.erase(0, 1);
	while (sht[0]=='0')
	  sht.erase(0, 1);
	string shotid = "shot"+vid+"_"+sht;

	if (debug2) {
	  cout << dname << " #" << i << " " << label << " " << " "
	       << shotid << " " << val;
	  cout << endl;
	}

	validmap.insert(make_pair(val, shotid));
      }

      size_t n = 1, n_max = 2000;
      for (auto i=validmap.rbegin(); i!=validmap.rend() && n<=n_max; i++, n++) {
	XmlDom item = fea.Element("item");
	item.Prop("seqNum", ToStr(n));
	item.Prop("shotId", i->second);
      }
    }

    xml.Write(xmlfile);
    WriteLog("Stored "+detections.front()+" results for "+classname+
	     " in <"+xmlfile+">");

    // WriteLog("Consider: tar -cvf - ./output | gzip > "+resfile);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCOCOoutput(const vector<string>&) {
    const string msg = "AnalyseCOCOoutput() : ";
    
    bool id_from_subrange = true;

    DataBase *db  = CheckDB();
    
    string textindex = CheckQuery()->TextIndex();
    if (textindex=="")
      return ShowError(msg+"textindex should have been specified");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    AddExtraVariableInfo(extra, "textindex", textindex);
    string mstr;
    query->WriteAnalyseVariablesNew("COCOoutput", mstr, gtl, extra);

    string rlabel = restr.label(), fname = filename;
    if (rlabel=="*")
      rlabel = "ALL";
    if (fname=="")
      fname = db->Name()+"-"+rlabel+"-"+textindex+".json";
    ofstream ofs(fname);

#if defined(HAVE_JSON_JSON_H)
    Json::Value a;
    size_t n = 0;
#else
    ShowError(msg+"no JSON available");
#endif // HAVE_JSON_JSON_H
    
    vector<size_t> idxs = restr.indices(1);
    for (auto idx : idxs) {
      ground_truth gt(db->Size());
      gt[idx] = 1;
      list<textline_t> tl = db->TextIndexLines(textindex, "text", gt);
      if (tl.size()!=1)
	return ShowError(msg+"TextIndexLines("+textindex+",#"+ToStr(idx)+") failed");

      string txt = tl.front().txt_val[0].first;
      if (txt=="")
	return ShowError(msg+"empty string for #"+ToStr(idx)+" "+db->Label(idx));

      int id = atoi(db->Label(idx).c_str());
      string idstr = ToStr(id);
      if (id_from_subrange) {
	map<string,string> m = db->ReadOriginsInfo(idx, false, false);
	string sr = m["subrange"];
	size_t p = sr.rfind('/');
	if (p!=string::npos)
	  sr.erase(0, p+1);
	p = sr.rfind('.');
	if (p!=string::npos)
	  sr.erase(p);
	idstr = sr;
      }

      cout << "#" << idx << " " << db->Label(idx) << " " << idstr << " " << txt << endl;
      
#if defined(HAVE_JSON_JSON_H)
      Json::Value item;
      item["image_id"] = idstr;
      item["caption"]  = txt;
      a.append(item);
      n++;
#endif // HAVE_JSON_JSON_H
    }

#if defined(HAVE_JSON_JSON_H)
    ofs << a;
    WriteLog("Wrote "+ToStr(n)+" sentence results in <"+fname+">");
#endif // HAVE_JSON_JSON_H

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCOCOoutput_old(const vector<string>&) {
    const string msg = "AnalyseCOCOoutput_old() : ";
    
    bool angry = true;

    DataBase *db  = CheckDB();
    
    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection should be specified");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    AddExtraVariableInfo(extra, "detections", ToStr(detections));
    string mstr;
    query->WriteAnalyseVariablesNew("COCOoutput", mstr,
				    gtl, extra);

    string rlabel = restr.label(), fname = filename;
    if (rlabel=="*")
      rlabel = "ALL";
    if (fname=="")
      fname = db->Name()+"-"+rlabel+"-"+detections[0]+".json";
    ofstream ofs(fname);

#if defined(HAVE_JAULA_H) && defined(PICSOM_USE_JAULA)
    JAULA::Value_Array doc;
    size_t n = 0;
#else
    ShowError(msg+"no JAULA available");
#endif // PICSOM_USE_JAULA && HAVE_JAULA_H
    
    vector<size_t> idxs = restr.indices(1);
    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];
      textline_t tl = db->ObjectTextLineRetrieve(idx, "", detections[0], angry);
      // textline_t tl;
      // tl.txt_val.push_back(make_pair("hello world", 0.9));

#if defined(HAVE_JAULA_H) && defined(PICSOM_USE_JAULA)
      int id = atoi(db->Label(idx).c_str());
      JAULA::Value_Object item;
      item.insertItem("image_id", JAULA::Value_Number_Int(id));
      item.insertItem("caption",  JAULA::Value_String(tl.txt_val[0].first));
      doc.addItem(item);
      n++;
#endif // PICSOM_USE_JAULA && HAVE_JAULA_H
    }

#if defined(HAVE_JAULA_H) && defined(PICSOM_USE_JAULA)
    doc.repr(ofs);
    ofs << endl;
    WriteLog("Wrote "+ToStr(n)+" sentence results in <"+fname+">");
#endif // PICSOM_USE_JAULA && HAVE_JAULA_H

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseLSMDCoutput(const vector<string>& args) {
    const string msg = "AnalyseLSMDCoutput() : ";
    
    bool angry = true;

    DataBase *db  = CheckDB();
    
    bool args_ok = args.size()==1;
    string style = args_ok ? args[0] : "";
    if (style!="picsom" && style!="lsmdc")
      args_ok = false;

    if (!args_ok)
      return ShowError(msg+"exactly one argument \"picsom\" or \"lsmdc\""
		       " should be specified (has effect only when "
		       "queryrestriction=test");

    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection should be specified");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    AddExtraVariableInfo(extra, "detections", ToStr(detections));
    string mstr;
    query->WriteAnalyseVariablesNew("LSMDCoutput", mstr,
				    gtl, extra);

    string rlabel = restr.label(), fname = filename;
    if (rlabel=="*")
      rlabel = "ALL";
    if (fname=="")
      fname = db->Name()+"-"+rlabel+"-"+detections[0]+"-"+style+".json";
    ofstream ofs(fname);

#if defined(HAVE_JAULA_H) && defined(PICSOM_USE_JAULA)
    JAULA::Value_Array doc;
    size_t n = 0;
#else
    ShowError(msg+"no JAULA available");
#endif // PICSOM_USE_JAULA && HAVE_JAULA_H
    
    multimap<string,string> commons = db->GetCommons();
    for (auto j=commons.begin(); j!=commons.end(); j++) {
      string s = j->first;
      for (;;) {
	size_t p = s.find('_');
	if (p==string::npos)
	  break;
	s[p] = ' ';
      }
      commons.insert(make_pair(s, j->second));
      cout << "<" << j->first << "> -> <" << j->second << ">" << endl;
      cout << "<" << s << "> -> <" << j->second << ">" << endl;
    }

    vector<size_t> idxs = restr.indices(1);
    for (size_t i=0; i<idxs.size(); i++) {
      size_t idxp = idxs[i];
      const vector<int>& cidxs = db->FindObject(idxp)->children;
      if (cidxs.size()!=1)
	return ShowError(msg+"cidxs.size()!=1 <"+db->Label(idxp)+">");

      size_t idxc = cidxs[0];

      textline_t tl = db->ObjectTextLineRetrieve(idxc, "", detections[0], angry);

      bool is_lsmdc = false;
      int id = atoi(db->Label(idxp).c_str()); // style==picsom
      if (style=="lsmdc" && rlabel=="test") {
	id = i+1;
	is_lsmdc = true;
      }

      string txt = tl.txt_val[0].first, txtwas = txt;
      
      for (auto j=commons.begin(); j!=commons.end(); j++) {
	size_t q = 0;
	for (;;) {
	  size_t p = txt.find(j->first, q);
	  if (p==string::npos)
	    break;
	  if ((p!=0 && txt[p-1]!=' ') ||
	      (p+j->first.size()!=txt.size() && txt[p+j->first.size()]!=' ')) {
	    q = p+1;
	    continue;
	  }
	  string rep = j->second;
	  if (!is_lsmdc && rep=="SOMEONE")
	    rep = LowerCase(rep);
	  txt.replace(p, j->first.size(), rep);
	}
      }

      cout << "<" << txtwas <<"> -> <" << txt << ">" << endl;

      if (is_lsmdc) {
	if (txt[0]>='a' && txt[0]<='z')
	  txt[0] -= 32;
	if (txt[txt.size()-1]!='.')
	  txt += '.';
      }

#if defined(HAVE_JAULA_H) && defined(PICSOM_USE_JAULA)
      JAULA::Value_Object item;
      item.insertItem("video_id", JAULA::Value_Number_Int(id));
      item.insertItem("caption",  JAULA::Value_String(txt));
      doc.addItem(item);
      n++;
#else
      id = id;
#endif // PICSOM_USE_JAULA && HAVE_JAULA_H
    }

#if defined(HAVE_JAULA_H) && defined(PICSOM_USE_JAULA)
    doc.repr(ofs);
    ofs << endl;
    WriteLog("Wrote "+ToStr(n)+" sentence results in <"+fname+">");
#endif // PICSOM_USE_JAULA && HAVE_JAULA_H

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseImageNetOutput(const vector<string>&) {
    const string msg = "AnalyseImageNetOutput() : ";
    
    if (detections.size()!=1)
      return ShowError(msg+"detections.size()!=1");

    DataBase *db  = CheckDB();
    
    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    AddExtraVariableInfo(extra, "detections", ToStr(detections));
    string mstr;
    query->WriteAnalyseVariablesNew("ImageNetOutput", mstr,
				    gtl, extra);

    string fname = filename;
    if (fname=="")
      fname = db->Name()+"-"+detections[0]+".submission";

    ofstream ofs(fname);

    bool debug2 = verbose>1;

    vector<size_t> idxs = restr.indices(1);
    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];
      bool dummy = true;
      map<string,vector<float> > detects =
	db->RetrieveDetectionData(idx, detections[0], true, dummy);
      if (detects.size()!=1)
	return ShowError(msg+"detects.size()!=1 for #"+ToStr(idx)
			 +" with detection \""+detections[0]+"\"");
      const vector<float>& v = detects.begin()->second;
      if (v.size()!=1000)
	return ShowError(msg+"v.size()!=1000 for #"+ToStr(idx)
			 +" with detection \""+detections[0]+"\"");
      multimap<float,size_t> m;
      for (size_t j=0; j<v.size(); j++)
	m.insert(make_pair(-v[j], j));
      
      if (debug2)
	cout << idx << " :";

      size_t n = 5;
      bool first = true;
      for (auto p=m.begin(); p!=m.end() && n--; p++) {
	if (debug2)
	  cout << "  " << p->second << "=" << -p->first;

	ofs << (first?"":" ") << p->second;
	first = false;
      }
      ofs << endl;
      if (debug2)
	cout << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseVocOutput(const vector<string>&) {
    const string msg = "AnalyseVocOutput() : ";
    
    if (detections.size()!=1)
      return ShowError(msg+"detections.size()!=1");

    bool debug2 = verbose>1;

    DataBase *db  = CheckDB();
    
    analyse_result res_allx;
    float mean_ap = 0;

    list<string> classes = db->SplitClassNames(classname);
    for (auto ci=classes.begin(); ci!=classes.end(); ci++) {
      string cname = *ci;

      string detname = detections[0]+"#"+cname;
      if (instance!="")
	detname += "§"+instance;

      // markus: commented out lines are for indoor:
      CheckQuery()->SetTemporalRestriction(cname+"_test", Target(), -1);
      //CheckQuery()->SetTemporalRestriction("all-test-p", Target(), -1);
      ground_truth restr = QueryRestrictionGT(true);
      ground_truth gt    = db->GroundTruthExpression(cname+"&"+cname+"_test");
      //ground_truth gt    = db->GroundTruthExpression(cname+"&all-test-p");
      ground_truth_list gtl;
      AddGroundTruthInfo(gtl, "queryrestriction", restr);
      AddGroundTruthInfo(gtl, "ground_truth",     gt);
      list<string> extra;
      AddExtraVariableInfo(extra, "detection", detname);
      string mstr;
      query->WriteAnalyseVariablesNew("VocOutput", mstr, gtl, extra);

      string fname = filename;
      if (fname=="")
	fname = detections[0]+"_cls_test_";
      if (fname!="null")
	fname += cname+".txt";

      ofstream ofs(fname!="null"?fname:"/dev/null");

      multimap<float,bool> ores;
      vector<size_t> idxs = restr.indices(1);
      for (size_t i=0; i<idxs.size(); i++) {
	size_t idx = idxs[i];

	bool dummy = true;
	map<string,vector<float> > detects =
	  db->RetrieveDetectionData(idx, detname, true, dummy);
	if (detects.size()!=1)
	  return ShowError(msg+"detects.size()!=1 for #"+ToStr(idx)
			   +" with detection \""+detections[0]+"\"");
	const vector<float>& v = detects.begin()->second;
	if (v.size()!=1)
	  return ShowError(msg+"v.size()!=1 for #"+ToStr(idx)
			   +" with detection \""+detections[0]+"\"");

	map<string,string> info = CheckDB()->ReadOriginsInfo(idx, false, true);
	string iname = info["auxid"]; // not set in stanford40...
	if (iname=="") {
	  iname = info["url"]; 
	  // size_t p = iname.rfind('.');
	  // if (p!=string::npos)
	  //   iname.erase(p);
	  size_t p = iname.rfind('/');
	  if (p!=string::npos)
	    iname.erase(0, p+1);
	}

	if (debug2)
	  cout << cname << " " << idx << " " << iname << " : " << v[0] << endl;

	ofs << iname << " " << 1 << " " << v[0] << endl;

	bool hit = gt[idx]==1;
	ores.insert(make_pair(-v[0], hit));
      }

      vector<bool> hits;
      size_t npos = 0;
      for (auto i=ores.begin(); i!=ores.end(); i++) {
	bool hit = i->second;
	hits.push_back(hit);
	npos += hit;
      }

      size_t cpos = 0;
      vector<float> prec;
      for (size_t i=0; i<hits.size(); i++) {
	cpos += hits[i];
	prec.push_back(cpos/(1.0+i));
      }
      
      for (int i=prec.size()-2; i>=0; i--)
	if (prec[i+1]>prec[i])
	  prec[i] = prec[i+1];

      float ap = 0.0;
      for (size_t i=0; i<hits.size(); i++)
	if (hits[i])
	  ap += prec[i];

      ap /= npos;
      analyse_result res;
      res.rescount  = 1;
      res.avgprec   = ap;
      WriteLog("detector "+detections[0]+" (instance="+instance+") class "+
	       cname+" ap="+ToStr(ap)+" with "+ToStr(cpos)+" positives");
      res_allx.add_sub_result(res);
      mean_ap += ap;
    }

    mean_ap /= classes.size();

    WriteLog("With detector "+detections[0]+" (instance="+instance+
	     ") mean avg.prec="+ToStr(mean_ap)+" from "+
	     ToStr(classes.size())+" classes");

    cout << "MEAN-AVG-PREC " << db->Name() << " " << detections[0] << "\t"
	 << mean_ap << endl;

    return res_allx;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseYleJsonOutput(const vector<string>& arg) {
    const string msg = "AnalyseYleJsonOutput() : ";

    string vers = "1";
    if (vers=="1")
      return AnalyseYleJsonOutputV1(arg);

    return ShowError(msg+"vers=<"+vers+"> unknown");
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseYleJsonOutputV1(const vector<string>& arg) {
    const string msg = "AnalyseYleJsonOutputV1() : ";
    
#if defined(HAVE_JSON_JSON_H)

    bool debug2 = verbose>1, debug3 = verbose>2, debug4 = verbose>3;

    if (arg.size()!=1)
      return ShowError(msg+"one argument should be specified");

    const string& type = arg[0];
    if (type!="concepts" && type!="captions")
      return ShowError(msg+"argument should be concepts|captions");

    if (filename=="")
      return ShowError(msg+"filename should be specified");

    DataBase *db  = CheckDB();
    
    string detname, captindex;
    list<string> classes;
    if (type=="concepts") {
      if (detections.size()!=1)
	return ShowError(msg+"detections.size()!=1");
      if (classname=="")
	return ShowError(msg+"class should be specified");
      detname = detections[0];
      classes = db->SplitClassNames(classname);
    }
    if (type=="captions") {
      if (captionings.size()!=1)
	return ShowError(msg+"captionings.size()!=1");
      captindex = captionings[0];
    }

    float thr = threshold>0 ? threshold : 0.5;

    WriteLog(msg+"starting type="+type+" detname="+detname+" class="+
	     classname+" threshold="+ToStr(thr));

    ground_truth restr = QueryRestrictionGT(true);
    vector<size_t> idxs = restr.indices(1);
    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];

      vector<size_t> shots;
      const object_info *oi = db->FindObject(idx);
      for (auto j=oi->children.begin(); j!=oi->children.end(); j++) {
	if (db->ObjectsTargetType(*j)==target_videosegment)
	  shots.push_back(*j);
	if (debug4)
	  cout << " " << db->Label(*j);
      }
      if (debug4)
	cout << endl;

      map<string,string> info = db->ReadOriginsInfo(idx, false, true);
      string auxid = info["auxid"];
      string fname = filename+"-"+auxid+".json";
      cout << fname << endl;
      ofstream out(fname);

      string datetime = XSdateTime(TimeNow());
      size_t p = datetime.find('T');
      if (p!=string::npos)
	datetime[p] = ' ';

      Json::Value result;   
      Json::Value texts(Json::arrayValue);
      // texts.append(Json::Value("hello"));
      result["source"]["id"]     = auxid;
      //result["source"]["format"] = "lorem ipsum";
      result["metadata"]["createdAt"] = datetime;
      result["metadata"]["versionIdentifier"] = "1.0.0";
      //result["metadata"]["formatConvertedTo"] = "lorem ipsum";
      result["results"]["texts"] = texts;

      for (auto s=shots.begin(); s!=shots.end(); s++) {
	auto psd = db->ParentStartDuration(*s, target_video);
	double t_begin = psd.second.first;
	double t_end   = t_begin+psd.second.second;
	string s_begin = SecToString(t_begin, false);
	string s_end   = SecToString(t_end,   false);
	string trange  = s_begin+"-"+s_end;
	
	//double fps =  db->VideoFrameRate(*s);
	//size_t f_begin = floor(t_begin*fps);
	//size_t f_end   = floor(t_end*fps+0.5);
	
	if (type=="concepts") {
	  auto fr = db->VideoOrSegmentFramesOrdered(*s);
	  if (fr.size()==0)
	    return ShowError(msg+"no frames for #"+ToStr(*s));

	  if (debug2)
	    cout << "AAA1 " << db->Label(idx) << " " << db->Label(*s)
		 << " " << t_begin << " " << t_end << " " << trange
		 << " [" << fr.begin()->second << "] #" << fr.begin()->first
		 << " [" << fr.rbegin()->second << "] #" << fr.rbegin()->first
		 << endl;

	  multimap<double,string> detcon;
	  for (auto c=classes.begin(); c!=classes.end(); c++) {
	    double sum = 0;
	    size_t n = 0;
	    for (auto j=fr.begin(); j!=fr.end(); j++) {
	      size_t iidx = j->first;
	      string detcls = detname+"#"+*c;
	      bool dummy = true;
	      map<string,vector<float> > detects =
		db->RetrieveDetectionData(iidx, detcls, true, dummy);
	      if (detects.size()!=1)
		return ShowError(msg+"detects.size()!=1 for #"+ToStr(iidx)
				 +" with detection \""+detcls+"\"");
	      const vector<float>& v = detects.begin()->second;
	      if (v.size()!=1)
		return ShowError(msg+"v.size()!=1 for #"+ToStr(iidx)
				 +" with detection \""+detcls+"\"");
	      
	      sum += v[0];
	      n++;

	      if (debug3)
		cout << "BBBB " << db->Label(*s) << " " << *c << " ["
		     << j->second << "] " << db->Label(iidx) << " #" << iidx
		     << " " << v[0] << endl;
	    }
	    double val = sum/n;

	    if (debug2)
	      cout << "AAA2 " << db->Label(*s) << " " << *c << " "
		   << sum << " " << n << " " << val << endl;

	    detcon.insert(make_pair(val, *c));
	  }

	  vector<string> seldet;
	  if (debug2)
	    cout << "AAA3";
	  for (auto j=detcon.rbegin(); j!=detcon.rend(); j++) {
	    string str = db->PossiblyDeLscom(j->second);

	    if (debug2)
	      cout << " " << str << " (" << j->second << ") = " << j->first;
	    if (j->first>=thr)
	      seldet.push_back(str);
	  }
	  if (debug2)
	    cout << endl;

	  if (seldet.size()) {
	    string detstr = JoinWithString(seldet, " ");
	    result["results"]["timeline"][trange] = detstr;
	    if (debug2)
	      cout << "AAA4 " << trange << " " << detstr << endl;

	    size_t m = db->VideoOrSegmentMiddleFrame(*s).first;
	    cout << "**textentry** " << db->Label(m) << " "
		 << filename << " " << detstr << endl;

	  } else if (debug2)
	    cout << "AAA4 " << trange << " no detections" << endl;
	}
      
	if (type=="captions") {
	  size_t m = db->VideoOrSegmentMiddleFrame(*s).first;
	  //  obs! should this use DataBase::TextIndexLine()?
	  auto l = db->TextIndexRetrieve(m, captindex);
	  for (auto j=l.begin(); j!=l.end(); j++) {
	    if (debug2)
	      cout << "AAA1 " << db->Label(idx) << " " << db->Label(*s)
		   << " " << db->Label(m) << " " << trange
		   << " <" << j->first << ">=<"
		   << j->second << ">" << endl;
	  }
	  map<string,string> kv(l.begin(), l.end());
	  textline_t tl(db, *s);
	  tl.txt_decode(kv["text"]);
	  string capttxt = tl.txt_val[0].first;
	  cout << "XXX " << capttxt << " XXX" << endl;
	  
	  result["results"]["timeline"][trange] = capttxt;
	}
      }
      
      out << result << endl;

      if (out)
	WriteLog("Stored YleJson results in <"+fname+">");
      else
	return ShowError(msg+"failed to write in <"+fname+">");
    }

    return true;

#else
    return ShowError(msg+"HAVE_JSON_JSON_H not defined"+(arg.size()?"":""));
#endif // defined(HAVE_JSON_JSON_H)
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseShowTopDetections(const vector<string>&) {
    const string msg = "AnalyseShowTopDetections() : ";
    
    size_t n = 5;

    bool debug2 = verbose>1;

    DataBase *db  = CheckDB();
    vector<string> det = ExpandDetectionsWithClasses(detections,
						     classname);
    if (det.size()==0)
      return ShowError(msg+"ExpandDetectionsWithClasses() failed");

    string detstr = CommaJoin(det);

    vector<size_t> idx = QueryRestrictionGT().indices(1);
    for (size_t j=0; j<idx.size(); j++) {
      bool dummy = true;
      map<string,vector<float> >
	dets = db->RetrieveOrProduceDetectionData(idx[j], detstr, classname,
						  true, dummy, true);
      
      multimap<float,string> v;

      for (auto d=dets.begin(); d!=dets.end(); d++) {
	if (d->second.size()!=1)
	  return ShowError(msg+"d->second.size()!=1");

	if (debug2)
	  cout << "#" << idx[j] << " " << d->first << "=" << ToStr(d->second)
	       << endl;
	v.insert(make_pair(d->second[0], d->first));
      }

      size_t k = 0;
      for (auto i=v.rbegin(); i!=v.rend() && k<n; i++, k++) {
	string s = i->second;
	if (detections.size()==1) {
	  size_t p = s.rfind('#');
	  if (p!=string::npos) {
	    s.erase(0, p+1);
	    if (s[s.size()-1]==')')
	      s.erase(s.size()-1);
	  }
	}
	cout << db->Label(idx[j]) << " " << k << " "
	     << s << " " << i->first << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseDumpDetections(const vector<string>&) {
    const string msg = "AnalyseDumpDetections() : ";
    
    bool debug1 = verbose>0, debug2 = verbose>1;

    DataBase *db  = CheckDB();
    
    if (classname=="")
      return ShowError(msg+"class should be specified");
    
    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection (without #class)"
		       " should be specified");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("DumpDetections", mstr,
				    gtl, extra);

    string outname1;
    list<string> clslist = db->SplitClassNames(classname);

    for (auto c=clslist.begin(); c!=clslist.end(); c++) {
      string lscomnum = db->LscomName(*c, true, "trecvid2011");
      pair<string,string> lscom = DataBase::SplitLscomName(lscomnum);
      string fnum = lscom.second;
      string dname = detections.front()+"#"+*c;
      string outname = "PicSOM-"+detections.front()+"-"+*c+"-fNum"+fnum+".txt";
      if (outname1=="")
	outname1 = outname;
      ofstream out(outname);

      if (!out)
	return ShowError(msg+"failed to write in <"+outname+">");

      if (debug1)
	cout << "STARTING to dump " << *c << " = " << lscom.first << " = "
	     << fnum << " from " << dname << " to <" << outname << ">" << endl;

      for (size_t i=0; i<db->Size(); i++) {
	if (restr[i]!=1)
	  continue;

	bool dummy = true;
	map<string,vector<float> > detects =
	  db->RetrieveDetectionData(i, dname, true, dummy);
	if (detects.size()>1)
	  return ShowError(msg+"detects.size()>1 for #"+ToStr(i)
			   +" with detection \""+dname+"\"");
	
	if (detects.size()<1)
	  return ShowError(msg+"detects.size()<1 for #"+ToStr(i)
			   +" with detection \""+dname+"\"");
	
	if (detects.begin()->second.size()!=1)
	  ShowError(msg+"detection dimensionality != 1");

	float val = detects.begin()->second[0];

	string label = Label(i);
	string vid = label.substr(0, 5), sht = label.substr(5);
	while (vid[0]=='0')
	  vid.erase(0, 1);
	while (sht[0]=='0')
	  sht.erase(0, 1);
	string shotid = "shot"+vid+"_"+sht;

	if (debug2) {
	  cout << dname << " #" << i << " " << label << " " << " "
	       << shotid << " " << val;
	  cout << endl;
	}
	out << val << " " << shotid << endl;
      }
    }

    WriteLog("Stored "+detections.front()+" results for "+classname+
	     " in "+ToStr(clslist.size())+" files <"+outname1+"> ...");

    // WriteLog("Consider: tar -cvf - ./output | gzip > "+resfile);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseEvaluateDetections(const vector<string>& argsin) {
    const string msg = "AnalyseEvaluateDetections() : ";
    
    vector<string> args = argsin;

    bool debug1 = verbose>0, debug2 = verbose>1;

    DataBase *db  = CheckDB();
    
    if (classname=="")
      return ShowError(msg+"class should be specified");
    
    if (detections.size()<1)
      return ShowError(msg+"at least one detection (without #class)"
		       " should be specified");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("EvaluateDetections", mstr,
				    gtl, extra);

    string outname1;
    list<string> clslist = db->SplitClassNames(classname);

    analyse_result res_allx;

    for (auto dd=detections.begin(); dd!=detections.end(); dd++) {
      float mean_ap = 0.0;
      analyse_result res_med;
      
      for (auto c=clslist.begin(); c!=clslist.end(); c++) {
	string clspec = *c;
	if (clspec.find(classprefix)==0)
	  clspec.erase(0, classprefix.size());
	
	string dname = *dd+"#"+clspec;
	
	if (debug1)
	  cout << "STARTING to evaluate " << *c << " from " << dname
	       << endl;

	ground_truth gt = db->GroundTruthExpression(*c);
	db->GroundTruthSummary(gt);

	multimap<float,bool> vmap;

	size_t npos = 0, nneg = 0;

	for (size_t i=0; i<db->Size(); i++) {
	  if (restr[i]!=1 || gt[i]==0)
	    continue;

	  bool dummy = true, allow_incore = false;
	  map<string,vector<float> > detects =
	    db->RetrieveOrProduceDetectionData(i, *dd, clspec, true, dummy,
					       allow_incore);
	  if (detects.size()!=1)
	    continue;
	
	  if (detects.begin()->second.size()!=1)
	    ShowError(msg+"detection dimensionality != 1");

	  float val = detects.begin()->second[0];
	  bool  hit = gt[i]==1;
	  if (debug2)
	    cout << dname << " #" << i << " " << db->Label(i)
		 << " " << val << " " << (hit?"1":"0") << endl;
	
	  vmap.insert(make_pair(val, hit));
	  npos +=  hit;
	  nneg += !hit;
	}

	analyse_result res;

	if (debug1)
	  cout << "npos=" << npos << " nneg=" << nneg << endl;
      
	float ap = 0.0;
	size_t cpos = 0, cneg = 0;
	if (debug2)
	  cout << "0 0 0" << endl;

	for (auto i=vmap.rbegin(); i!=vmap.rend(); i++) {
	  float fp = float(cneg)/nneg, tp = float(cpos)/npos;

	  bool hit = i->second;
	  cpos +=  hit;
	  cneg += !hit;

	  res.threshold.push_back(i->first);
	  res.true_pos. push_back(tp);
	  res.false_pos.push_back(fp);

	  if (hit)
	    ap += float(cpos)/(cpos+cneg);

	  if (debug2) {
	    cout << cpos+cneg << " " << fp << " " << tp
		 << " (" << i->first << " " << i->second
		 << ")";
	    if (hit)
	      cout << " p=" << float(cpos)/(cpos+cneg);
	    cout << endl;
	  }
	}

	ap /= npos;
	if (debug2)
	  cout << "ap=" << ap << endl;

	res.rescount  = 1;
	res.avgprec   = ap;
	(args.size()<=1?res_allx:res_med).add_sub_result(res);

	WriteLog("Detections with <"+*dd+"> for <"+*c+"> : "+ToStr(npos)+
		 "/"+ToStr(npos+nneg)+" positives a priori="+
		 ToStr(float(npos)/(npos+nneg))+" avg.prec="+ToStr(ap));

	mean_ap += ap;
      }

      mean_ap /= clslist.size();

      WriteLog("Detections with <"+*dd+"> for "+ToStr(clslist.size())+
	       " classes in <"+restr.label()+"> mean avg.prec="+ToStr(mean_ap));

      if (args.size()>1)
	res_allx.add_sub_result(res_med);
    }

    return res_allx;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseEvaluateDetectionsWithThresholds(const vector<string>&
						    argsin) {
    const string msg = "AnalyseEvaluateDetectionsWithThresholds() : ";
    
    vector<string> args = argsin;

    bool debug1 = verbose>0, debug2 = verbose>1;

    float rank_mult = 12.5; // like trecvid2013med

    DataBase *db  = CheckDB();
    
    if (classname=="")
      return ShowError(msg+"class should be specified");
    
    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection (without #class)"
		       " should be specified");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("EvaluateDetections", mstr,
				    gtl, extra);

    string outname1;
    list<string> clslist = db->SplitClassNames(classname);

    analyse_result res_allx;

    for (auto a=args.begin(); a!=args.end(); a++) {
      if (debug1)
	cout << "STARTING to evaluate with thresholding " << *a << endl;
	
      float mean_r0 = 0.0, mean_ap = 0.0;
      float mean_pmiss = 0.0, mean_pfa = 0.0;
      analyse_result res_med;
      
      for (auto c=clslist.begin(); c!=clslist.end(); c++) {
	string clspec = *c;
	if (clspec.find(classprefix)==0)
	  clspec.erase(0, classprefix.size());
	
	string dname = detections.front()+"#"+clspec;
	float thr = db->ThresholdValue(dname+"-"+*a);
	
	if (debug1)
	  cout << "STARTING to evaluate " << *c << " from " << dname
	       << " with value " << thr << endl;

	ground_truth gt = db->GroundTruthExpression(*c);
	db->GroundTruthSummary(gt);

	multimap<float,bool> vmap;

	size_t npos = 0, nneg = 0;

	for (size_t i=0; i<db->Size(); i++) {
	  if (restr[i]!=1 || gt[i]==0)
	    continue;

	  bool dummy = true;
	  map<string,vector<float> > detects =
	    db->RetrieveDetectionData(i, dname, true, dummy);
	  if (detects.size()!=1)
	    continue;
	
	  if (detects.begin()->second.size()!=1)
	    ShowError(msg+"detection dimensionality != 1");

	  float val = detects.begin()->second[0];
	  bool  hit = gt[i]==1;
	  if (debug2)
	    cout << dname << " #" << i << " " << db->Label(i)
		 << " " << val << " " << (hit?"1":"0") << endl;
	
	  vmap.insert(make_pair(val, hit));
	  npos +=  hit;
	  nneg += !hit;
	}

	analyse_result res;

	if (debug1)
	  cout << "npos=" << npos << " nneg=" << nneg << endl;
      
	float ap = 0.0;
	size_t cpos = 0, cneg = 0;
	if (debug2)
	  cout << "0 0 0" << endl;

	float thr_r0 = -100;
	float thr_pmiss = 1, thr_pfa = 1;
	vector<float> r0vec;

	for (auto i=vmap.rbegin(); i!=vmap.rend(); i++) {
	  bool excluded = i->first<=thr;

	  float pmiss = float(npos-cpos)/npos;
	  float pfa   = float(cneg)/nneg;
	  float fp = float(cneg)/nneg, tp = float(cpos)/npos;
	  float r0 = tp - rank_mult*(cpos+cneg)/(nneg+npos);
	  r0vec.push_back(r0);

	  if (thr_pmiss==1 && excluded) {
	    thr_r0    = r0;
	    thr_pmiss = pmiss;
	    thr_pfa   = pfa;
	  }

	  bool hit = i->second;
	  cpos +=  hit;
	  cneg += !hit;

	  res.threshold.push_back(i->first);
	  res.true_pos. push_back(tp);
	  res.false_pos.push_back(fp);
	  res.minaccrec.push_back(r0);

	  if (hit)
	    ap += float(cpos)/(cpos+cneg);

	  if (debug2) {
	    cout << cpos+cneg << " " << fp << " " << tp
		 << " (" << i->first << " " << i->second
		 << ") r0=" << r0;
	    if (hit)
	      cout << " p=" << float(cpos)/(cpos+cneg);
	    cout << endl;
	  }
	}

	ap /= npos;
	if (debug2)
	  cout << "ap=" << ap << endl;

	res.rescount  = 1;
	res.avgprec   = ap;
	(args.size()<=1?res_allx:res_med).add_sub_result(res);

	WriteLog("Thresholding "+*a+" "+ToStr(thr)+
		 " <"+*c+"> : "+ToStr(npos)+
		 "/"+ToStr(npos+nneg)+" positives a priori="+
		 ToStr(float(npos)/(npos+nneg))+" avg.prec="+ToStr(ap)+
		 " r0="+ToStr(thr_r0)+" pmiss="+ToStr(thr_pmiss)+
		 " pfa="+ToStr(thr_pfa));

	mean_ap    += ap;
	mean_r0    += thr_r0;
	mean_pmiss += thr_pmiss;
	mean_pfa   += thr_pfa;
      }

      mean_ap    /= clslist.size();
      mean_r0    /= clslist.size();
      mean_pmiss /= clslist.size();
      mean_pfa   /= clslist.size();

      WriteLog("Thresholding "+*a+" for "+ToStr(clslist.size())+
	       " classes mean avg.prec="+ToStr(mean_ap)+" mean r0="+
	       ToStr(mean_r0)+" mean pmiss="+ToStr(mean_pmiss)+" mean pfa="+
	       ToStr(mean_pfa));

      if (args.size()>1)
	res_allx.add_sub_result(res_med);
    }
  
    return res_allx;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseSelectThresholds(const vector<string>& args) {
    const string msg = "AnalyseSelectThresholds() : ";
    
    bool obey_gt = false;  // obs!

    bool debug1 = verbose>0, debug2 = verbose>1;

    if (args.size()==0)
      return ShowError(msg+"at least one thresholding method "
		       "should be specified");

    if (classname=="")
      return ShowError(msg+"class should be specified");
    
    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection (without #class)"
		       " should be specified");

    DataBase *db  = CheckDB();
    
    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("SelectThresholds", mstr,
				    gtl, extra);

    list<string> clslist = db->SplitClassNames(classname);

    for (auto c=clslist.begin(); c!=clslist.end(); c++) {
      string clspec = *c;
      if (clspec.find(classprefix)==0)
	clspec.erase(0, classprefix.size());

      string dname = detections.front()+"#"+clspec;
	
      if (debug1)
	cout << "STARTING to evaluate " << *c << " from " << dname
	     << " obey_gt=" << (obey_gt?"true":"false") << endl;
	
      ground_truth gt = obey_gt ? db->GroundTruthExpression(*c) : restr;
      db->GroundTruthSummary(gt);

      multimap<float,bool> vmap;
	
      for (size_t i=0; i<db->Size(); i++) {
	if (restr[i]!=1 || gt[i]==0)
	  continue;
	  
	bool dummy = true;
	map<string,vector<float> > detects
	  = db->RetrieveDetectionData(i, dname, true, dummy);
	if (detects.size()!=1)
	  continue;
	
	if (detects.begin()->second.size()!=1)
	  ShowError(msg+"detection dimensionality != 1");

	float val = detects.begin()->second[0];
	bool  hit = gt[i]==1;
	if (debug2)
	  cout << dname << " #" << i << " " << db->Label(i)
	       << " " << val << " " << (hit?"1":"0") << endl;
	
	vmap.insert(make_pair(val, hit));
      }
	
      for (auto a=args.begin(); a!=args.end(); a++) {
	if (debug1)
	  cout << "STARTING to perform thresholding " << *a
	       << " with " << vmap.size() << " values" << endl;
	
	string thrmet = *a, thrastr;
	if (thrmet.size() && thrmet[thrmet.size()-1]==')' &&
	    !SplitParentheses(*a, thrmet, thrastr))
	  return ShowError(msg+"failed to split <"+*a+">");
      
	vector<string> thrargs;
	if (thrastr!="")
	  thrargs = SplitInCommas(thrastr);

	float thr = -1;
	if (thrmet=="value")
	  thr = SelectThreshold_value(vmap, thrargs);
	else if (thrmet=="count")
	  thr = SelectThreshold_count(vmap, thrargs);
	else if (thrmet=="maxr0")
	  thr = SelectThreshold_maxr0(vmap, thrargs);
	else if (thrmet=="optr0")
	  thr = SelectThreshold_optr0(vmap, thrargs);
	else 
	  return ShowError(msg+"thresholding method <"+thrmet+"> unknown");

	string thrsuff = "-"+*a;
	for (;;) {
	  size_t p = thrsuff.find_first_of("(,.=)");
	  if (p==string::npos)
	    break;
	  if (thrsuff[p]=='(' || thrsuff[p]=='=' || thrsuff[p]==')')
	    thrsuff.erase(p, 1);
	  else
	    thrsuff[p] = '_';
	}
	string thrfile = db->ExpandPath("thresholds")+"/"+dname+thrsuff;
	if (!Picsom()->MakeDirectory(thrfile, true))
	  return ShowError(msg+"mkdir() for <"+thrfile+"> failed");

	stringstream thrss;
	thrss << "# threshold " << *a << " for " << *c << " ("
	      << clspec << ") " << detections.front() << " -> "
	      << dname << endl
	      << thr << endl << endl;
	string thrtxt = thrss.str();
	if (!StringToFile(thrtxt, thrfile))
	  return ShowError(msg+"failed to write in <"+thrfile+">");

	if (debug1)
	  WriteLog("Threshold <"+*a+"> for <"+*c+"> is "+ToStr(thr)+
		   " saved in <"+db->ShortFileName(thrfile)+">");;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  float Analysis::SelectThreshold_value(const multimap<float,bool>&,
					const vector<string>& args) {
    const string msg = "AnalyseSelectThresholds_value() : ";

    if (args.size()!=1) {
      ShowError(msg+"exactly one argument should be specified");
      return -1;
    }

    float val = atof(args[0].c_str());

    return val;
  }

  /////////////////////////////////////////////////////////////////////////////

  float Analysis::SelectThreshold_count(const multimap<float,bool>& vmap,
					const vector<string>& args) {
    const string msg = "AnalyseSelectThresholds_count() : ";

    if (args.size()!=1) {
      ShowError(msg+"exactly one argument should be specified");
      return -1;
    }

    int n = atoi(args[0].c_str()), j = 0;

    float v = 1;
    for (auto i=vmap.rbegin(); i!=vmap.rend(); i++, j++) {
      if (j==n) {
	v = i->first;
	break;
      }
    }

    return v;
  }

  /////////////////////////////////////////////////////////////////////////////

  float Analysis::SelectThreshold_maxr0(const multimap<float,bool>& vmap,
					const vector<string>& args) {
    const string msg = "AnalyseSelectThresholds_maxr0() : ";

    if (args.size()!=0) {
      ShowError(msg+"exactly zero arguments should specified");
      return -1;
    }

    return SelectThreshold_r0_common(vmap, true);
  }

  /////////////////////////////////////////////////////////////////////////////

  float Analysis::SelectThreshold_optr0(const multimap<float,bool>& vmap,
					const vector<string>& args) {
    const string msg = "AnalyseSelectThresholds_optr0() : ";

    if (args.size()!=0) {
      ShowError(msg+"exactly zero arguments should specified");
      return -1;
    }
    
    return SelectThreshold_r0_common(vmap, false);
  }

  /////////////////////////////////////////////////////////////////////////////

  float Analysis::SelectThreshold_r0_common(const multimap<float,bool>& vmap,
					    bool do_max) {
    const string msg = "AnalyseSelectThresholds_r0_common() : ";

    bool debug2 = verbose>1, debug3 = verbose>2;

    float r0_mult = 12.5;

    size_t npos = 0, nneg = 0, cpos = 0, cneg = 0;
    for (auto i=vmap.begin(); i!=vmap.end(); i++)
      (i->second?npos:nneg)++;

    if (debug2)
      cout << msg << "npos=" << npos << " nneg=" << nneg << endl;
      
    float max_r0    = -100, opt_r0  = -100;
    float max_r0_thr   = 0, opt_r0_thr = 0;
    float max_r0_pmiss = 1, max_r0_pfa = 1;
    float opt_r0_pmiss = 1, opt_r0_pfa = 1;

    for (auto i=vmap.rbegin(); i!=vmap.rend(); i++) {
      float eff_thr = 0;
      auto inext = i;
      inext++;
      if (inext!=vmap.rend())
	eff_thr = (i->first+inext->first)/2;

      bool hit = i->second;
      (hit?cpos:cneg)++;
      float tp = float(cpos)/npos, fp = float(cneg)/nneg;
      float r0 = tp-r0_mult*(cpos+cneg)/(nneg+npos);
      float pmiss = float(npos-cpos)/npos;
      float pfa   = float(cneg)/nneg;

      if (r0>max_r0) {
	max_r0       = r0;
	max_r0_thr   = eff_thr;
	max_r0_pmiss = pmiss;
	max_r0_pfa   = pfa;
      }
      if (opt_r0_pmiss==1 && pmiss<r0_mult*pfa) {
	opt_r0       = r0;
	opt_r0_thr   = eff_thr;
	opt_r0_pmiss = pmiss;
	opt_r0_pfa   = pfa;
      }

      if (debug3)
	cout << msg << cpos+cneg << " " << fp << " " << tp
	     << " (" << i->first << " " << hit
	     << ") r0=" << r0 << " eff_thr=" << eff_thr << endl;
    }

    if (debug2) {
      if (do_max) 
	cout << msg << "max_r0=" << max_r0
	     << " max_r0_thr=" << max_r0_thr
	     << " max_r0_pmiss=" << max_r0_pmiss
	     << " max_r0_pfa=" << max_r0_pfa << endl;
      else
	cout << msg << "opt_r0=" << opt_r0
	     << " opt_r0_thr=" << opt_r0_thr
	     << " opt_r0_pmiss=" << opt_r0_pmiss
	     << " opt_r0_pfa=" << opt_r0_pfa << endl;
    }

    return do_max ? max_r0_thr : opt_r0_thr;
  }

  /////////////////////////////////////////////////////////////////////////////

  string Analysis::TrecvidShotId(const string& label) const {
    bool debug = false;
    DataBase *db = GetDataBase();
    const string& dbn = db->BaseName();

    bool tv10 = dbn.substr(0, 10) == "trecvid201";

    int id1start = tv10 ? 0 : 1;
    int id2start = tv10 ? 5 : 4;
    int id1len   = tv10 ? 5 : 3;

    int id1 = atoi(label.substr(id1start,id1len).c_str());
    int id2 = atoi(label.substr(id2start,4).c_str());
    
    // hack, for 0-starting labels in trecvid2009
    if (db->BaseName() == "trecvid2009" && label[0]=='0')
      id1 += 299;

    string shot_str;
    if (id1 && (id2 || tv10))
      shot_str = "shot"+ToStr(id1)+"_"+ToStr(id2);

    if (debug)
      cout << "TrecvidShotId() : " << label << " => " << shot_str << endl;
       
    return shot_str;
  }

  /////////////////////////////////////////////////////////////////////////////

  string Analysis::TrecvidShotIdFromOrigins(const string& label) {
    size_t idx = LabelIndex(label);
    map<string,string> info = CheckDB()->ReadOriginsInfo(idx, false, true);
    
    string url = info["url"];
    size_t p = url.find("/shot");
    if (p==string::npos) {
      if (url.substr(0,4) != "shot")
        return "";
    } else
      url.erase(0, p+1);
    p = url.find("_");
    if (p==string::npos)
      return "";
    
    p = url.find("_", p+1);
    if (p==string::npos)
      return "";
    
    return url.substr(0, p);
  }

 /////////////////////////////////////////////////////////////////////////////

  bool Analysis::WriteOrderedClassFile(const list<pair<size_t,double> >& l,
                                       const string& f, const string& txt,
                                       bool val, bool append) {
    return CheckDB()->WriteOrderedClassFile(l, f, txt, val, append);
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseClass(const vector<string>&) {
  WriteLog("AnalyseClass");

  if (!query->HasPositive())
    return ShowError("AnalyseClass() : positive should be defined.");

  const string& pos = query->Positive();
  const string& neg = query->Negative();
  target_type t = query->Target();
  int o = -1;

  ground_truth posi = GroundTruthExpression(pos, t, o, expand);
  ground_truth nega = GroundTruthExpression(neg, t, o, expand);

  if (!posi.NumberOfEqual(1))
    return ShowError("AnalyseClass() : Found no [", TargetTypeString(t),
                     "] objects of class <", pos, ">");

  ReadFiles(true);

  string mstr = string("% ") + TimeStamp() + "\n%\n";
  query->WriteAnalyseVariablesOld("Class", -1, &posi, NULL, 0, false, mstr);

  query->Classify(2); // was Classify(true) 
  GetDataBase()->PrepareClassification(classname, false, vector<string>(),
                                       true, true);

  DataBase *seendb = NULL;

  query->MarkAsSeenEmptyAspect(&posi, &nega, seendb);

  if (verbose) {
    stringstream ss;
    ss << "Database " << DataBaseName() << " contains "
       << query->DataBaseSize() << " objects";
    cout << endl << ss.str() << endl;

    ss.str("");
    ss << "Marked " << query->NpositiveSeenObjects() << " objects ["
       << TargetTypeString(t) << "] of class \""
       << query->Positive() << "\" as positive";
    cout << ss.str() << endl;

    if (query->NnegativeSeenObjects()) {
      ss.str("");
      ss << "Marked " << query->NnegativeSeenObjects() << " objects ["
	 << TargetTypeString(t) << "] of class \""
	 << query->Negative() << "\" as negative";
      cout << ss.str() << endl;
    }
  }

  query->PerMapObjects(1);
  query->MaxQuestions(1);

  // this was needed for the "no convolution" experiments of CIVR2005:
  // query->ConvType("point-1-1-1-1", -1); 

  CbirStages();

  //  const vector<Query::classification_data_t>& cd =
  //    GetQuery()->ClassificationData();

  InitializeXmlResult(true);
  XmlDom xml_root = xml_result.Root();
  GetQuery()->AddToXMLguessedkeywords(xml_root);

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseFill(const vector<string>& args) {
  WriteLog("AnalyseFill");

  ReadFiles();

  string trecvid_was = trecvid;
  trecvid = "";
  ground_truth posi_gt = CreateGroundTruthQuery();

  Query *orig_query = query;
  query = new Query(Picsom());
  Picsom()->AppendQuery(query, false);
  query->CopySome(*orig_query, true, false, false);
  query->DeleteSeen();
  query->DeleteNew();

  DataBase *db = CheckDB();
  db->GroundTruthSummary(posi_gt);

  ground_truth nega_gt(posi_gt.size(), -1), view;

  query->MarkAsSeenNoAspects(&posi_gt, &nega_gt, db); //MarkAsSeenEmptyAspect()?
  query->DumpSeen();

  aspect_map_t posi, nega;
  posi[""] = make_pair(posi_gt, 1.0);
  nega[""] = make_pair(nega_gt, 1.0);

  bool ok = AnalyseBestFinalPart(posi, nega, view, args).ok();
  if (!ok)
    return ShowError("failed");

  Query q(Picsom());
  q.CopySome(*query, true, false, false);
  q.DeleteNew();
  
  for (size_t i=0; i<posi.size(); i++)
    if (posi_gt[i]==1 && db->OkWithRestriction(i))
      q.AppendNewObject(new Object(db, i, select_question, 1.0));

  for (size_t i=0; i<query->NnewObjects() &&
         q.NnewObjects()<query->MaxQuestions(); i++) {
    cout << i << endl;
  }

  q.DumpNew();
  q.MaxQuestions(1000);  // dunno if this could be passed from somewhere...

  objectlist_t bestidxval; // obs! this is for faking *ResultsTrecvid()

  trecvid = trecvid_was;
  AnalyseBestResultsTrecvid(&q, bestidxval);

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseInteractive(const vector<string>& r){
  string msg = "AnalyseInteractive() : ";
  
  static vector<size_t> indices;
  static list<string>   classes;

  string cnamesuffix = "_xy";

  cout << msg << "r.size()=" << r.size();
  for (size_t i=0; i<r.size(); i++)
    cout << " [" << r[i] << "]";
  cout << endl;

  string arg = r.size()>1 && r[0].substr(0, 2)=="**" ? r[1] : "";

  if (arg=="" || arg=="restart") {
    ReadFiles();

    indices = ViewClassGT().indices(1);
    cout << endl;
    CheckDB()->GroundTruthSummaryTable(ViewClassGT());
    cout << endl;
    
    classes = CheckDB()->SplitClassNames(classname);
    for (list<string>::const_iterator i=classes.begin();
         i!=classes.end(); i++) {
      string cname = *i+cnamesuffix;
      ground_truth gt = CheckDB()->GroundTruthExpression(*i);
      size_t nn = gt.indices(1).size();
      if (!nn)
        return ShowError(msg+"empty class <"+*i+">");

      ofstream os(cname.c_str());
      os << "#" << endl;
      os << "# single-object click-locations" << endl;
      os << "# viewclass=[" << CheckQuery()->ViewClass() << "] "
         << indices.size() << " items" << endl;
      os << "# class=[" << *i << "] " << nn << " items" << endl;
      os << "# " << TimeStamp() << endl;
      os << "# " << Picsom()->UserName() << endl;
      os << "#" << endl;

      if (!os)
        return ShowError(msg+"failed to write in class file <"+cname+">");

      os.close();
    }

    if (!Picsom()->FindAnalysis(this)) {
      // hopefully "this" won't ever be deleted...
      Picsom()->AppendAnalysis(this); 
      // this doesn't return:
      return Picsom()->SetUpListenConnection(true, false,
					     "/analyse/interactive/");  
    }
    
    return true;
  }

  cout << endl << "AnalyseInteractive >>>>> " << arg << " <<<<<< ";

  if (arg.find("click ")==0) {
    string line = arg.substr(6);
    size_t p = line.find(' ');
    line.insert(p+1, "xy=(");
    line.append(")");

    string label = line;
    p = label.find(' ');
    label. erase(p);
    int idx = CheckDB()->LabelIndex(label);
    if (idx<0)
      return ShowError(msg+"LabelIndex("+label+") failed");
    
    bool found = false;
    for (list<string>::const_iterator i=classes.begin();
         i!=classes.end(); i++) {
      ground_truth gt = CheckDB()->GroundTruthExpression(*i);
      if (gt[idx]!=1)
        continue;

      string cname = *i+cnamesuffix;
      ofstream os(cname.c_str(), ios::app);
      os << line << endl;
      if (!os)
        return ShowError(msg+"failed to append in class file <"+cname+">");
    
      if (!found) 
        cout << "recorded as [" << line << "] in ";
      else
        cout << " and ";
          
      cout << "<" << cname << ">";

      found = true;
    }
    cout << endl << endl;

    if (!found)
      return ShowError(msg+"no matching class found");

    return true;
  }

  if (arg.find("next")==0) {
    CheckQuery()->DeleteSeen();
    CheckQuery()->DeleteNew();

    if (indices.size()==0) {
      WriteLog(msg+"experiment ending SUCCESSFULLY!");
      return true;
    }

    int i = indices[0];
    indices.erase(indices.begin());
    DataBase *db = CheckDB();
    query->AppendNewObject(new Object(db, i, select_question, 1.0));

    cout << "prepared for [" << Label(i) << "] " << indices.size()
         << " still left" << endl << endl;
  
    return true;
  }

  return ShowError(msg+"command ["+arg+"] not understood");
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseSearch(const vector<string>& args) {
  if (topics=="")
    return ShowError("AnalyseSearch() : topics not set");

  string msg = "AnalyseSearch() : ";
  WriteLog(msg+"topics=<", topics, ">");

  analyse_result result_x;

  string topicfile(topics);
  string topicnum;

  // check if we have topic in the form "topicfile@num=1234"
  size_t ind = topicfile.find('@');
  if (ind != string::npos) {
    topicnum = topicfile.substr(ind+1);
    topicfile.erase(ind);
    if ((ind = topicnum.find("num=")) != string::npos) {
      topicnum.erase(0,ind+4);
      if (topicnum.find_first_not_of("0123456789") != string::npos)
        return ShowError(msg+"invalid topic number <"+topicnum+">");
    }
    else
      return ShowError(msg+"invalid topics <"+topics+">");
  }
  bool topicnumempty = topicnum=="";

  string topicorig = topicfile;
  if (!FileExists(topicfile)&&topicfile[0]!='/'&&topicfile[0]!='.') {
    topicfile = CheckDB()->SolveDirectory("analysis/best","")+"/"+topicorig;
    if (!FileExists(topicfile)) {
      topicfile = CheckDB()->SolveDirectory("analysis","")+"/"+topicorig;
      if (!FileExists(topicfile)) {
        topicfile = CheckDB()->SolveDirectory("","")+"/"+topicorig;
        if (!FileExists(topicfile))
          return ShowError(msg+"failed to find <"+topicorig+">");
      }
    }
  }
  XmlDom xml  = XmlDom::Parse(topicfile);
  XmlDom root = xml.Root();
  if (!root)
    return ShowError(msg+"failed to parse <"+topicfile+">");

  if (root.NodeName()=="videoTopic") {
    if (topicnumempty || root.Property("num")==topicnum) {
      if (InServer())
        return AnalyseSearchAppendTopicList(root);
      else
        return AnalyseSearchVideoTopic(root, args);
    }
    else
      return ShowError(msg+"topic num <"+topicnum+"> not found");
  }

  if (root.NodeName()=="videoTopics") {
    bool ok = true;
    bool topicnumfound = false;
    for (XmlDom node = root.FirstChild(); ok && node; node = node.Next()) {
      if (node.IsText() || node.IsComment())
        continue;
      if (node.NodeName()=="videoTopic") {

        if (!topicnumempty) {

          if (node.Property("num")==topicnum) {
            topicnumfound = true;
            if (InServer())
              ok = AnalyseSearchAppendTopicList(node);

            ok = ok && AnalyseSearchVideoTopic(node, args).ok();

            if (!InServer()) {
              result_x = AnalyseSearchBest("tNum"+topicnum, args);
              ok = ok && result.ok();
            }
          }
        }
        else { // topicnum==""
          if (InServer())
            ok = AnalyseSearchAppendTopicList(node);
          else
            ok = AnalyseSearchVideoTopic(node, args).ok();
        }

      } 
      else
        ShowError(msg+"strange node <"+node.NodeName()+"> in loop");
    }

    if (!topicnumempty && !topicnumfound)
      return ShowError(msg+"topic num <"+topicnum+"> not found");

    return result_x;
  }

  return ShowError(msg+"strange node <"+root.NodeName()+"> as root");
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result 
Analysis::AnalyseSearchVideoTopic(const XmlDom& node,
                                  const vector<string>& /*args*/) {

  string msg = "AnalyseSearchVideoTopic()";
  string num = node.Property("num");
  if (num=="")
    return ShowError(msg+" : num property not found");

  msg += " num=\""+num+"\"";

  WriteLog(msg);

  if (Target()==target_no_target)
    CheckQuery()->Target(target_video);

  if (trecvid=="" && InServer()) {
    trecvid = "result-"+num;
    if (trecvid_runid=="")
      trecvid_runid    = parent ? parent->trecvid_runid    : "I";
    if (trecvid_priority=="")
      trecvid_priority = parent ? parent->trecvid_priority : "6";
    // Simple::SetTimeNow(start_time);
    // cout << endl << endl << "SETTING START TIME" << endl << endl << endl;
  }
  
  DataBase *db = CheckDB();
  const string& dbname = db->BaseName();
  bool legacydb = (dbname == "trecvid2005");                          

  ground_truth gt(db->Size(), -1);

  string aspname  = trecvid_useaspects ? "example" : "";
  size_t nexamples = 0;

  bool ok = true;
  for (XmlDom n = node.FirstChild(); ok && n; n = n.Next()) {
    if (n.IsText() || n.IsComment())
      continue;
    const string name = n.NodeName();
    if (name=="textDescription") {
      string text = n.Property("text");
      if (text=="")
        ShowError(msg+" : text property not found");
      WriteLog("  textDescription text=\""+text+"\"");
      query->TextQuery(text);

    } else if (name=="imageExample" || name=="videoExample"
               || name=="audioExample") {
      if (trecvid_noexamples)
        continue;
      string src = n.Property("src");
      if (src=="")
        ShowError(msg+" : src property not found");

      string desc = n.Property("desc");

      string start = n.Property("start"), stop = n.Property("stop");
      if ((start=="" || stop=="") && name!="imageExample")
        ShowError(msg+" : start/stop property not found");

      string url = src;
      if (start!="") {
        if (legacydb)
          url += "##"+start+","+stop;
        else {
          double startsec = TimeStringToSeconds(start);
          double dursec = TimeStringToSeconds(stop)-startsec;
          url = "["+SecondsToMPEG7MediaTimePoint(startsec)+"/"+
            SecondsToMPEG7MediaDuration(dursec)+"]"+url;
        }
      }
      int idx = db->ReverseURL(url);

      if (idx==-1 && !legacydb) {
        url = src+"##"+start+","+stop;
        idx = db->ReverseURL(url);
      }

      string idxstr = idx==-1 ? " -not found-" : " INDEX="+ToStr(idx);

      WriteLog("  "+name+" src=\""+src+"\"",
               name!="imageExample" ?
               " start=\""+start+"\" stop=\""+stop+"\"" : "",
               desc!="" ? " desc=\""+desc+"\"" : "",
               idxstr);

      if (idx!=-1) {
        gt[idx] = 1;

        aspect_data asp;
        asp.value = 1.0;
        map<string,aspect_data> aspmap;
        aspmap[aspname] = asp;
        
        Object *obj = new Object(db, idx, select_show, +1.0, "", -1, NULL,
                                 &aspmap);

        query->AddToSeen(obj);

        obj = new Object(db, idx, select_show);
        query->AppendNewObject(obj);

        nexamples++;
      }

    } else
      ShowError(msg+"strange node <"+n.NodeName()+">");
  }

  WriteLog("AnalyseSearchVideoTopic() : added "+ToStr(nexamples)+
           " positive example objects"+
           (trecvid_useaspects ? " to aspect \"example\"" : ""));

  string mstr;
  list<string> extra;
  ground_truth_list gtl;
  query->WriteAnalyseVariablesNew("SearchVideoTopic", mstr, gtl, extra);
  query->DoubleLogSeparator(mstr);

  if (classname!="") {
    string text = "Class created from search task "+num;
    return db->ConditionallyWriteClassFile(true, classname, gt, text, false);
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

void Analysis::SplitSecondsTime(const double secs, int& hour, int& min, 
                                int& sec, int& msec) {
  // fixme: calculate hour as well...
  hour = 0;
  min = (int)floor(secs/60);
  double totsec = secs-min*60;
  sec  = (int)floor(totsec);
  msec = (int)floor((totsec-sec)*1000+0.5);
}

///////////////////////////////////////////////////////////////////////////////

string Analysis::SecondsToMPEG7MediaTimePoint(const double secs) {
  char buf[30];
  int hour, min, sec, msec;
  SplitSecondsTime(secs, hour, min, sec, msec);
  sprintf(&buf[0],"T%02d:%02d:%02d:%dF%d",hour,min,sec,msec,1000);
  return string(buf);
}

///////////////////////////////////////////////////////////////////////////////

string Analysis::SecondsToMPEG7MediaDuration(const double secs) {
  char buf[30];
  int hour, min, sec, msec;
  SplitSecondsTime(secs, hour, min, sec, msec);
  if (hour != 0)
        sprintf(&buf[0],"PT%dH%dM%dS%dN%dF",hour,min,sec,msec,1000);
  else
        sprintf(&buf[0],"PT%dM%dS%dN%dF",min,sec,msec,1000);
  return string(buf);
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseSearchBest(const string& tnum, const vector<string>& args) {
  WriteLog("AnalyseSearchBest tnum=<"+tnum+">");

  cout << endl << "textquery=<" << query->TextQuery() << ">" << endl << endl;

  if (query->HasDynamicBinaryTextFeatures())
    query->ProcessTextQuery();

  ReadFiles();

  ground_truth posi_gt, nega_gt, view;
  posi_gt.label(tnum);
  query->SetPositive(tnum);

  if (query->HasViewClass()) {
    target_type t = query->Target();
    int o = -1;
    view = GetDataBase()->GroundTruthExpression(query->ViewClass(),
                                                t, o, expand);
  }

  aspect_map_t posi, nega;
  posi[""] = make_pair(posi_gt, 1.0);
  nega[""] = make_pair(nega_gt, 1.0);
  
  analyse_result bestres = AnalyseBestFinalPart(posi, nega, view, args);
  
  return bestres; 
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::AnalyseSearchAppendTopicList(const XmlDom& node) {
  string msg = "AnalyseSearchAppendTopicList()";

  string num = node.Property("num");
  if (num=="")
    return ShowError(msg+" : num property not found");

  msg += " num=\""+num+"\"";

  WriteLog(msg);
  
  string description;

  for (XmlDom n = node.FirstChild(); n; n = n.Next()) {
    if (n.IsText() || n.IsComment())
      continue;
    const string name = n.NodeName();
    if (name=="textDescription") {
      description = n.Property("text");
      break;
    } 
  }

  if (description=="")
    ShowError(msg+" : textDescription->text property not found");

  searchtasks.push_back( pair<string,string>(num, description) );

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseConcatText(const vector<string>&) {
  target_type t = query->Target();
  int o = -1;

  WriteLog("AnalyseConcatText target=", TargetTypeString(t));

  ground_truth set = GroundTruthExpression(classname, t, o, expand);
  CheckDB()->GroundTruthSummary(set);

  string outname = classname+".txt";
  ofstream ostr(outname.c_str());
  if (!ostr)
    return ShowError("AnalyseConcatText() failed to open <"+outname+">");

  int n = 0;
  for (int i=0; i<(int)set.size(); i++) {
    if (!(CheckDB()->ObjectsTargetType(i)&target_text))
      continue;

    bool yes = set[i]==1;
    if (!yes) {
      const object_info *oi = CheckDB()->FindObject(i);
      int p = oi->default_parent();
      yes = p!=-1 && set[p]==1;
    }
    if (!yes)
      continue;

    string fname = CheckDB()->SolveObjectPath(Label(i));
    cout << CheckDB()->ObjectDump(i) << " " << fname << endl;

    string txt = FileToString(fname);
    ostr << txt;
    
    n++;
  }

  if (!ostr)
    return ShowError("AnalyseConcatText() failed to write in <"+outname+">");

  WriteLog("Successfully concatenated "+ToStr(n)+" files in <"+outname+">");

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseSimulate(const vector<string>& args) {
  list<string> classes = GetDataBase()->SplitClassNames(classname);

  rfbnoise.Seed(GetQuery()->RndSeed());

  if (classes.size()==1)
    return AnalyseSimulatePerClass(args);

  bool keep_subs = true;

  string mstr("% combined result for classes "), xxxstr;
  mstr += classname + "\n\n";

  ground_truth gt_xxx(classname);
  query->WriteAnalyseVariablesOld("Simulate", -1, &gt_xxx, NULL,
                                  rounds, false, mstr);
  query->DoubleLogSeparator(xxxstr);

  string classname_saved(classname), matlabname_saved(MatlabName());
  int classrounds_saved = classrounds;

  analyse_result finalresult;

  double corrsum = 0, totsum = 0, biassum = 0;
  int nres = 0;

  int ii = 0;
  bool ok = true;
  for (list<string>::const_iterator i = classes.begin();
       ok && i!=classes.end(); i++, ii++) {
    classname = *i;

    WriteLog("Starting <"+classname+"> "+ToStr(ii)+"/"+ToStr(classes.size()));

    if (matlabname_saved!="")
      MatlabName(matlabname_saved+"_"+classname);

    analyse_result res = AnalyseSimulatePerClass(args);
    if (!res.empty()) {
      AddToResult(res, finalresult);
      corrsum += res.corr*res.rescount;
      totsum  += res.tot*res.rescount;
      biassum += res.bias*res.rescount;
      nres    += res.rescount;
      if (keep_subs)
        finalresult.add_sub_result(res);

      //cout << res.corr << " " << res.tot << " " << res.rescount << endl;
    }
    else
      ok = false;

    classrounds = classrounds_saved;
  }

  classname = classname_saved;
  MatlabName(matlabname_saved);

  AnalyseResultSetSizes(finalresult, corrsum/nres, totsum/nres, biassum/nres);
  WriteAnalyseResults("Simulate", finalresult, mstr, true, true);

  return ok&&finalresult.ok() ? finalresult : false;
}
  
///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseSimulatePerClass(const vector<string>&) {
  string err = "AnalyseSimulatePerClass() : ";

  target_type tt = query->Target();
  const DataBase *db = GetDataBase();

  analyse_result empty(0.0, 0.0);

  int o = 0;
  ground_truth corr_cls = GroundTruthExpression(classname, tt,o, expand);
  if (!corr_cls.NumberOfEqual(1)) {
    ShowError(err+"found no objects [", TargetTypeString(tt),
              "] of class <", classname, ">");
    return empty;
  }

  ground_truth corr_rst = db->RestrictionGT();
  if (!corr_rst.NumberOfEqual(1)) {
    ShowError(err+"found no objects [", TargetTypeString(tt),
              "] of restriction <", db->RestrictionName(), ">");
    return empty;
  }

  ground_truth correct = corr_cls.TernaryMask(corr_rst);
  if (!correct.NumberOfEqual(1)) {
    ShowError(err+"empty correct set");
    return empty;
  }

  ground_truth tested = TestSet(corr_cls, tt, o);
  if (tested.Length()==0)
    return empty;

  size_t npos_test = (size_t)tested.NumberOfEqual(1);
  if (!npos_test) {
    ShowError(err+"empty tested set");
    return empty;
  }

  bool restrction_tested_separate
    = corr_rst.TernaryAND(tested).NumberOfEqual(1)==0;

  ground_truth watchclass;
  if (watchclassname!="") {
    watchclass = GroundTruthExpression(watchclassname, tt, o, expand);
    if (!watchclass.NumberOfEqual(1)) {
      ShowError(err+"found no objects [", TargetTypeString(tt),
                "] of watch class <", watchclassname, ">");
      return empty;
    }
  }

  bool have_dollars = false;
  aspect_map_t aspect;
  vector<string> pos_asp = query->PositiveAspects();
  for (size_t a=0; a<pos_asp.size(); a++) {
    ground_truth gt;
    const string& gts = query->Positive(pos_asp[a]);
    if (gts.find("$$")==string::npos)
      gt = GTExpr(gts);
    else {
      gt.label(gts);
      have_dollars = true;
    }
    aspect[pos_asp[a]] = make_pair(gt, 1.0);
  }

  if (query->Algorithm()==cbir_sq)
    query->ScalarQuantize();

  bool do_chain = false;

  query->SetIdentity(string("simulate-")+classname+":");

  int exampleidx = -1;
  bool example_or_aspects = forcehit || aspect.size();
  vector<size_t> corset;

  if (example_or_aspects) {    
    corset = tested.indices(1);

    if (corset.size()!=npos_test) {
      ShowError(err+"corset.size()!=tested.NumberOfEqual(1)");
      return empty;
    }

    if (classrounds==0) 
      exampleidx = corset[query->RndSeed()%corset.size()];
  }

  vector<size_t> watchset = watchclass.indices(1);

  ReadFiles(true);

  string mstr = "% " + TimeStamp() + "\n%\n";

  ground_truth_list gtl;
  AddGroundTruthInfo(gtl, "class",   correct);
  AddGroundTruthInfo(gtl, "testset", tested);
  AddAspectInfo(gtl, "positive", aspect);

  list<string> extra;
  AddExtraVariableInfo(extra, "rounds",   ToStr(rounds));
  AddExtraVariableInfo(extra, "do_chain", ToStr(do_chain));
  AddExtraVariableInfo(extra, "truncate", ToStr(truncate));

  string rfbnoise      = gt_noise.str();
  string rfbnoise_gaze = gt_gaze_noise.str();
  AddExtraVariableInfo(extra, "rfbnoise", rfbnoise);
  AddExtraVariableInfo(extra, "rfbnoise.gaze", rfbnoise_gaze);

  string clicks_max_str = clicks_max==numeric_limits<size_t>::max() ?
    "unlimited" : ToStr(clicks_max);
  AddExtraVariableInfo(extra, "clicks_min", ToStr(clicks_min));
  AddExtraVariableInfo(extra, "clicks_max", clicks_max_str);

  query->WriteAnalyseVariablesNew("Simulate", mstr, gtl, extra);
  query->DoubleLogSeparator(mstr);

#ifdef USE_MRML
  if (mrmlserver.size())
    DoubleLog(mstr, "AnalyseSimulate: mrmlserver=", mrmlserver);
#endif // USE_MRML

  bool all_rounds_requested = classrounds==-1;
  if (example_or_aspects && classrounds==-1)
    classrounds = npos_test;

  size_t classidx = 0;
  if (example_or_aspects && firstforcedidx!=-1) {
    DoubleLog(mstr, "AnalyseSimulate: firstforcedidx=",ToStr(firstforcedidx));
    while (corset[classidx]!=(size_t)firstforcedidx) {
      classidx++;
      if (classidx>=corset.size()) {
        ShowError(err+"could not find firstforcedidx=",
                  ToStr(firstforcedidx));
        return empty;
      }
    }
  }

  if (forcehit && classrounds+classidx>npos_test) {
    classrounds = npos_test-classidx;
    if (!all_rounds_requested)
      ShowError(err+"too many classrounds requested, setting to ",
                ToStr(classrounds));
  }

  query->DoubleLog(mstr, "AnalyseSimulate: classidx=",    ToStr(classidx));
  query->DoubleLog(mstr, "AnalyseSimulate: classrounds=", ToStr(classrounds));
  query->DoubleLog(mstr, "AnalyseSimulate: matlabname=",  MatlabName());
  query->DoubleLogSeparator(mstr);

  int skipped = classidx;

  pair<size_t,size_t> corr_all = db->GroundTruthTypeCount(correct,
                                                          query->Target());

  //double corr = correct.NumberOfEqual(1), incorr = correct.NumberOfEqual(-1);
  double corr = corr_all.first;
  double tot = corr_all.second;
  
  if (restrction_tested_separate) { corr++; tot++; }

  analyse_result finalresult(corr, tot);

  int roundnr = 1;
  string orgmapimagename=query->MapImageName();

  map<string,analyse_result> asp_cache;

  do {
    if (classrounds>0) {
      if (example_or_aspects) 
        exampleidx = corset[classidx];
      classidx++;
    }

    if (orgmapimagename!="") {
      stringstream ss;
      ss << orgmapimagename << "_" << roundnr;
      query->MapImageName(ss.str());
    }

    string asp_set;
    if (example_or_aspects && have_dollars) {
      aspect.clear();
      for (size_t a=0; a<pos_asp.size(); a++) {
        string gts = query->Positive(pos_asp[a]);
        string gte = ExpandDollars(gts, Label(exampleidx));
        ground_truth gt = GTExpr(gte);
        aspect[pos_asp[a]] = make_pair(gt, 1.0);
        if (gte!=gts)
          WriteLog("Expanded $$ in ["+gts+"] to ["+gte+"] = "+gt.text());
        db->GroundTruthSummaryTable(gt, true, false, *aout);
        asp_set += (asp_set!=""?"+":"")+gt.text();
      }
    }

    roundnr++;

    int forcedidx = forcehit ? exampleidx : -1;
    bool forced_corr = forcedidx>=0 && corr_cls[forcedidx]==1;

    analyse_result tauresult;
    if (!forcehit && asp_cache.find(asp_set)!=asp_cache.end()) {
      WriteLog("Reusing result with aspects ["+asp_set+"]");
      tauresult = asp_cache[asp_set];

    } else {
      tauresult = AnalyseSimulateOneRun(correct, forcedidx, forced_corr,
					rounds, do_chain, watchset, aspect);
      if (asp_set!="") {
        WriteLog("Storing result with aspects ["+asp_set+"]");
        asp_cache[asp_set] = tauresult;
      }
    }      

    if (tauresult.empty())
      return tauresult;

    if (finalresult.bias==0)
      finalresult.bias = tauresult.bias;

    AddToResult(tauresult, finalresult);

    WriteAnalyseResults("Simulate", finalresult, mstr, true, verbose>1);

  } while (classrounds>0 && int(classidx)-skipped<classrounds);

  return finalresult;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseSimulateOneRun(const ground_truth& correct, int forcedimg,
                           bool forcedcorr, int nrounds, bool do_chain,
                           const vector<size_t>& watchset,
                           const aspect_map_t& aspect) {
  string err = "AnalyseSimulateOneRun() : ";

  bool use_gaze_relevance_group_values = true; // should be scriptable!
  bool aspecthit_triggers_phase2 = false;  // should be scriptable!

  IntVector histcorr, histtot;
  double estmax, estmin, estfit = 0, estord = 0, estbirds = 0;
  double recall = 0, precision = 0, precavg = 0;

  const DataBase *db = CheckDB();
  pair<size_t,size_t> corr_all = db->GroundTruthTypeCount(correct,
                                                          query->Target());
  
  int dbsize_all = correct.Length(); // was db->Size()
  int dbsize_def = corr_all.second;  // was dbsize_all-correct.NumberOfEqual(0)
  int csum =       corr_all.first;   // was correct.NumberOfEqual(1);

  /// should this be instead applied on forcedobj ???
  int restricted_objects_seen = 0;
  if (forcedimg>=0 && correct[forcedimg]!=1 && forcedcorr) {
    csum++;
    dbsize_def++;
    restricted_objects_seen = 1;
  }

  // vector<int> fsvec = AnalyseSimulateClickedExample(forcedimg, correct.label());
  // int forcedseg = fsvec.size() ? fsvec[0] : -1;
  // if (forcedimg>=0 && segmentspec!="" && forcedseg==-1) // this may not be OK
  //   return ShowError(err+"something wrong with "
  //                     "AnalyseSimulateClickedExample() ???");
  //  int forcedobj = forcedseg>=0 ? forcedseg : forcedimg; 
  int forcedobj = forcedimg;

  IntVector hits, done(dbsize_all);
  vector<float> vf_hits;

  Query *rootquery = new Query(picsom);
  Query *oq = rootquery;
  oq->Parent(query);
  oq->SetIdentity();
  oq->CopySome(*query, true, false, false);
  oq->ZeroRound();
  oq->RestrictedObjectsSeen(restricted_objects_seen);
  oq->RndSeedStep(true/*false*/);

  string mdump = Query::MatlabDump();
  WriteLog("AnalyseSimulate: class   = ", classname);
  if (forcedimg>=0) {
    WriteLog("AnalyseSimulate: forcedimg = ", ToStr(forcedimg), 
             " [", GetDataBase()->Label(forcedimg), "]");
    if (forcedobj!=forcedimg)
       WriteLog("AnalyseSimulate: forcedobj = ", ToStr(forcedobj), 
                " [", GetDataBase()->Label(forcedobj), "]");
    WriteLog("AnalyseSimulate: forcedcorr = ", ToStr(forcedcorr));
    if (mdump!="")
      Query::MatlabDump(mdump+ToStr(forcedobj));
  }
  WriteLog("AnalyseSimulate: rndseed = ", oq->RndSeedStr());

  if (verbose>1) {
    string xxxtmp;
    DoubleLogSeparator(xxxtmp);
  }

  ground_truth forced_initial_gt;
  int bias = 0;
  if (usebias) {
    if (forcedobj>=0)
      bias = 1;
    else if (oq->StageFunc(stage_initial_set)==func_only_forced_images) {
      const string& fi = oq->StageArgs(stage_initial_set);
      if (fi!="") {
	forced_initial_gt = GTExpr(fi);
	bias = forced_initial_gt.positives();
	// obs! this should handle also ternary gt case with negative objects!
	// see also Query::OnlyForcedObjects() !
	// bias = forced_initial_gt.size()-forced_initial_gt.zeros();
	if (verbose>1) {
	  cout << "initial_set=only_forced_images(" << fi
	       << ") leads to bias=" << bias << endl;
	}
      }
    }
  }

  analyse_result empty(0.0, 0.0);
  analyse_result results(csum, dbsize_def, bias);

  if (forcedobj>=0) {
    if (oq->StageFunc(stage_initial_set)!=func_only_forced_images)
      ShowError(err+"stages[stage_initial_set]!=func_only_forced_images");
    char idxtxt[20];
    sprintf(idxtxt, "#%d", forcedobj);
    oq->StageArgs(stage_initial_set, idxtxt);
  }

  picsom->PossiblyShowDebugInformation("AnalyseSimulateOneRun() starting");

  RandVar rnd(CheckQuery()->RndSeed());

  bool do_truncate = false;
  int total_corrcount = 0, first_positives = -1, i = 0;
  int totidx = bias, first_hit = -1;
  int htotsum = 0, hcorsum = 0;

  for (; nrounds<=0 || i<nrounds; i++) {
    Query *nq = do_chain ? new Query(picsom) : oq;

    if (do_chain) {
      nq->Parent(oq);
      nq->SetIdentity();
      nq->CopySome(*oq, true, false, false);

    } else {
      //      nq->DeleteIndexData();  // obs! this will once be too radical!
      //      nq->DeleteVQUnits_xxx();
      //      nq->DeletePerMapNew_xxx();
      nq->DeleteCombined();
      nq->DeleteUnique();
      nq->DeleteNew();

      nq->AllSeenReally();
    }

    if (query->MapImageName()!="") {
      stringstream ss;
      ss << query->MapImageName() << "r"<<i;
      nq->MapImageName(ss.str());
    }

    Query::Watchset(watchset);

    bool cbir_stages_run = false;
    if (!do_truncate) {

#ifdef USE_MRML
      // if connection was made to MRML server
      if (mrmlserver!="") {
        if (!mrml_connection || !nq->MRMLSinglePass(mrml_connection)) {
          ShowError(err+"Analysis::MRMLSinglePass() failed",
                    mrml_connection?"":": mrml_connection==NULL");
          results = empty;
          goto out;
        }
        cbir_stages_run = true;
      }
#endif //USE_MRML

      if (!cbir_stages_run && !nq->CbirStages()) {
        ShowError(err+"CbirStages() failed");
        results = empty;
        goto out;
      }
    }

    int truncated_length = nq->MaxQuestions();
    if (hits.Length()+truncated_length>dbsize_def)
      truncated_length = dbsize_def-hits.Length();

    int corrcount = 0, totcount = 0;
    int length = do_truncate ? truncated_length : nq->NnewObjects();

    if (!length && i==bias) {
      ShowError(err+"NnewImages() empty");
      break;
    }

    int skipx = 0;
    size_t ncorres = 0;

    vector<bool> resvec;

    for (int j=0; skipx+j<length; j++) {
      if (do_truncate || 
	  (nq->NewObject(skipx+j).Retained() &&
	   nq->NewObject(skipx+j).SelectType() == select_question)) {
	int idx = -1;
	if (!do_truncate) {
	  const Object& img = nq->NewObject(skipx+j);
	  idx = img.Index();
	  if (idx<0) {
	    j = length;
	    continue;
	  }
	  if (!db->ObjectsTargetTypeContains(idx, query->Target())) {
	    j = length;
	    continue;
	  }
	}

	bool res = false;
	if (!do_truncate) {
	  if (forcedcorr && idx==forcedobj)
	    res = true;
	  else
	    res = correct[idx]==1;
	}
	resvec.push_back(res);
	ncorres += res;

      } else
	skipx++;
    }

    if (verbose>4)
      cout << "counted " << ncorres << " relevant hits ";

    size_t ncorres_true = ncorres;

    if (ncorres<=clicks_max && ncorres>=clicks_min) {
      resvec.clear();
      if (verbose>4)
	cout << "no flips needed" <<endl;
      
    } else {
      while (ncorres<clicks_min && ncorres<resvec.size()) {
	size_t r = (size_t)rnd.RandomInt(resvec.size()-ncorres);
	bool found = false;
	for (size_t i=0; i<resvec.size(); i++)
	  if (!resvec[i]) {
	    if (!r) {
	      found = true;
	      resvec[i] = true;
	      ncorres++;
	      if (verbose>4)
		cout << "flipped #" << i << " false->true  ";
	      break;

	    } else
	      r--;
	  }
	  
	if (!found)
	  return ShowError(err+"ncorres<clicks_min failed");
      }

      while (ncorres>clicks_max) {
	size_t r = (size_t)rnd.RandomInt(ncorres);
	bool found = false;
	for (size_t i=0; i<resvec.size(); i++)
	  if (resvec[i]) {
	    if (!r) {
	      found = true;
	      resvec[i] = false;
	      ncorres--;
	      if (verbose>4)
		cout << "flipped #" << i << " true->false  ";
	      break;

	    } else
	      r--;
	  }

	if (!found)
	  return ShowError(err+"ncorres>clicks_max failed");
      }

      if (verbose>4)
	cout << "ended with " << ncorres << " clicks" << endl;
    }

    vector<int> one_round_hits;
    int skip = 0;
    for (int j=0; j<length; j++) {
      stringstream vout;
      if (do_truncate || 
	  (nq->NewObject(skip).Retained() &&
	   nq->NewObject(skip).SelectType() == select_question)) {
        int idx = -1;
        string score = "*******";
        Object::relevance_distribution r;
        if (!do_truncate) {
          const Object& img = nq->NewObject(skip);
          idx = img.Index();
          if (idx<0) {
            ShowError(err+"Object::FindIndex() with <",
                      img.Label(), "> failed");
            j = length;
            continue;
          }
          if (!db->ObjectsTargetTypeContains(idx, query->Target())) {
            ShowError(err+"target type error: object=["+
                      db->ObjectsTargetTypeString(idx)
                      +"] vs. query=["+
                      TargetTypeString(query->Target())+"] with "+
                      db->ObjectDump(idx));
            j = length;
            continue;
          }
          
          score = ToStr(img.Value());

          r=img.rel_distribution; // MarkAsSeen invalidates img-reference
          // vout << img.DumpString(-1) << endl;
        }

        bool res = false, res_fb = false;
	// bool res_fb_asp = false;
        // res_fb_asp should have value for each aspect
        if (!do_truncate) {
          if (forcedcorr && idx==forcedobj)
            res = true;
	  else if (i==0 && !forced_initial_gt.empty())
	    res = forced_initial_gt[idx]==1;
          else
            res = correct[idx]==1;

          if (!aspecthit_triggers_phase2 || aspect.empty()) 
            res_fb = resvec.empty() ? res : resvec[j];

          for (aspect_map_t::const_iterator a=aspect.begin();
               a!=aspect.end() && !res_fb; a++)
            if (a->second.first[idx]==1) {
              if (aspecthit_triggers_phase2)
                res_fb = true;      // not affected my clicks_min/max
              // else
              //   res_fb_asp = true;  // not affected my clicks_min/max
            }
        }

        hits.Push(res);
        vf_hits.push_back(res);
        one_round_hits.push_back(res);

        if (!do_truncate) {
          done[idx]++;
          if (done[idx]!=1 && !nq->CanShowSeen()) {
            ShowError(err+"done[#", ToStr(idx), "] <",
                      Label(idx), "> set");
            break;
          }
        }

        if (hits.Length()>dbsize_def) {
          ShowError(err+"hits.Length()>dbsize_def");
          break;
        }

        corrcount += res;
        totcount++;

        if (verbose>4)
          vout << i << ":" << j << " " << res << " " << res_fb << " "
               << corrcount
               << "/" << totcount << " " << total_corrcount+corrcount
               << " " << totidx << " (" << bias << ") " << score << " "
               << (do_truncate ? " * truncated *" : db->ObjectDump(idx));

        if (res && first_hit<0)
          first_hit = totidx;
        totidx++;

        if (!do_truncate) {
          double fb_val_true = res_fb ? 1.0 : -1.0;
          double fb_val_eff  = NoisyRFBvalue(fb_val_true);

          if (verbose>4)
            vout << " " << fb_val_true << "->" << fb_val_eff;

          /*
          if (nq->DebugSelective() || fb_val_true!=fb_val_eff) {
            vout << " Marking " << Label(idx) << " as seen w/ val=" << fb_val_eff;
            if (fb_val_true!=fb_val_eff)
              vout << " CORRECT value is " << fb_val_true;
            vout << endl;
          }
          */

          bool set_empty_a = aspect.empty(), ok = false;
          ok = nq->MarkAsSeenEither(idx, fb_val_eff, set_empty_a);
          if (segmentspec!="" && res_fb)
            ok = ok && AnalyseSimulateMarkSegments(nq, idx, correct.label(),
                                                   fb_val_eff, set_empty_a);

          if (!ok) {
            oq->DumpNew();
            nq->DumpSeen();
          }

          Object *o = nq->FindInSeen(idx);
          if (!o) {
            ShowError(err+"newly added object not found in seen");
            break;
          }
          o->rel_distribution = r;
          o->not_really_seen  = false;
          o->GenuineRelevance(true);

          if (verbose>4)
            vout << " rank=" << o->Rank() << " value=" << o->Value();

          if (!aspect.empty()) {
            if (verbose>5)
              vout << "   aspects: [";

            vector<string> e;
            for (aspect_map_t::const_iterator a=aspect.begin(); true; a++) {
              double aval_gt = fb_val_true, aval_eff = aval_gt;
              string anam = "";

              if (a!=aspect.end()) {
                aval_eff = aval_gt = a->second.first[idx];
                anam = a->first;
                if (anam=="gaze") {
		  if (use_gaze_relevance_group_values) {
		    DataBase *dbx = (DataBase*)db;
		    bool ispos = aval_gt==1;
		    size_t npos = ncorres_true;
		    aval_eff = dbx->GazeRelevanceGroupValue(rnd, ispos, npos);
		    if (verbose>5)
		      vout << " {" << ispos << "," << npos << "}";

		  } else
		    aval_eff = NoisyRFBvalue(aval_gt, gt_gaze_noise);
		}

              } else
		aval_eff = fb_val_eff;

              // obs! should aval be multiplied or something?

              if (verbose>5)
                vout << " \"" << anam << "\"=" << aval_gt << "->" << aval_eff;

              bool set_aspect = aval_eff!=0.0;
              if (set_aspect) {
                if (!o->AspectRelevance(anam, aval_eff, "", e)) {
                  ShowError(err+"setting aspect relevance failed");
                  break;
                }
              } else if (verbose>5)
                vout << "(not set)";

              if (a==aspect.end())
                break;
            }
            if (verbose>5)
              vout << " ]";

          } else if (verbose>5)
            vout << "   no aspects defined";
          
        }
        if (verbose>4) {
          string vline = vout.str();
          cout << vline  << endl;
        }

      } else
        skip++;
    }

    if (aspecthit_triggers_phase2 && !aspect.empty() &&
        !total_corrcount && corrcount) {
      if (verbose>1)
        cout << "First relevant object found, changing to phase2" << endl;
      if (!query->ChangePhase("2")) {
        ShowError("ChangePhase(\"2\") failed");
        break;
      }
    }

    double apriori = double(csum-histcorr.Sum())/(dbsize_def-histtot.Sum());

    if (verbose>4)
      cout << "apriori=" << apriori << " csum=" << csum
           << " histcorr.Sum()=" << histcorr.Sum()
           << " dbsize_def=" << dbsize_def
           << " histtot.Sum()=" << histtot.Sum() << endl;        

    total_corrcount += corrcount;

    histcorr.Push(corrcount);
    histtot.Push(totcount);

    int mq = query->MaxQuestions();
    int totcount_should_be = (bias && i==0) ? bias : mq;
   
    if (relaxcounttest) {
      if (totcount <=0) {
        ShowError(err+"no images returned");
        if (!totcount)
          break;
      }

    } else if (totcount!=totcount_should_be && hits.Length()!=dbsize_def) {
      char tmp[1000];
      sprintf(tmp, "totcount=%d maxquestions=%d ", totcount, mq);
      sprintf(tmp+strlen(tmp), "i=%d hits.Length()=%d ", i, hits.Length());
      sprintf(tmp+strlen(tmp), "dbsize_def=%d bias=%d ", dbsize_def, bias);
      sprintf(tmp+strlen(tmp), "forcedimg=%d ", forcedimg);
      //sprintf(tmp+strlen(tmp), "forcedseg=%d ", forcedseg);
      sprintf(tmp+strlen(tmp), "forcedobj=%d ", forcedobj);
      ShowError(err+tmp);
      if (!totcount)
        break;
    }

    double precest = 0;

    estmax   = TauEstimateMax( histtot, histcorr, dbsize_def, csum, mq);
    estmin   = TauEstimateMin( histtot, histcorr, dbsize_def, csum, mq);
    if (!nq->CanShowSeen()) {
      estfit  = TauEstimateFit( histtot, histcorr, dbsize_def, csum, mq);
      estord  = TauEstimateOrder(hits, dbsize_def, csum);
      precest = AveragePrecisionEstimate(hits, dbsize_def, csum, bias);
    }
    else
      estfit = estord = 1;

    estbirds = TauEstimateBIRDS(hits, csum);

    recall    = Recall(hits, csum, bias);
    precision = Precision(hits, bias);
    precavg   = AveragePrecision(hits, csum, bias, NULL);

    double instprec = float(corrcount)/totcount;
    double maxpr    = MaxPR(one_round_hits, csum);

    double false_pos = 0; // obs!
    double true_pos  = 0; // obs!

    if (!bias || i!=0)
      results.setvecs(recall, precision, precavg, instprec, maxpr, apriori,
                      false_pos, true_pos);

    if ((!bias && i==0) || (bias && i==1))
      first_positives = corrcount;

    //estmean = TauEstimateMean(histtot, histcorr, dbsize_def, csum, mq);
    //esttrad = TauEstimateTrad(histtot, histcorr);

    if (verbose>2 || (verbose==2 && !do_truncate) || (verbose>1 && !forcehit)) {
      char sepchar = ':';
      if (do_truncate)
        sepchar = 'x';
      else if (histtot.Sum()<=bias)
        sepchar = '!';
      char tmps[1000];
      sprintf(tmps, 
              "%5d%c %3d/%3d  tot: %6d/%6d  fin: %6d/%6d  "
              "Tau: max %6.4f min %6.4f fit %6.4f ord %6.4f BIRDS-I %6.4f  "
              "Recall: %6.4f  Prec: %6.4f avg %6.4f est %6.4f MPR: %6.4f",
              i, sepchar, corrcount, totcount, histcorr.Sum(), histtot.Sum(), 
              csum, dbsize_def, estmax, estmin, estfit, estord, estbirds,
              recall, precision, precavg, precest, maxpr);
      WriteLog(tmps);
    }

    if (verbose>3) {
     ostream& os = cout;
      for (vector<int>::const_iterator oi = one_round_hits.begin();
           oi != one_round_hits.end(); oi++)
        os << *oi << " ";
      os << "-> " << maxpr << endl;
    }

    if (total_corrcount==csum && truncate && !do_truncate) {
      if (verbose>2)
        cout << "All " << csum
             << " relevant objects found, setting do_truncate = true"
             << endl;
      do_truncate = true;
    }

    picsom->PossiblyShowDebugInformation("AnalyseSimulateOneRun() in loop");

    oq = nq;
    if (!do_chain)
      oq->IncrementRound();

    // nq->DumpSeenRelevance();

    // remove images without genuine relevance from seenimg
   
    nq->RemoveNongenuineFromSeen();

    if (nq->DebugSelective()) {
      cout << "after non-genuine removal: "<< endl;
      nq->DumpSeen();
      int pos,neg;
      IntVector fakediv;
      nq->CountPositivesAndNegatives(fakediv,pos,neg,false,false);
      cout << pos << " positives, "<< neg << " negatives " << endl;
    }

    if (hits.Length()==dbsize_def)
      break;
  }

  picsom->PossiblyShowDebugInformation("AnalyseSimulateOneRun() ending");

  htotsum = histtot.Sum();
  hcorsum = histcorr.Sum();

  // cout << "hcorsum="  << hcorsum << " csum=" << csum
  //      << " htotsum=" << htotsum << " dbsize_def=" << dbsize_def << endl;

  if (hcorsum>csum || htotsum>dbsize_def)
    ShowError(err+"hcorsum>csum || htotsum>dbsize_def");

  // I don't see what would be wrong here... Just a good result...
  // if (hcorsum==csum && htotsum!=dbsize_def)
  //   ShowError(err+"hcorsum==csum && htotsum!=dbsize_def");

  if (hcorsum!=csum && htotsum==dbsize_def)
    ShowError(err+"hcorsum!=csum && htotsum==dbsize_def");

  results.rescount    = 1;
  results.rounds      = i;
  results.seen        = htotsum;
  results.found       = hcorsum;
  results.firstpos    = first_positives;
  results.tau         = estfit;
  results.tauord      = estord;
  results.birds       = estbirds;   
  results.firsthit    = first_hit;
  results.firsthitadv = FirstHitAdv(first_hit, results.corr, results.tot);
  results.firsthitadv_geo = log(1/results.firsthitadv);

  AveragePrecision(hits, hcorsum, bias, &results.avgprecision);
  results.avgprec      = AvgPrecision(results, htotsum);
  // results.avgprecbl = (float(csum)*csum*htotsum)/
  //   (float(AveragePrecisionDivider(csum, htotsum))*dbsize_def*dbsize_def);
  results.avgprecbl    = float(csum)/dbsize_def;
  results.avgprecadv_a = results.avgprec/results.avgprecbl;
  results.avgprecadv_g = results.avgprecadv_a;

  // cout << "csum=" << csum << " dbsize_def=" << dbsize_def
  //      << " htotsum=" << htotsum << endl;
  // cout << "results.avgprec    = " << results.avgprec    << endl;
  // cout << "results.avgprecbl  = " << results.avgprecbl  << endl;
  // cout << "results.avgprecadv = " << results.avgprecadv << endl;

  results.appoint = htotsum;

  // results.inferredap = xxx;  // should this be set too?

  results.set_roc_from_hits(vf_hits, csum, dbsize_def, (size_t)bias);

  if (do_chain) {
    string sp = query->SavePath(false);
    query->Save(sp, true);
  }

  query->DeleteChild(rootquery);

 out:
  Query::MatlabDump(mdump);
  
  Query::Watchset(IntVector());

  return results;
}

  /////////////////////////////////////////////////////////////////////////////

  vector<int> Analysis::AnalyseSimulateClickedExample(int eximg,
                                                      const string& lab) {

    string err = "AnalyseSimulateClickedExample() : ";

    vector<int> res;
    vector<int> r = AnalyseSimulateReferenceSegments(eximg, lab);
    if (r.size()!=1) {
      ShowError(err+"r.size()!=1");
      return res;
    }

    res = AnalyseSimulateExpandSegmentTree(r[0]);
    if (res.empty())
      ShowError(err+"res.empty()");

    return res;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AnalyseSimulateMarkSegments(Query *nq, int eximg,
                                             const string& lab,
                                             double v, bool emptya) {
    string err = "AnalyseSimulateMarkSegments() : ";

    vector<int> seg = AnalyseSimulateClickedExample(eximg, lab);

    for (size_t i = 0; i<seg.size(); i++) {
      nq->MarkAsSeenEither(seg[i], v, emptya);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<int> Analysis::AnalyseSimulateReferenceSegments(int eximg,
                                                         const string& lab) {
    bool debug = false;

    DataBase *db = CheckDB();

    string err = "AnalyseSimulateReferenceSegments("+ToStr(eximg)+","+
      lab+") : ";

    vector<int> res;

    if (eximg<0 || !db->HasXYmap(lab) || segmentspec=="") {
      ShowError(err+"problem 1");
      return res;
    }

    const xymap_t& xymap      = db->XYmap(lab);
    xymap_t::const_iterator i = xymap.find(eximg);
    if (i==xymap.end()) {
      ShowError(err+"xymap.find() failed with "+db->ObjectDump(eximg));
      return res;
    }
    const xymap_ve& xyv = i->second;
    if (debug) {
      cout << "forcedimg " << eximg << " has xy coords for <" << lab << "> ";
      for (size_t j=0; j<xyv.size(); j++)
        cout << (j?",":"") << "(" << xyv[j].first << "," << xyv[j].second
             << ")";
      cout << endl;
    }

    string segmfname = db->SolveObjectPath(Label(eximg), "segments",
                                           segmentspec, true, NULL);
    if (segmfname!="")
      segmfname += ".seg";

    segmentfile segdata("", segmfname);

    for (size_t j=0; j<xyv.size(); j++) {
      int seg = -1;
      segdata.get_pixel_segment(0, xyv[0].first, xyv[0].second, seg);
      string slabel = segmentspec+":"+Label(eximg)+"_"+ToStr(seg);
      int exseg = LabelIndex(slabel);
      res.push_back(exseg);
      if (debug)
        cout << " seg=" << seg << " label=" << slabel << " exseg=" << exseg;
    }
    if (debug)
      cout << endl;

    return res;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<int> Analysis::AnalyseSimulateExpandSegmentTree(int oidx) {
    bool debug = false;

    vector<int> res;

    vector<int> sibl;
    bool is_c, is_s;
    int min = 0, max = 0, par;
    DataBase *db = CheckDB();
    string segm;
    size_t p;

    if (segmentexpand=="" || segmentexpand=="1") {
      if (oidx>=0)
        res.push_back(oidx);
      goto ret;
    }

    is_c = segmentexpand[0]=='C';
    is_s = segmentexpand[0]=='S';

    if (!is_c && !is_s)
      goto ret;

    if (sscanf(segmentexpand.substr(1).c_str(), "%d-%d", &min, &max)!=2)
      goto ret;
    
    if (min<1 || max<min)
      goto ret;

    segm = db->Label(oidx);
    p = segm.rfind('_');
    if (p==string::npos)
      goto ret;
    segm.erase(0, p+1);

    par = db->ParentObject(oidx);
    if (par==-1)
      goto ret;
    sibl = db->SubObjects(par);

    for (size_t i=0; i<sibl.size(); i++) {
      string siblsegm = db->Label(sibl[i]);
      p = siblsegm.rfind('_');
      if (p==string::npos) {
        res.clear();
        goto ret;
      }
      siblsegm.erase(0, p+1);

      vector<string> parts = SplitInSomething("+", false, siblsegm);
      bool found = false;
      for (size_t j=0; j<parts.size() && !found; j++)
        if (parts[j]==segm)
          found = true;
      if (found && is_c && (int)parts.size()>=min && (int)parts.size()<=max)
        res.push_back(sibl[i]);
    }

  ret:
    if (debug) {
      cout << "segmentexpand=[" << segmentexpand << "] " << db->Label(oidx)
           << " ->";
      for (size_t j=0; j<res.size(); j++)
        cout << " " << db->Label(res[j]);
      cout << endl;
    }

    return res;
  }

  /////////////////////////////////////////////////////////////////////////////

  double Analysis::NoisyRFBvalue(double in,const ground_truth_noise& gt) {
    return NoisyRFBvalue(in, gt.gt_np, gt.gt_pn,
			 gt.gt_0p, gt.gt_0n, gt.gt_p0, gt.gt_n0);
  }

  /////////////////////////////////////////////////////////////////////////////

  double Analysis::NoisyRFBvalue(double in, double xgt_np, double xgt_pn,
                                 double xgt_0p, double xgt_0n,
                                 double xgt_p0, double xgt_n0) {
    if (in==-1.0)
      return NoisyRFBvalue(-1.0, xgt_np, +1.0, xgt_n0,  0.0); 
    else if (in==1.0)
      return NoisyRFBvalue(+1.0, xgt_pn, -1.0, xgt_p0,  0.0);
    else if (in==0.0)
      return NoisyRFBvalue( 0.0, xgt_0p, +1.0, xgt_0n, -1.0);

    ShowError("Analysis::NoisyRFBvalue() : unknown input value "+ToStr(in));

    return 0.0;
  }

  /////////////////////////////////////////////////////////////////////////////

  double Analysis::NoisyRFBvalue(double d, double p1, double v1,
                                 double p2, double v2) {
    if (p1==0.0 && p2==0.0)
      return d;

    double x = rfbnoise.Erand();

    if (x<p1)
      return v1;

    if (x<p1+p2)
      return v2;

    return d;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseFillZeroFeatureData(const vector<string>&) {
    WriteLog("AnalyseFillZeroFeatureData");
    string msg = "AnalyseFillZeroFeatureData() : ";

    if (Nindices()!=1)
      return ShowError(msg+"exactly one feature should be specified");

    if (sourcefeature=="")
      return ShowError(msg+"sourcefeature should be specified");

    TSSOM& ts = TsSom(0);

    string fn = ts.FeatureFileName();
    if (sourcefeature==fn)
      return ShowError(msg+"sourcefeature should not match feature");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(msg+"database should be opened -rw=...fea...");

    ground_truth restr = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("FillZeroFeatureData", mstr, gtl, extra);

    vector<size_t> dat_missing, dat_orphan, dat_zero, div_missing;
    int tot =  ts.CheckDataSet(restr, verbose-1, false,
			       dat_missing, dat_orphan,
			       dat_zero, div_missing, true, false);
    
    WriteLog("There were "+ToStr(dat_zero.size())+" zero vectors of "+
	     ToStr(tot)+" in "+fn);

    size_t ncorr = 0, nmiss = 0;
    for (size_t i=0; i<dat_zero.size(); i++) {
      size_t idx = dat_zero[i];
      if (verbose>1)
	cout << i << " #" << idx << endl;
      
      bool angry = true, delete_vec = true;
      FloatVector *vec = CheckDB()->FeatureData(sourcefeature, idx, angry);
      if (vec) {
	if (!vec->IsZero()) {
	  if (!ts.BinDataStoreFeature(*vec))
	    return ShowError(msg+"BinDataStoreFeature() failed");
	  ncorr++;
	  if (verbose>1)
	    cout << " ... " << ncorr << " ok " << nmiss << " missed of "
		 << i << "/" << dat_zero.size() << endl;
	}
	if (delete_vec)
	  delete vec;
      } else
	nmiss++;
    }

    WriteLog(ToStr(ncorr)+" zero vectors were replaced while "+
	     ToStr(nmiss)+" vectors were not available of "+
	     ToStr(dat_zero.size()));

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseFeatureData(const vector<string>&) {
    WriteLog("AnalyseFeatureData");

    string mstr;
    ground_truth_list gtl;
    ground_truth restr = QueryRestrictionGT(); // obs!
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    list<string> extra;
    AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack", TaskStack());
    query->WriteAnalyseVariablesNew("FeatureData", mstr, gtl, extra);

    list<string> summary;

    for (size_t m=0; m<Nindices(); m++) {
      TSSOM& ts = TsSom(m);
      CheckDB()->PossiblyDownloadFeatureData(ts.Name());

      vector<size_t> dat_missing, dat_orphan, dat_zero, div_missing;
      int tot =  ts.CheckDataSet(restr, verbose-1, false,
				 dat_missing, dat_orphan,
				 dat_zero, div_missing, true, false);

      int dok = tot-dat_missing.size()-dat_orphan.size()
	-dat_zero.size()-div_missing.size();

      stringstream ss;
      ss << query->MapName(true, m)
	 << "  total: "     << tot
	 << "  data ok: "   << dok
	 << "  no data: "   << dat_missing.size() 
	 << "  orphans: "   << dat_orphan.size() 
	 << "  zero data: " << dat_zero.size() 
	 << "  no div: "    << div_missing.size();
    
      string s = ss.str();
      WriteLog(s);
      summary.push_back(s);

      if (verbose>1)
	for (size_t i=0; i<2; i++) {
	  vector<size_t> idx;
	  if (i==0) {
	    *aout << "Missing:";
	    idx = dat_missing;
	  }
	  if (i==1) {
	    *aout << "Zero:";
	    idx = dat_zero;
	  }
	  *aout << endl;
	  for (size_t j=0; j<idx.size(); j++)
	    *aout << "  #" << idx[j] << " " << Label(idx[j]) << endl;
	  *aout << endl;
	}
    }
  
    WriteLog("");

    if (summary.size()) {
      WriteLog("Summary of AnalyseFeatureData():");
      WriteLog("");
      for (auto i=summary.begin(); i!=summary.end(); i++)
	WriteLog(*i);
      WriteLog("");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseNearest(const vector<string>& args) {
    string msg = "AnalyseNearest() : ";

    WriteLog("AnalyseNearest");

    if (args.size()!=3) 
      return ShowError(msg+"exactly three arguments should be given: "
		       "ref-database ref-queryrestriction n");

    size_t nn = atoi(args[2].c_str());
    string refdatabase = args[0];
    string refqueryrestriction = args[1];
    string featname = IndexFullName(0);

    DataBase *db = CheckDB();

    DataBase *refdb = Picsom()->FindDataBase(refdatabase);
    ground_truth gt = refdb->GroundTruthExpression(refqueryrestriction);
    FloatVectorSet set;
    for (size_t i=0; i<gt.size(); i++)
      if (gt[i]==1) {
	FloatVector *v = refdb->FeatureData(featname, i, true);
	if (!v)
	  return ShowError(msg+"vector #"+ToStr(i)+" of <"+featname+
			   "> not found in "+refdatabase);
	set.Append(v);
      }
    
    // cout << set.Nitems() << endl;
    // if (set.Nitems())
    //   cout << set[0].Label() << " " << set[0].Number() << endl;    

    const ground_truth& restr = QueryRestrictionGT();
    vector<size_t> idxs = restr.indices(1);

    WriteLog("Finding "+ToStr(nn)+" nearest neighbors of "+ToStr(idxs.size())
	     +" objects ["+restr.label()+"] in <"+db->Name()+"> among "
	     +ToStr(set.Nitems())+" objects ["+gt.label()+"] in <"+
	     refdb->Name()+">");

    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];

      FloatVector *v = db->FeatureData(featname, idx, true);
      if (!v)
	return ShowError(msg+"vector #"+ToStr(idx)+" of <"+featname+
			 "> not found in "+db->Name());

      IntVector vi(nn);
      FloatVector vd;
      if (!set.NearestNeighbors(*v, vi, vd))
	return ShowError(msg+"NearestNeighBors("+ToStr(idx)+") failed");
      delete v;

      cout << "##";
      for (int j=0; j<vi.Length(); j++)
	cout << " " << vi[j];
      cout << " " << db->Label(idx) << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseDetectorDifference(const vector<string>& args) {
    string msg = "AnalyseDetectorDifference() : ";

    bool show_changers = args.size();
    size_t n_chg = 5;

    if (detections.size()!=2)
      return ShowError(msg+"exactly two detections should be specified");

    WriteLog("AnalyseDetectorDifference");

    DataBase *db = CheckDB();
    list<string> cls = db->SplitClassNames(classname);

    const ground_truth& restr = QueryRestrictionGT();
    vector<size_t> idxs = restr.indices(1);

    struct change_t {
      size_t idx;
      int opos, npos, ch;
    };

    for (auto c=cls.begin(); c!=cls.end(); c++) {
      ground_truth corr = db->GroundTruthExpression(*c).TernaryAND(restr);

      vector<map<size_t,change_t> > true_pos, false_pos;

      vector<float> ap;
      for (auto j=detections.begin(); j!=detections.end(); j++) {
	multimap<float,size_t> dv;

	for (auto i=idxs.begin(); i!=idxs.end(); i++) {
	  size_t idx = *i;
      
	  bool dummy = false;
	  auto det = db->RetrieveOrProduceDetectionData(idx, *j, *c, false,
							dummy, true);

	  if (det.size()!=1)
	    return ShowError(msg+"det.size()!=1");
	  
	  if (det.begin()->second.size()!=1)
	    return ShowError(msg+"det.begin()->secondsize()!=1");
	  
	  float v = det.begin()->second[0];
	  dv.insert(make_pair(v, idx));	  

	  // cout << "#" << idx << " " << *c << " " << *j << " " << v << endl;
	}

	map<size_t,change_t> tp, fp;
	vector<float> h;
	for (auto i=dv.rbegin(); i!=dv.rend(); i++) {
	  bool hit = corr[i->second]==1;
	  h.push_back(hit?1:0);

	  change_t ct = { i->second, -1, -1, 0 };

	  if (hit) {
	    ct.opos = tp.size();
	    tp[i->second] = ct;
	  } else {
	    ct.opos = fp.size();
	    fp[i->second] = ct;
	  }
	}
	analyse_result res(h);
	res.avgprec = res.avgprecision.back();

	// cout << *c << " " << *j << " " << res.avgprec << endl;
	ap.push_back(res.avgprec);

	true_pos .push_back(tp);
	false_pos.push_back(fp);
      }

      cout << *c;
      for (size_t i=0; i<ap.size(); i++)
	cout << " " << ap[i];
      cout << "  diff=" << ap[1]-ap[0]
	   << "  rat=" << ap[1]/ap[0] << endl;

      if (show_changers) {
	multimap<int,change_t> tp_change, fp_change;
	for (auto i=true_pos[0].begin(); i!=true_pos[0].end(); i++) {
	  int p = i->second.opos, q = true_pos[1][i->first].opos, ch = p-q;
	  cout << *c << " TP #" << i->first << " " << p << " -> "
	       << q << " ch=" << ch << endl;
	  change_t ct = { i->first, p, q, ch };
	  tp_change.insert(make_pair(ch, ct));
	}
	for (auto i=false_pos[0].begin(); i!=false_pos[0].end(); i++) {
	  int p = i->second.opos, q = false_pos[1][i->first].opos, ch = p-q;
	  cout << *c << " FP #" << i->first << " " << p << " -> "
	       << q << " ch=" << ch << endl;
	  change_t ct = { i->first, p, q, ch };
	  fp_change.insert(make_pair(ch, ct));
	}

	size_t n = 0;
	for (auto i=tp_change.rbegin(); i!=tp_change.rend() && n<n_chg;
	     i++, n++)
	  cout << *c << " TP improve #" << i->second.idx << " " << i->first
	       << " " << i->second.opos << " -> " << i->second.npos << endl;
	n = 0;
	for (auto i=tp_change.begin(); i!=tp_change.end() && n<n_chg;
	     i++, n++)
	  cout << *c << " TP worsen  #" << i->second.idx << " " << i->first
	       << " " << i->second.opos << " -> " << i->second.npos << endl;
	n = 0;
	for (auto i=fp_change.begin(); i!=fp_change.end() && n<n_chg;
	     i++, n++)
	  cout << *c << " FP improve #" << i->second.idx << " " << i->first
	       << " " << i->second.opos << " -> " << i->second.npos << endl;
	n = 0;
	for (auto i=fp_change.rbegin(); i!=fp_change.rend() && n<n_chg;
	     i++, n++)
	  cout << *c << " FP worsen  #" << i->second.idx << " " << i->first
	       << " " << i->second.opos << " -> " << i->second.npos << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseDetectorPerformance(const vector<string>& args) {
    string msg = "AnalyseDetectorPerformance() : ";

    bool show_val = verbose&2, write_png = verbose&4, disp = verbose&32;
    // size_t maxn_per_class = 20, maxn_overall = 100;
    size_t maxn_per_class = 397, maxn_overall = 397;
    size_t n_examp_f = verbose&8  ? query->MaxQuestions() : 0;
    size_t n_examp_c = verbose&16 ? query->MaxQuestions() : 0;

    if (args.size()==0)
      return ShowError(msg+"argument(s) needed");

    if (detections.size()!=1)
      return ShowError(msg+"exactly one detection should be specified");

    WriteLog("AnalyseDetectorPerformance");

    DataBase *db = CheckDB();

    const ground_truth& restr = QueryRestrictionGT();
    vector<size_t> idxs = restr.indices(1);

    list<string> detcls;
    // detcls.push_back(restr.label());

    for (auto i=args.begin(); i!=args.end(); i++) {
      list<string> t = db->SplitClassNames(*i);
      detcls.insert(detcls.end(), t.begin(), t.end());
    }

    list<string> classes = db->SplitClassNames(classname);

    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    string mstr;
    list<string> extra;
    AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack", TaskStack());
    query->WriteAnalyseVariablesNew("DetectionData", mstr, gtl, extra);

    typedef FloatVector::DistanceType::DistType DT;
    list<pair<DT,string> > dt {
      make_pair(  DT::euclidean,              "euc"),
	make_pair(DT::kullback_sym,           "kld"),
	make_pair(DT::cosine,                 "cos"),
	make_pair(DT::chisquare,              "chi"),
	make_pair(DT::histogram_intersection, "his"),
	make_pair(DT::undef,                  "auc"),
	make_pair(DT::undef,                  "eer")
	};
      
    set<string> dt_min { "eer", "his" };
    set<string> iset;
    map<string,map<string,multimap<float,string> > > perf;
    analyse_result res;

    for (auto d=detcls.begin(); d!=detcls.end(); d++) {
      map<string,double> meas_sum, meas_ext;
      for (auto m=dt.begin(); m!=dt.end(); m++) {
	meas_sum[m->second] = 0;
	bool is_max_meas = dt_min.find(m->second)==dt_min.end();
	if (is_max_meas)
	  meas_ext[m->second] =    0; // max
	else
	  meas_ext[m->second] = 1000; // min
      }

      for (auto c=classes.begin(); c!=classes.end(); c++) {
	string detstr = detections[0];
	size_t p = detstr.find("%c");
	if (p!=string::npos)
	  detstr.replace(p, 2, *c);
	p = detstr.find("%d");
	if (p!=string::npos)
	  detstr.replace(p, 2, *d);

	ground_truth gt = db->GroundTruthExpression(*c);

	vector<float> e;
	vector<vector<float> > val { e, e, e };
	multimap<float,size_t> rr, rr_pos, rr_neg;
	size_t hittot = 0;
	for (auto i=idxs.begin(); i!=idxs.end(); i++) {
	  if (gt[*i]==1)
	    hittot++;

	  bool dummy = true;
	  map<string,vector<float> > dets
	    = db->RetrieveDetectionData(*i, detstr, true, dummy);
	  if (dets.size()!=1)
	    return ShowError(msg, "#"+ToStr(*i)+" <"+detstr+
			     "> dets.size()="+ToStr(dets.size()));
	  if (dets.begin()->second.size()!=1)
	    return ShowError(msg, "#"+ToStr(*i)+" <"+detstr+
			     "> dets.begin()->second.size()="+
			     ToStr(dets.begin()->second.size()));
	  float r = dets.begin()->second[0];

	  if (n_examp_c+n_examp_f)
	    iset.insert(db->Label(*i));
	  val[0].push_back(r);
	  rr.insert(make_pair(r, *i));
	  if (gt[*i]==1) {
	    val[1].push_back(r);
	    rr_pos.insert(make_pair(r, *i));
	  } else {
	    val[2].push_back(r);
	    rr_neg.insert(make_pair(r, *i));
	  }

	  if (show_val)
	    cout << *d << " " << *c << " #" << *i << " " << (int)gt[*i]
		 << " " << r << endl;
	}

	if (d==detcls.begin())
	  cout << *c << " pos=" << val[1].size() << " neg=" << val[2].size()
	       << " tot=" << val[0].size() << endl;

	ShowExamples(rr_pos, true,  n_examp_c, db, "true positives",  disp);
	ShowExamples(rr_neg, false, n_examp_c, db, "true negatives",  disp);
	ShowExamples(rr_pos, false, n_examp_f, db, "false negatives", disp);
	ShowExamples(rr_neg, true,  n_examp_f, db, "false positives", disp);

	size_t hs = 100, hd = 50;
	vector<vector<float> >  histall;
	for (size_t k=0; k<3; k++) {
	  const vector<float>& vr = val[k];
	  vector<size_t> histi(hs);
	  for (auto i=vr.begin(); i!=vr.end(); i++) {
	    int j = (int)floor(*i*hs);
	    if (j<0)
	      j = 0;
	    if (j>int(hs)-1)
	      j = hs-1;
	    histi[j]++;
	  }

	  if (write_png) {
	    string bfname = "hist-"+*d+"-"+*c+"-"+ToStr(k)+".png";
	    WriteHistogramImage(histi, hd, false, "abs-"+bfname);
	    WriteHistogramImage(histi, hd, true,  "rel-"+bfname);
	  }

	  histall.push_back(vector<float>(hs));
	  vector<float>& hist = histall[k];
	  float max = 0;
	  if (vr.size()) {
	    for (size_t i=0; i<histi.size(); i++) {
	      hist[i] = float(histi[i])/vr.size();
	      if (hist[i]>max)
		max = hist[i];
	    }
	  }
	}

	string hdr = "PERF "+*c+" "+*d+" ";

	//FloatVector fvhistall(hs, &histall[0][0]);
	FloatVector fvhistpos(hs, &histall[1][0]);
	FloatVector fvhistneg(hs, &histall[2][0]);
	fvhistpos.CalculateSelfDot();
	fvhistneg.CalculateSelfDot();

	vector<float> hits, pvec, rvec;
	size_t tot = 0, hitsum = 0;
	for (auto i=rr.rbegin(); i!=rr.rend(); i++) {
	  bool hit = gt[i->second]==1;
	  hits.push_back(hit ? 1.0 : 0.0);
	  hitsum += hit;
	  tot++;
	  pvec.push_back(hitsum/float(tot));
	  rvec.push_back(hitsum/float(hittot));
	}

	res.rescount = 1;
	res.set_roc_from_hits(hits, val[1].size(), idxs.size(), 0);
	res.precision = pvec;
	res.recall    = rvec;

	for (auto m=dt.begin(); m!=dt.end(); m++) {
	  double dd = -1;
	  if (m->second=="auc")
	    dd = res.roc_auc;
	  else if (m->second=="eer")
	    dd = res.roc_eer;
	  else {
	    FloatVector::DistanceType dist(m->first);
	    dd = fvhistpos.DistanceXX(fvhistneg, &dist);
	  }
	  cout << hdr << m->second << " " << dd << endl;

	  bool is_max_meas = dt_min.find(m->second)==dt_min.end();
	  double sdd = is_max_meas ? dd : -dd;

	  perf[*c][m->second].insert(make_pair(sdd, *d));

	  meas_sum[m->second] += dd;
	  if (is_max_meas) {
	    if (dd>meas_ext[m->second])
	      meas_ext[m->second] = dd; // max!
	  } else {
	    if (dd<meas_ext[m->second])
	      meas_ext[m->second] = dd; // min!
	  }
	}
      }

      for (auto m=dt.begin(); m!=dt.end(); m++) {
	bool is_max_meas = dt_min.find(m->second)==dt_min.end();
	string minmax = is_max_meas ? "_max" : "_min";
	double sdd = is_max_meas ? meas_ext[m->second] : -meas_ext[m->second];
	double avg = meas_sum[m->second]/classes.size();
	double sav = is_max_meas ? avg : -avg;
	perf[""][m->second+"_avg"].insert(make_pair(sav, *d));
	perf[""][m->second+minmax].insert(make_pair(sdd, *d));
      }
    }

    string hdr = "PERF SUMMARY ";
    for (auto c=perf.begin(); c!=perf.end(); c++) {
      const auto& r = c->second;
      for (auto m=r.begin(); m!=r.end(); m++) {
      
	string hdrx = hdr+m->first+" ["+c->first+"] ";
	size_t j = 0, maxn = c->first=="" ? maxn_overall : maxn_per_class;
	for (auto i=m->second.rbegin(); i!=m->second.rend() && j<maxn;
	     i++, j++) {
	  string mname = m->first;
	  size_t p = mname.find("_");
	  if (p!=string::npos)
	    mname.erase(p);
	  bool is_max_meas = dt_min.find(mname)==dt_min.end();
	  // if (mname=="EER")
	  //   is_max_meas = false;
	  float val = i->first;
	  if (!is_max_meas)
	    val = -val;

	  char valtmp[20];
	  sprintf(valtmp, "%4zd %0.5g", j, val);
	  cout << hdrx << valtmp << " " << i->second << endl;
	}
      }
    }

    if (iset.size()) {
      cout << "LATEX %";
      for (auto i=iset.begin(); i!=iset.end(); i++)
	cout << " " << *i;
      cout << endl;
    }

    return res;
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::ShowExamples(const multimap<float,size_t>& rr, bool rev,
			      size_t n, DataBase *db, const string& s,
			      bool disp) {
    //string msg = "ShowExamples() : ";

    cout << "LATEX \\examplesection{" << s << "}" << endl;
    size_t c = 0;
    auto i = rr.begin();
    auto j = rr.rbegin();
    while (c++<n) {
      if (i==rr.end())
	break;
      if (j==rr.rend())
	break;

      size_t idx = rev ? j->second : i->second;
      float  val = rev ? j->first  : i->first;
      cout << "LATEX \\examplevalue{" << c << "}{"
	   << db->Label(idx) << "}{" << val << "}{}" << endl;

      if (disp) {
	imagedata img = db->ImageData(idx);
	char key = '?';
	cout << ">>> " << s << " " << db->Label(idx) << " " << val << " <<<"
	     << endl;
	imagefile::display(img, &key);
	cout << "KEY " << key << " " << db->Label(idx) << endl;
      }
      
      i++;
      j++;
    }
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseDetectionData(const vector<string>& args) {
    string msg = "AnalyseDetectionData() : ";

    bool use_lscom = true;

    WriteLog("AnalyseDetectionData");

    if (classname!="") {
      vector<string> detections_keep = detections;
      string classname_keep = classname, imagefilename_keep = imagefilename;
      list<string> clist = CheckDB()->SplitClassNames(classname);
      classname = "";
      for (auto ci=clist.begin(); ci!=clist.end(); ci++) {
	string cn = *ci; 

	detections.clear();
	for (auto di=detections_keep.begin();
	     di!=detections_keep.end(); di++) {
	  string s = *di;
	  if (s.find('#')!=string::npos)
	    return ShowError(msg+"'#' found in <"+s+">");
	  s += "#"+cn;
	  detections.push_back(s);
	}
	
	if (imagefilename_keep!="") {
	  if (use_lscom) {
	    string l = DataBase::LscomName(Picsom(), cn, true, lscommap);
	    cn = DataBase::SplitLscomName(l).first;
	  }
	  imagefilename = imagefilename_keep+cn;
	}

	if (AnalyseDetectionData(args).errored())
	  return false;
      }
      detections = detections_keep;
      classname = classname_keep;
      imagefilename = imagefilename_keep;

      return true;
    }

    const ground_truth& restr = QueryRestrictionGT();
    vector<size_t> idxs = restr.indices(1);
    set<size_t> idxset(idxs.begin(), idxs.end());

    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    string mstr;
    list<string> extra;
    AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack", TaskStack());
    query->WriteAnalyseVariablesNew("DetectionData", mstr, gtl, extra);

    bool show_summary = verbose&1, show_hist = verbose&2;
    bool show_max = verbose&4, show_obj = verbose&8, show_all = verbose&16;
    bool png_hist = verbose&32;
    size_t hn = 100, hds = 20, hdp = 50;
    vector<size_t> hvec(hn);

    map<string,ground_truth> nodata, negdata, zerodata, okdata, bigdata;
    map<string,vector<size_t> > hist;

    string detstr = CommaJoin(detections);	

    list<string> bdet = detstr=="" ? CheckDB()->FindAllBinDetectionNames(false)
      : CheckDB()->FindMatchingBinDetections(detstr, false);

    string detstr2 = CommaJoin(bdet);

    map<string,multimap<float,size_t> > max;
    size_t max_n = 20;

    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];

      bool dummy = true;
      map<string,vector<float> > dets
	= CheckDB()->RetrieveDetectionData(idx, detstr2, true, dummy);
      if (show_obj)
	cout << "  #" << idx << " (" << i << "/" << idxs.size() << ") "
	     << dets.size() << " detections" << endl;

      for (auto j=dets.begin(); j!=dets.end(); j++) {
	if (nodata.find(j->first)==nodata.end()) {
	  nodata[j->first] = restr;
	  negdata[j->first] = zerodata[j->first] = okdata[j->first]
	    = bigdata[j->first] = ground_truth(DataBaseSize());
	}

	if (j->second.size()!=1)
	  ShowError("detection dimensionality != 1");

	if (j->second[0]<0)
	  negdata[j->first][idx] = 1;
	else if (j->second[0]==0)
	  zerodata[j->first][idx] = 1;
	else if (j->second[0]<=1) {
	  okdata[j->first][idx] = 1;
	  if (show_hist || png_hist) {
	    size_t bin = (size_t)floor(j->second[0]*hn);
	    if (bin==hn)
	      bin--;
	    if (hist.find(j->first)==hist.end())
	      hist[j->first] = hvec;
	    hist[j->first][bin]++;
	  }

	} else
	  bigdata[j->first][idx] = 1;

	nodata[j->first][idx] = 0;	

	if (show_max) {
	  max[j->first].insert(make_pair(j->second[0], idx));
	}

	if (show_all)
	  cout << "  #" << idx << " (" << i << "/" << idxs.size() << ") "
	       << j->first << " = " << j->second[0] << endl;
      }
    }

    for (auto i=bdet.begin(); i!=bdet.end(); i++) {
      if (show_summary)
	cout << *i << " :"
	     << "	 nodata="   << nodata[*i].number_of_equal(1)
	     << "	 negdata="  << negdata[*i].number_of_equal(1)
	     << "	 zerodata=" << zerodata[*i].number_of_equal(1)
	     << "	 okdata="   << okdata[*i].number_of_equal(1)
	     << "	 bigdata="  << bigdata[*i].number_of_equal(1)
	     << endl;

      if (show_hist || png_hist) {
	size_t max = 0, tot = 0;
	for (auto j=hist[*i].begin(); j!=hist[*i].end(); j++) {
	  tot += *j;
	  if (*j>max)
	    max = *j;
	}
	if (max) {
	  if (show_hist) {
	    for (size_t k=0; k<hds; k++) {
	      size_t t = max*(hds-k-1)/hds;
	      for (auto j=hist[*i].begin(); j!=hist[*i].end(); j++)
		cout << (*j>t ? '*' : ' ');
	      cout << endl;
	    }
	    for (size_t j=0; j<hn; j++)
	      cout << "-";
	    cout << endl << endl;
	  }
	  if (png_hist) {
	    string ifname = "abs-"+*i+"-"+restr.label()+".png";
	    WriteHistogramImage(hist[*i], hdp, false, ifname);
	    ifname = "rel-"+*i+"-"+restr.label()+".png";
	    WriteHistogramImage(hist[*i], hdp, true, ifname);
	  }
	}
      }

      if (show_max) {
	list<string> labset;
	size_t n = 0;
	for (auto j=max[*i].rbegin(); j!=max[*i].rend() && n<max_n;
	      j++, n++) {
	  const string& lab = CheckDB()->Label(j->second);
	  cout << *i << " " << j->first << " #" << j->second << " " << lab
	       << endl;
	  labset.push_back(lab);
	}

	if (imagefilename!="") {
	  string spec = "a185x185";
	  imagedata b(1, 1, 3, imagedata::pixeldata_float);
	  b.set(0, 0, imagecolor<float>("white"));
	  float c = 0.5;
	  imagedata col = CheckDB()->CreateImageCollage(labset, spec, 5,
							200, 200, b, c);
	  string ifname = imagefilename;
	  size_t p = ifname.rfind('.');
	  if (p==string::npos || p+5<ifname.size())
	    ifname += ".png";

	  try {
	    imagefile::write(col, ifname);
	  } catch (const string& e) {
	    return ShowError(msg+"failed to write collage in <"+
			     ifname+"> : "+e);
	  }

	  WriteLog("Wrote image collage in <"+ifname+">");
	}
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::WriteHistogramImage(const vector<size_t>& hist,
				     size_t h, bool scale,
				     const string& ifname) {
    string msg = "WriteHistogramImage() : ";

    size_t w = hist.size(), max = 0, tot = 0;
    for (auto i=hist.begin(); i!=hist.end(); i++) {
      tot += *i;
      if (*i>max)
	max = *i;
    }

    imagedata img(w, h, 1, imagedata::pixeldata_uchar);
    for (size_t k=0; k<h; k++) {
      size_t t = (scale?max:tot)*(h-k-1)/h;
      for (size_t j=0; j<hist.size(); j++)
	img.set(j, k, hist[j]>t ? (unsigned char)0 : (unsigned char)255);
    }

    try {
      imagefile::write(img, ifname);
      WriteLog("Stored histogram in <"+ifname+">");
    } catch (const string& emsg) {
      return ShowError(msg+"failed to write in <"+ifname+"> : "+emsg);
    }
    
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseDetectionStats(const vector<string>& args) {
    string msg = "AnalyseDetectionStats() : ";

    bool use_lscom = true;
    size_t n_show_cond = 20;

    if (detections.size()==0)
      return ShowError(msg+"detections should be set");

    string dfin, dfout;
    if (args.size() && args[0].find("dfin=")==0)
      dfin = args[0].substr(5);
    if (args.size() && args[0].find("dfout=")==0)
      dfout = args[0].substr(6);

    WriteLog("AnalyseDetectionStats dfin=<"+dfin+"> dfout=<"+dfout+">");

    list<string> clist = CheckDB()->SplitClassNames(classname);
    vector<size_t> idxs = QueryRestrictionGT().indices(1);

    map<string,size_t> tf;

    map<size_t,vector<size_t> > per_idx_hits;
    map<size_t,string> cnames;

    for (auto d=detections.begin(); d!=detections.end(); d++) {
      multimap<float,string> res;

      size_t cno = 0;
      for (auto c=clist.begin(); c!=clist.end(); c++, cno++) {
	cnames[cno] = *c;

	vector<float> val;
	simple::StatVar s;
	for (auto i=idxs.begin(); i!=idxs.end(); i++) {
	  string det = *d+"#"+*c;

	  bool dummy = false;
	  map<string,vector<float> > dets
	    = CheckDB()->RetrieveDetectionData(*i, det, true, dummy);

	  if (dets.size()!=1)
	    return ShowError(msg+"idx="+ToStr(*i)+" dets.size()!="
			     +ToStr(dets.size()));
	  if (dets.begin()->second.size()!=1)
	    return ShowError(msg+"idx="+ToStr(*i)
			     +" dets.begin()->secod.size()size()!="
			     +ToStr(dets.begin()->second.size()));
	  float v = dets.begin()->second[0];
	  val.push_back(v);
	  s += v;

	  if (detections.size()==1 && v>0) {
	    tf[*c]++;
	    per_idx_hits[*i].push_back(cno);
	  }
	}
	ostringstream os;
	s.Print(true, os);
	string cname = *c;
	if (use_lscom) {
	  string l = DataBase::LscomName(Picsom(), *c, true, lscommap);
	  cname += " "+DataBase::SplitLscomName(l).first;
	}
	
	ostringstream ress;
	ress << cname << " " << *d << " " << os.str() << endl;
	float m = s.Mean();
	float sum1 = 0, sum0 = 0; // Durbin-Watson statistic
	for (size_t j=0; j+1<val.size(); j++) {
	  sum1 += (val[j]-val[j+1])*(val[j]-val[j+1]);
	  sum0 += (val[j]-m)*(val[j]-m);
	}
	ress << " dw = " << sum1/sum0 << " acc =";
	vector<float> corr;
	for (size_t r=0; r<15; r++) {
	  float sum = 0;
	  for (size_t j=0; j+r<val.size(); j++)
	    sum += (val[j]-m)*(val[j+r]-m);
	  sum /= val.size()-r;
	  corr.push_back(sum);
	  ress << " " << corr[r]/corr[0];
	}
	ress << endl;
	res.insert(make_pair(m, ress.str()));
      }
      
      for (auto i=res.rbegin(); i!=res.rend(); i++)
	cout << i->second;
    }

    multimap<size_t,string> tfo;
    for (auto i=tf.begin(); i!=tf.end(); i++)
      tfo.insert(make_pair(i->second, i->first));

    map<string,double> df;
    if (dfin!="") {
      string s = FileToString(dfin);
      vector<string> vs = SplitInSomething("\n", false, s);
      for (size_t i=0; i<vs.size(); i++)
	if (vs[i]!="") {
	  size_t p = vs[i].find(" ");
	  df[vs[i].substr(0, p)] = atof(vs[i].substr(p+1).c_str());
	}
      WriteLog("Read in "+ToStr(df.size())+" document frequencies from <"
	       +dfin+">");
    }

    multimap<double,string> tfidf;

    ofstream dfoutof;
    if (dfout!="")
      dfoutof.open(dfout);

    cout << endl << "samples: " << idxs.size() << endl;
    cout << "max freq:" << endl;
    size_t maxj = 500, j = 0;
    for (auto i=tfo.rbegin(); i!=tfo.rend(); i++, j++) {
      if (j<maxj) {
	string cname = i->second;
	if (use_lscom) {
	  string l = DataBase::LscomName(Picsom(), cname, true, lscommap);
	  cname += " "+DataBase::SplitLscomName(l).first;
	}
	cout << j << " " << cname << " " << i->first << endl;
      }
      dfoutof << i->second << " " << double(i->first)/idxs.size() << endl;

      if (df.find(i->second)!=df.end()) {
	double v = i->first*log2(df[i->second]);
	cout << "  " << i->first << " " << df[i->second]
	     << " " << log2(df[i->second]) << " = " << v << endl;
	  
	tfidf.insert(make_pair(-v, i->second));
      }
    }

    if (dfout!="") {
      if (!dfoutof)
	return ShowError(msg+"failed to write in <"+dfout+">");
      else
	WriteLog("Saved "+ToStr(tfo.size())+" document frequencies in <"+
		 dfout+">");
    }

    if (tfidf.size()) {
      cout << endl << "max tfidf:" << endl;
      j = 0;
      for (auto i=tfidf.rbegin(); i!=tfidf.rend() && j<maxj; i++, j++) {
	string cname = i->second;
	if (use_lscom) {
	  string l = DataBase::LscomName(Picsom(), cname, true, lscommap);
	  cname += " "+DataBase::SplitLscomName(l).first;
	}
	cout << j << " " << cname << " " << i->first << endl;
      }
    }

    cox::matrix<size_t> union2(clist.size(), clist.size());
    cox::matrix<size_t> coocc_pos(clist.size(), clist.size());
    cox::matrix<size_t> coocc_neg(clist.size(), clist.size());
    for (auto i=per_idx_hits.begin(); i!=per_idx_hits.end(); i++) {
      const vector<size_t>& c = i->second;
      set<size_t> sc(c.begin(), c.end());
      set<pair<size_t,size_t> > pp;
      for (size_t a=0; a<c.size(); a++) {
	for (size_t b=0; b<c.size(); b++)
	  coocc_pos(c[a], c[b])++;
	for (size_t b=0; b<clist.size(); b++)
	  if (sc.find(b)==sc.end())
	    coocc_neg(c[a], b)++;
	for (size_t b=0; b<clist.size(); b++)
	  if (pp.find(make_pair(c[a], b))==pp.end()) {
	    union2(c[a], b)++;
	    if (c[a]!=b)
	      union2(b, c[a])++;
	    pp.insert(make_pair(c[a], b));
	    pp.insert(make_pair(b, c[a]));
	  }
      }
    }

    multimap<float,pair<size_t,size_t> > ord_pos, ord_neg, intun;
    cox::matrix<float> cond_pos(clist.size(), clist.size());
    cox::matrix<float> cond_neg(clist.size(), clist.size());
    for (size_t a=0; a<clist.size(); a++)
      for (size_t b=0; b<clist.size(); b++)
	if (coocc_pos(b, b) && coocc_pos(a, a)) {
	  cond_pos(a, b) = float(coocc_pos(a, b))/coocc_pos(b, b);
	  cond_neg(a, b) = float(coocc_neg(a, b))/(idxs.size()-coocc_pos(b, b));
	  if (a!=b) {
	    ord_pos.insert(make_pair(cond_pos(a, b), make_pair(a, b)));
	    ord_neg.insert(make_pair(cond_neg(a, b), make_pair(a, b)));
	    if (a<b) {
	      float iu = float(coocc_pos(a, b))/union2(a, b);
	      intun.insert(make_pair(iu, make_pair(a, b)));
	    }
	  }
	}

    cout << endl << "max P(a | b) :" << endl;
    size_t n = 0, ni = 0;
    for (auto i=ord_pos.rbegin(); i!=ord_pos.rend() && n<n_show_cond;
	 i++, ni++) {
      size_t a = i->second.first, b = i->second.second;
      string cna = cnames[a], cnb = cnames[b];
      if (use_lscom) {
	string l = DataBase::LscomName(Picsom(), cna, true, lscommap);
	cna += " "+DataBase::SplitLscomName(l).first;
	l = DataBase::LscomName(Picsom(), cnb, true, lscommap);
	cnb += " "+DataBase::SplitLscomName(l).first;
      }
      cout << ni << " P(" << cna << " | " << cnb << ") = " << i->first
	   << " [ " << coocc_pos(a, b) << " " << coocc_pos(a, a) << " "
	   << coocc_pos(b, b) << " ]"
	   << endl;
      if (i->first<1)
	n++;
    }

    cout << endl << "min P(a | b) :" << endl;
    n = ni = 0;
    for (auto i=ord_pos.begin(); i!=ord_pos.end() && n<n_show_cond; i++, ni++) {
      size_t a = i->second.first, b = i->second.second;
      string cna = cnames[a], cnb = cnames[b];
      if (use_lscom) {
	string l = DataBase::LscomName(Picsom(), cna, true, lscommap);
	cna += " "+DataBase::SplitLscomName(l).first;
	l = DataBase::LscomName(Picsom(), cnb, true, lscommap);
	cnb += " "+DataBase::SplitLscomName(l).first;
      }
      cout << ni << " P(" << cna << " | " << cnb << ") = " << i->first 
	   << " [ " << coocc_pos(a, b) << " " << coocc_pos(a, a) << " "
	   << coocc_pos(b, b) << " ]"
	   << endl;
      if (i->first>0)
	n++;
    }

    cout << endl << "max P(a | NOT b) :" << endl;
    n = 0, ni = 0;
    for (auto i=ord_neg.rbegin(); i!=ord_neg.rend() && n<n_show_cond;
	 i++, ni++) {
      size_t a = i->second.first, b = i->second.second;
      string cna = cnames[a], cnb = cnames[b];
      if (use_lscom) {
	string l = DataBase::LscomName(Picsom(), cna, true, lscommap);
	cna += " "+DataBase::SplitLscomName(l).first;
	l = DataBase::LscomName(Picsom(), cnb, true, lscommap);
	cnb += " "+DataBase::SplitLscomName(l).first;
      }
      cout << ni << " P(" << cna << " | NOT " << cnb << ") = " << i->first
	   << " [ " << coocc_neg(a, b) << " " << coocc_pos(a, a) << " "
	   << (idxs.size()-coocc_pos(b, b)) << " ]"
	   << endl;
      if (i->first<1)
	n++;
    }

    cout << endl << "min P(a| NOT b) :" << endl;
    n = ni = 0;
    for (auto i=ord_neg.begin(); i!=ord_neg.end() && n<n_show_cond; i++, ni++) {
      size_t a = i->second.first, b = i->second.second;
      string cna = cnames[a], cnb = cnames[b];
      if (use_lscom) {
	string l = DataBase::LscomName(Picsom(), cna, true, lscommap);
	cna += " "+DataBase::SplitLscomName(l).first;
	l = DataBase::LscomName(Picsom(), cnb, true, lscommap);
	cnb += " "+DataBase::SplitLscomName(l).first;
      }
      cout << ni << " P(" << cna << " | NOT " << cnb << ") = " << i->first 
	   << " [ " << coocc_neg(a, b) << " " << coocc_pos(a, a) << " "
	   << (idxs.size()-coocc_pos(b, b)) << " ]"
	   << endl;
      if (i->first>0)
	n++;
    }

    cout << endl << "max |a INTERSECT b|/|a UNION b| :" << endl;
    n = 0, ni = 0;
    for (auto i=intun.rbegin(); i!=intun.rend() && n<n_show_cond;
	 i++, ni++) {
      size_t a = i->second.first, b = i->second.second;
      string cna = cnames[a], cnb = cnames[b];
      if (use_lscom) {
	string l = DataBase::LscomName(Picsom(), cna, true, lscommap);
	cna += " "+DataBase::SplitLscomName(l).first;
	l = DataBase::LscomName(Picsom(), cnb, true, lscommap);
	cnb += " "+DataBase::SplitLscomName(l).first;
      }
      cout << ni << " |INT/UNION|(" << cna << " " << cnb << ") = " << i->first
	   << " [ " << coocc_pos(a, a) << " " << coocc_pos(b, b) << " "
	   << coocc_pos(a, b) << " " << union2(a, b)  << " ]"
	   << endl;
      if (i->first<1)
	n++;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<string> Analysis::ExpandDetectionsWithClasses(const vector<string>& d,
						       const string& c) {

    bool found = false;
    vector<string> e;
    for (auto dp=d.begin(); dp!=d.end(); dp++) {
      string dd = *dp;
      size_t p = dd.find("%C");
      if (p!=string::npos) {
	found = true;
	dd.replace(p, 2, c);
      }
      e.push_back(dd);
    }
	
    return ExpandDetectionsWithClasses(d, CheckDB()->SplitClassNames(c),
				       !found);
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<string> Analysis::ExpandDetectionsWithClasses(const vector<string>& d,
						       const list<string>& c,
						       bool angry) {
    string msg = "Analysis::ExpandDetectionsWithClasses() : ";

    bool has_class = c.size()>1 || (c.size() && *c.begin()!="");

    vector<string> ret, empty;
    for (auto dp=d.begin(); dp!=d.end(); dp++) {
      string dd = *dp;
      size_t p = dd.find("%c");
      if (p==string::npos && has_class && angry) {
	ShowError(msg+"classname specified, "
		  "but detections doesn't contain '%c'");
	return empty;
      }
      if (p!=string::npos && !has_class) {
	ShowError(msg+"classname not specified, "
		  "but detections contains '%c'");
	return empty;
      }
      if (p!=string::npos && has_class) {
	for (auto i=c.begin(); i!=c.end(); i++) {
	  string t = dd;
	  t.replace(p, 2, *i);
	  ret.push_back(t);
	}
	continue;
      }
      ret.push_back(dd);
    }

    return ret;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseDetectionsToFeatures(const vector<string>& args) {
    string msg = "Analysis::AnalyseDetectionsToFeatures() : ";

    WriteLog("AnalyseDetectionsToFeatures");

    if (detections.size()==0)
      return ShowError(msg+"detections should be specified");

    if (args.size()!=1)
      return ShowError(msg+"exactly one argument, "
		       "feature file name should be specified");

    vector<string> detectionx = ExpandDetectionsWithClasses(detections,
							    classname);
    if (detectionx.size()==0)
      return ShowError(msg+"ExpandDetectionsWithClasses() failed");

    const ground_truth& restr = QueryRestrictionGT();
    vector<size_t> idxs = restr.indices(1);
    set<size_t> idxset(idxs.begin(), idxs.end());

    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", restr);
    string mstr;
    list<string> extra;
    AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
    AddExtraVariableInfo(extra, "taskstack", TaskStack());
    query->WriteAnalyseVariablesNew("DetectionsToFeatures", mstr, gtl, extra);

    string detstr = CommaJoin(detectionx);	
    list<string> bdet = CheckDB()->FindMatchingBinDetections(detstr, false);
    if (bdet.size()==0)
      return ShowError(msg+"detstr=<"+detstr+"> evaluated to empty list");

    string detstr2 = CommaJoin(bdet);

    bin_data feat_out(args[0], true,
		      bin_data::header::format_float, 0, bdet.size());
    feat_out.resize(CheckDB()->Size());

    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];

      bool dummy = true;
      map<string,vector<float> > dets =
	CheckDB()->RetrieveDetectionData(idx, detstr2, true, dummy);
      if (verbose==3)
	cout << "  #" << idx << " (" << i << "/" << idxs.size() << ") "
	     << dets.size() << " detections" << endl;

      vector<float> v(dets.size());
      auto vi = v.begin();

      for (auto j=dets.begin(); j!=dets.end(); j++, vi++) {
	if (j->second.size()!=1)
	  ShowError(msg+"detection dimensionality != 1");

	if (verbose>3)
	  cout << "  #" << idx << " (" << i << "/" << idxs.size() << ") "
	       << j->first << " = " << j->second[0] << endl;

	*vi = j->second[0];
      }

      feat_out.set_float(idx, v);
    }

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseSiblings(const vector<string>&) {
  string err = "Analysis::AnalyseSiblings() : ";

  if (!resultcount)
    return ShowError(err+"resultcount should be set");

  WriteLog("AnalyseSiblings");
  bool debug = verbose>1;

  string mstr;
  ground_truth_list gtl;
  list<string> extra;
  AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
  AddExtraVariableInfo(extra, "taskstack", TaskStack());
  query->WriteAnalyseVariablesNew("Siblings", mstr, gtl, extra);

  DataBase *db = CheckDB();

  ReadFiles();

  vector<int> parent;
  for (size_t i=0; i<db->Size(); i++) {
    if (verbose>2)
      cout << db->ObjectDump(i) << " restriction=" << db->OkWithRestriction(i)
           << endl;

    if (db->FindObject(i)->children.size()==2 &&
        db->OkWithRestriction(i))
      parent.push_back(i);
  }

  map<string,map<float,float> > feat_dist, feat_dist_cum;

  for (size_t m=0; m<Nindices(); m++) {
    TSSOM& ts = TsSom(m);
    const string& fname = ts.Name();
    int l = ts.Nlevels()-1;
    const TreeSOM& som = Map(m, l);
    const IntVector& div = ts.Division(l, 0);

    map<float,float>& dist = feat_dist[fname];
    float sum = 0.0;

    for (vector<int>::const_iterator p=parent.begin(); p!=parent.end(); p++) {
      const object_info *oi = db->FindObject(*p);
      if (debug)
        cout << db->ObjectDump(*p) << " -> "
             << db->ObjectDump(oi->children[0]) << " + "
             << db->ObjectDump(oi->children[1]) << endl;

      int idx0 = oi->children[0], idx1 = oi->children[1];
      int u0 = div[idx0], u1 = div[idx1];
      IntPoint p0 = som.ToPoint(u0), p1 = som.ToPoint(u1);
      float d = sqrt(float((p0.X()-p1.X())*(p0.X()-p1.X())+
                           (p0.Y()-p1.Y())*(p0.Y()-p1.Y())));

      dist[d] += 1.0;
      sum += 1.0;

      if (debug)
        cout << "  " << idx0 << " " << u0 << " (" << p0 << ")"
             << "  " << idx1 << " " << u1 << " (" << p1 << ")"
             << "  d=" << d << "  dist[d]=" << dist[d] << endl;
    }

    map<float,float>& dist_cum = feat_dist_cum[fname];
    SiblingBMUcommon(dist, sum, dist_cum, fname);
  }

  multimap<float,int> diff;

  for (vector<int>::const_iterator p=parent.begin(); p!=parent.end(); p++) {
    const object_info *oi = db->FindObject(*p);

    cout << db->ObjectDump(*p);
    float sum = 0.0;

    for (size_t m=0; m<Nindices(); m++) {
      TSSOM& ts = TsSom(m);
      const string& fname = ts.Name();
      int l = ts.Nlevels()-1;
      const TreeSOM& som = Map(m, l);
      const IntVector& div = ts.Division(l, 0);

      int u0 = div[oi->children[0]], u1 = div[oi->children[1]];
      IntPoint p0 = som.ToPoint(u0), p1 = som.ToPoint(u1);
      float d = sqrt(float((p0.X()-p1.X())*(p0.X()-p1.X())+
                           (p0.Y()-p1.Y())*(p0.Y()-p1.Y())));

      const map<float,float>& cum = feat_dist_cum[fname];
      
      float v = 0.0;
      for (map<float,float>::const_iterator i=cum.begin(); i!=cum.end(); i++)
        if (i->first>=d)
          break;
        else
          v = i->second;

      sum += v;
      cout << " " << fname << "=" << v;
    }
    cout << " sum=" << sum << endl;

    diff.insert(pair<float,int>(sum, oi->index));
  }
  
  objectlist_t bestidxval;
  list<pair<size_t,double> > out;
  const size_t out_size = (size_t)resultcount;

  for (multimap<float,int>::reverse_iterator i=diff.rbegin();
       i!=diff.rend(); i++) {

    cout << "TOTAL " << db->ObjectDump(i->second) << " "
         << db->OkWithRestriction(i->second)
         << " " << i->first << endl;

    if (!db->OkWithRestriction(i->second))
      continue;
    
    // obs: using 0.0 as value!!
    bestidxval.push_back(pair<size_t,double>(i->second,0.0));

    if (out.size()<out_size)
      out.push_back(make_pair(i->second,i->first));
  }

  if (query->HasViewClass()) {
    ground_truth view = GroundTruthExpression(query->ViewClass(),
                                              query->Target(),
                                              -1, expand);
    string mmstr;
    return AnalyseResultsCommon(bestidxval, view, mmstr);
  }

  bool ok = true;

  if (resultname!="") {
    bool sval = false, app = false;
    string txt = "Result of AnalyseSiblings() in descending order of distance";
    string fn = ExpandedResultName();
    ok = WriteOrderedClassFile(out, fn, txt, sval, app);
  }

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseBMUs(const vector<string>&) {
  string err = "Analysis::AnalyseBMUs() : ";

  WriteLog("AnalyseBMUs");
  bool debug = verbose>1;

  string mstr;
  ground_truth_list gtl;
  list<string> extra;
  AddExtraVariableInfo(extra, "depth",     ToStr(Depth()));
  AddExtraVariableInfo(extra, "taskstack", TaskStack());
  query->WriteAnalyseVariablesNew("BMUs", mstr, gtl, extra);

  DataBase *db = CheckDB();

  ReadFiles();

  map<string,map<float,float> > feat_dist, feat_dist_cum;

  bool ok = true;
  for (size_t m=0; m<Nindices(); m++) {
    TSSOM& ts = TsSom(m);
    int l = ts.Nlevels()-1;
    const string& fname = ts.Name();

    if (ts.DivisionDepth(l)<2) {
      ok = ShowError(err+"["+fname+"] divisiondepth<2");
      continue;
    }

    const TreeSOM& som = Map(m, l);

    map<float,float>& dist = feat_dist[fname];
    float sum = 0.0;

    target_type tt = ts.FeatureTarget();
    int o = 0; 
    string cname = classname!="" ? classname : "*"; 
    ground_truth cls = GroundTruthExpression(cname, tt, o, expand);

    const IntVector& divvec0 = ts.Division(l, 0);
    const IntVector& divvec1 = ts.Division(l, 1);

    for (size_t i=0; i<cls.size(); i++) {
      if (cls[i]!=1)
        continue;

      int u0 = divvec0[i], u1 = divvec1[i];
      if (u0!=-1 && u1!=-1) {
        IntPoint p0 = som.ToPoint(u0), p1 = som.ToPoint(u1);
        float d = sqrt(float((p0.X()-p1.X())*(p0.X()-p1.X())+
                             (p0.Y()-p1.Y())*(p0.Y()-p1.Y())));
        dist[d] += 1.0;
        sum += 1.0;

        if (debug)
          cout << db->ObjectDump(i)
               << "  " << u0 << " (" << p0 << ")"
               << "  " << u1 << " (" << p1 << ")"
               << "  d=" << d << "  dist[d]=" << dist[d]
               << "  sum=" << sum << endl;
      }
   }

    map<float,float>& dist_cum = feat_dist_cum[fname];
    SiblingBMUcommon(dist, sum, dist_cum, fname);

    size_t i = 0, imax = 5;
    for (map<float,float>::const_iterator di=dist.begin(), ci=dist_cum.begin();
         di!=dist.end() && i<imax; di++, ci++, i++)
      cout << fname << " d=" << di->first << " n=" << sum*di->second
           << " frac=" << di->second << " cum=" << ci->second << endl;
  }

  return ok;
}

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::SiblingBMUcommon(map<float,float>& dist, float sum,
                                  map<float,float>& dist_cum,
                                  const string& fname) {
    vector<float> d, h, c;

    float cum = 0.0;
    for (map<float,float>::iterator i=dist.begin(); i!=dist.end(); i++) {
      i->second /= sum;
      cum += i->second;
      dist_cum[i->first] = cum;
      d.push_back(i->first);
      h.push_back(i->second);
      c.push_back(cum);
    }

    map<float,float>::iterator j = dist_cum.begin();
    for (map<float,float>::iterator i=dist.begin(); i!=dist.end(); i++, j++)
      cout << fname << "  "
           << i->first << " : " << i->second << " " << j->second
           << endl;

    if (MatlabName()!="") {
      string n(ExpandedMatlabName(fname));
      ofstream matlabos((n+".m").c_str());
      write_matlab(d, matlabos, n+"_d");
      write_matlab(h, matlabos, n+"_h");
      write_matlab(c, matlabos, n+"_c");

      WriteLog("Wrote results in <", n, ".m>");
    }

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseValue(const vector<string>&) {
  if (value=="")
    return ShowError("value not specified");

  DataBase *db = CheckDB();

  string valuefile = value;
  int cmpnt = 0;
  size_t p = valuefile.find('[');
  if (p!=string::npos) {
    string tmp = valuefile.substr(p+1);
    valuefile.erase(p);
    cmpnt = atoi(tmp.c_str());
  }

  string dirstr = db->ExpandPath("features");
  TSSOM feat(db, valuefile, dirstr);

  feat.ReadDataFile();
  FloatVectorSet& datset = feat.Data();

  ReadFiles();

  for (size_t m=0; m<Nindices(); m++) {
    string lbl=DataBaseName()+":"+IndexFullName(m)+":"+classname+":"+value+":";
    TsSom(m).ReadMapFile();

    target_type tt = TsSom(m).FeatureTarget();
    int o = 0;
    ground_truth cls = GroundTruthExpression(classname, tt, o, expand);

    FloatVector v(DataBaseSize());
    ground_truth is_set(DataBaseSize());

    for (int i=0; i<datset.Nitems(); i++) {
      cout << i << " " << datset[i][cmpnt] << " " << datset[i].Label() << endl;
      ground_truth ss = GroundTruthExpression(datset[i].Label(), tt, o,expand);
      for (int j=0; j<ss.Length(); j++)
        if (ss[j]==1 && cls[j]==1) {
          if (is_set[j]==1)
            return ShowError("AnalyseValue() failed A");
          else {
            is_set[j] = 1;
            v[j] = datset[i][cmpnt];
          }
	}
    }

    cout << endl;
    db->GroundTruthSummary(cls);
    cout << endl;

    for (size_t l=0; l<TsSom(m).Nlevels(); l++) {
      if (level>=0 && level!=int(l))
        continue;

      const SOM& som = Map(m, l);
      int cols = som.Width(), rows = som.Height();
      cout << endl << IndexFullName(m) << "[" << l << "] : "
           << cols << "x" << rows << endl;
      
      IntVector& dv = TsSom(m).Division(l, 0);

      typedef pair<pair<int,int>,float> spset_e;
      sparse_pointset_t vset;

      for (int i=0; i<v.Length(); i++)
        if (is_set[i]) {
          if (!dv.IndexOK(i))
            return ShowError("AnalyseValue() failed B");

          int idx = dv[i];
          if (idx==-1) // why these happen in grain::texture/colm ???
            continue;

          if (!som.PlanarIndexOK(idx))
            return ShowError("AnalyseValue() failed C : i=", ToStr(i),
                             " idx=", ToStr(idx));

          IntPoint pxy = som.ToPoint(idx);
          pair<int,int> xy(pxy.Y(), pxy.X());
          vset.insert(spset_e(xy, v[i]));
        }

      simple::FloatMatrix stddev;
      simple::FloatMatrix fmtrx = FillSparseValueMatrix(rows, cols, vset, stddev);

      simple::FloatMatrix fmtrxdisp = fmtrx, stddevdisp = stddev;
      fmtrxdisp.Add(-fmtrxdisp.Sum()/fmtrxdisp.Size());

      imagedata fmtrximg  = query->BlueWhiteRedMap(fmtrxdisp);
      imagedata stddevimg = query->BlueWhiteRedMap(stddev);

      imagefile::displaysettings setting;
      setting.fork = true;
      setting.title = lbl+ToStr(l)+":value";
      imagefile::display(fmtrximg, setting);

      setting.title = lbl+ToStr(l)+":stddev";
      imagefile::display(stddevimg, setting);
    }
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseEigDim(const vector<string>&) {
  int imax = 10;

  ReadFiles();

  for (size_t m=0; m<Nindices(); m++) {
    TSSOM& tssom = TsSom(m);
    cout << "Feature : " << tssom.Name() << endl;

    tssom.ReadDataFile();
    FloatVectorSet& data = tssom.Data();
    simple::FloatMatrix cov = data.AutoCov();
    FloatVector eval;
    cov.EigenVectors(&eval, 0);

    float sum = 0, dsum = 0, v0 = eval.Length() ? eval[0] : 1;

    for (int i=0; i<eval.Length(); i++) {
      float r = eval[i]/v0;
      float s = sqrt(r);
      dsum += r;
      sum  += s;

      if (i<imax || i==eval.Length()-1)
        cout << i << " : " << eval[i] << " -> " << r << " -> " << s
             << " sum=" << sum << " dsum=" << dsum << endl;
    }
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

simple::FloatMatrix Analysis::FillSparseValueMatrix(int rows, int cols, const
                                                    sparse_pointset_t& vl,
                                                    simple::FloatMatrix& stddev) {
  simple::FloatMatrix m(rows, cols);
  stddev.Size(m);

  int minn = 5;
  int minr = 1;
  
  int maxd = rows+cols-2;

  for (int x=0; x<cols; x++)
    for (int y=0; y<rows; y++) {
      float sum = 0, sum2 = 0;
      int nv = 0;

      for (int d=0; d<maxd; d++) {
        int n = d ? 4*d : 1;
        for (int i=0; i<n; i++) {
          int dx = 0, dy = 0;
          if (d) {
            dx = -d+abs(i-2*d);
            dy = -d+abs((i+d)%n-2*d);
          }
          // cout << d << " " << i << " " << dx << " " << dy << endl;
          if (m.IndexOK(x+dx, y+dy)) {
            pair<int,int> p(x+dx, y+dy);
            sparse_pointset_t::const_iterator a = vl.lower_bound(p);
            sparse_pointset_t::const_iterator b = vl.upper_bound(p);
            while (a!=b) {
              sum  += a->second;
              sum2 += a->second*a->second;
              nv++;
              a++;
            }
          }
        }
        //cout << "x=" << x << " y=" << y << " d=" << d << " nv=" << nv <<endl;

        if (nv>=minn && d>=minr)
          break;
      }
      
      m.Set(y, x, 0);
      stddev.Set(y, x, MAXFLOAT);
      
      if (nv>0) {
        float avg = sum/nv;
        m.Set(y, x, avg);
        
        if (nv>1) {
          float var = (sum2-sum*avg)/(nv-1);
          stddev.Set(y, x, var>0 ? sqrt(var) : 0);
        }
      }
    }

  return m;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseFocus(const vector<string>& arg) {
  bool use_tree = false;
  for (size_t i=0; i<arg.size(); i++)
    if (arg[i]=="(tree)")
      use_tree = true;

  string msg = "AnalyseFocus("+string(use_tree?"TREE":"")+") : ";

  const string& view_class = query->ViewClassOrPositive();
  if (view_class=="")
    return ShowError(msg+"viewclass or positive has to be set");

  target_type qt = query->Target();
  if (qt!=target_segment)
    return ShowError(msg+"now requires target=segment");

  if (segmentspec=="")
    return ShowError(msg+"segmentspec has to be set");

  target_type tx = qt; // target_type(target_image+target_segment);
  int oo = -1;

  DataBase *db = CheckDB();

  ground_truth posi = GroundTruthExpression(query->Positive(), tx, oo,
                                            expand);
  ground_truth nega = GroundTruthExpression(query->Negative(), tx, oo,
                                            expand);

  if (posi.positives()==0 && nega.positives()==0 && tx!=target_image) {
    target_type txi = target_image;
    posi = GroundTruthExpression(query->Positive(), txi, oo, expand);
    nega = GroundTruthExpression(query->Negative(), txi, oo, expand);
  }

  ground_truth view = GroundTruthExpression(view_class, tx, oo, expand);

  bool gt_error = posi.positives()==0;

  if (verbose>4 || gt_error) {
    cout << "positive  ";
    db->GroundTruthSummary(posi);
    cout << "negative  ";
    db->GroundTruthSummary(nega);
    cout << "viewclass ";
    db->GroundTruthSummary(view);
  }

  if (gt_error)
    return ShowError(msg+"no positives found");

  const xymap_t& xymap = db->XYmap(view_class);
  if (xymap.empty())
    return ShowError(msg+"xymap for <", view_class, "> empty");

  // query->MarkAsSeenNoAspects(&posi, &nega, NULL);
  query->MarkAsSeenEmptyAspect(&posi, &nega, NULL);

  ReadFiles(true);
  query->PerMapObjects(1);
  query->MaxQuestions(1);
  query->CanShowSeen(true);

  string logstr = "\n";
  query->WriteAnalyseVariablesOld("Focus"+string(use_tree?"(TREE)":""),
                                  -1, &posi, &view, 0, false, logstr);
  query->DoubleLog(logstr, "segments=", ToStr(segments));

  for (size_t p; (p=logstr.find("\n%"))!=string::npos;)
    logstr.replace(p, 2, "\n#");

  CbirStages();

  Query::picsom_bottom_score_options_t opt;
  opt.add = true;

  string segm = segmentspec;

  if (verbose>3)
    Query::DebugSelective(true);

  int t_pos = 0, f_pos = 0, t_neg = 0, f_neg = 0;

  for (int i=0; i<view.Length(); i++) {
    const object_info *o = db->FindObject(i);

    if (PicSOM::TargetTypeFileMasked(o->type)!=target_image) {
      if (verbose>4)
        cout << "not image: i=" << i << " " << db->ObjectDump(i) << endl;
      continue;
    }

    const vector<int>& child = o->children;    

    if (child.empty()) {
      ShowError("Empty child list for ",  db->ObjectDump(i));
      continue;
    }

    bool found = false;
    for (size_t j=0; !found && j<child.size(); j++)
      if (view[child[j]]==1)
        found = true;

    if (!found) {
      if (verbose>4)
        cout << "not in " << view.Label() << ": i=" << i
             << " " << db->ObjectDump(i) << endl;
      continue;
    }

    xymap_t::const_iterator xyi = xymap.find(i);
    if (xyi==xymap.end()) {
      ShowError("No xy for ", db->ObjectDump(i), " in ", view_class);
      continue;
    }

    const xymap_ve& xyv = xyi->second;

    if (verbose>2) {
      cout << db->ObjectDump(i); 
      for (xymap_ve::const_iterator vi=xyv.begin(); vi!=xyv.end(); vi++)
        cout << " " << vi->first << "," << vi->second;
      cout << endl;
    }

    string segmfname = db->SolveObjectPath(o->label, "segments", segm,
                                           true, NULL);
    if (segmfname!="")
      segmfname += ".seg";

    segmentfile segdata("", segmfname);
    set<int> idxset;

    if (verbose>1)
      cout << "*** " << segmfname << " :" << endl;

    for (size_t si=0; si<xyv.size(); si++) {
      int x = xyv[si].first, y = xyv[si].second, seg = -1;
      segdata.get_pixel_segment(0, x, y, seg);
      /// obs! that returns only a scalar though it should be a vector

      string slabel = segm+":"+Label(i)+"_"+ToStr(seg);
      int sidx = LabelIndex(slabel);

      bool in_view = view[sidx]==1;
      if (verbose>1)
        cout << "***   " << x << "," << y << " -> " << seg
             << " " << slabel << " #" << sidx
             << (in_view?" IS":" is NOT") << " in " << view.Label() << endl;

      if (in_view)
        idxset.insert(seg);
    }

    multimap<float,int> validx;

    float v_min = numeric_limits<float>::max(), v_max = -v_min;
    for (size_t j=0; j<child.size(); j++) {
      if (view[child[j]]!=1)
        continue;
      
      float v = query->PicSOMBottomScore(child[j], opt, NULL);

      if (verbose>2)
        cout << "i=" << i << " j=" << j << " " 
             << db->ObjectDump(child[j]) << "  v=" << v << endl;

      if (v>v_max)
        v_max = v;
      if (v<v_min)
        v_min = v;
      
      validx.insert(make_pair(v, child[j]));
    }
        
    if (verbose>1) {
      cout << "*** " << db->ObjectDump(i);
      if (validx.size())
        cout << " v_min=" << v_min << " v_max=" << v_max;
      cout << " :" << endl;
    }

    if (v_min==v_max && validx.size()>1)
      WarnOnce(msg+"v_min==v_max may lead to bizarre results");

    int nsegm = 0, npos = 0;
    for (multimap<float,int>::reverse_iterator mi=validx.rbegin();
         mi!=validx.rend(); mi++) {
      const string& ml = Label(mi->second);
      if (verbose>1)
        cout << "   " << ml << "=" << mi->first;

      if (!segments || nsegm<segments) {
        size_t upos = ml.find('_');
        if (upos==string::npos) {
          ShowError("No _ in <", ml, ">");
          continue;
        }
        string segmstr = ml.substr(upos+1);
        vector<string> segmstrv = SplitInSomething("+", false, segmstr);
        if (!use_tree && segmstrv.size()>1) {
          if (verbose>1)
            cout << " skipping hierarchical object" << endl;
          continue;
        }

        if (verbose>1)
          cout << " [";
        bool hit = false;
        for (size_t k=0; k<segmstrv.size(); k++) {
          int segidx = atoi(segmstrv[k].c_str());
          hit = hit || idxset.count(segidx);
          if (verbose>1)
            cout << (k?"+":"") << segidx;
          if (!use_tree)
            idxset.erase(segidx);
        }
        if (verbose>1)
          cout << "]->" << hit; 

        if (hit)
          t_pos++;
        else
          f_pos++;

        if (hit) {
          cout << "  HIT ";
          if (verbose<=1)
            cout << "in " << Label(mi->second) << endl;
        }

        npos++;

        logstr += ml + "\n";
      }

      nsegm++;
      if (verbose>1) {
        if (segments && nsegm==segments)
          cout << " ||";
        cout << endl;
      }
    }

    if (!use_tree) {
      int nneg = nsegm-npos, lpos = idxset.size();
      if (verbose>1)
        cout << "   nsegm=" << nsegm << " npos=" << npos
             << " nneg=" << nneg << " lpos=" << lpos
             << endl;

      if (nneg<0)
        ShowError("nneg = nsegm-npos = "+ToStr(nsegm)+"-"+ToStr(npos)+" = "
                  +ToStr(nneg)+ " < 0 !!!");
    
      if (nneg-lpos<0)
        ShowError("nneg-lpos = "+ToStr(nneg)+"-"+ToStr(lpos)+" = "
                  +ToStr(nneg-lpos)+ " < 0 !!!");
    
      f_neg += lpos;
      t_neg += nneg-lpos;
    }
  }
  
  if (!use_tree) {
    stringstream strtmp;
    strtmp << "t_pos=" << t_pos << " f_pos=" << f_pos
           << " t_neg=" << t_neg << " f_neg=" << f_neg
           << " all_pos=" << t_pos+f_pos << " all_neg=" << t_neg+f_neg
           << " t_all=" << t_pos+t_neg << " f_all=" << f_pos+f_neg
           << " POS=" << t_pos+f_neg << " NEG=" << t_neg+f_pos
           << " ALL=" << t_pos+f_neg+t_neg+f_pos;

    if (verbose)
      cout << endl << strtmp.str() << endl << endl;

    logstr += "\n# "+strtmp.str()+"\n";
  }

  if (classname!="") {
    string ctmp = classname, nseg = segments ? ToStr(segments) : "ALL";
    size_t p = ctmp.find("%n");
    if (p!=string::npos)
      ctmp.replace(p, 2, nseg);
    ofstream out(ctmp.c_str());
    out << logstr << endl;
    WriteLog("Wrote <", ctmp, ">");
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseViewXY(const vector<string>&) {
  using namespace picsom;

  DataBase *db = CheckDB();

  target_type tx = target_image;
  int o = -1;
  ground_truth cls = GroundTruthExpression(classname, tx, o, expand);
  if (verbose>4) {
    cout << "class ";
    db->GroundTruthSummary(cls);
  }

  const xymap_t& xymap = db->XYmap(classname);
  if (xymap.empty())
    return ShowError("AnalyseViewXY() : xymap for <", classname, "> empty");

  imagecolor<float> white("white");
  imagecolor<float> black("black");

  for (int i=0; i<cls.Length(); i++) {
    if (cls[i]!=1)
      continue;

    xymap_t::const_iterator xyi = xymap.find(i);
    if (xyi==xymap.end() || xyi->second.empty()) {
      ShowError("No xy for ", db->ObjectDump(i), " in ", classname);
      continue;
    }

    const xymap_ve& xyv = xyi->second;

    string in_name = db->SolveObjectPath(Label(i), "", "", false, NULL);
    if (in_name=="") {
      ShowError("File not found for ", db->ObjectDump(i));
      continue;
    }

    WriteLog(Label(i), ": processing <"+in_name+">");

    picsom::imagefile ifile(in_name);
    imagedata idata = ifile.frame(0);
    idata.force_three_channel();

    int d = 3;
    for (size_t j=0; j<xyv.size(); j++) {
      int x = xyv[j].first, y = xyv[j].second;
      WriteLog("  ", ToStr(x)+","+ToStr(y));

      for (int x1=x-d; x1<=x+d; x1++)
        for (int y1=y-d; y1<=y+d; y1++)
          if (idata.coordinates_ok(x1, y1)) {
            bool c = abs(y-y1)>abs(x-x1);
            idata.set(x1, y1, c?black:white);
          }
    }

    string out_name = classname+"-"+Label(i)+".jpg";
    imagefile::write(idata, out_name);
    WriteLog("  wrote <"+out_name+">");
  }

  return true;
}

  /////////////////////////////////////////////////////////////////////////////

  bool ends_with_only(const string& s) {
    return s.length()>=5 && s.substr(s.length()-5) == "-only";
  }

  bool Analysis::CalculateMapClassProbabilities(size_t index,
                                                const string& parentclass,
                                                classprobs_t& probs,
                                                float prob,
                                                bool include_terminal) {

    bool ok = true;
    bool debug = false;
    static map<string, simple::FloatMatrix> mapclassprobs;
    string msg = "CalculateMapClassProbabilities() : ";

    DataBase *db = CheckDB();

    for (list<string>::const_iterator it = featurechoices.begin();
         it!=featurechoices.end(); it++) {
      string feat = *it+"-"+parentclass;

      Index* ind = db->FindIndex(feat);
      TSSOM *ts = dynamic_cast<TSSOM*>(ind);
      if (!ts)
	return ShowError(msg, "could not cast ", feat, " into TSSOM.");
      ts->ReadMapFile();
      ts->ReadDivisionFile();
      
      int l = ts->Nlevels()-1;
      const IntVector& div = ts->Division(l,0);

      int unit = div[index];
      if (unit<0)
        continue;

      IntPoint pt = ts->Map(l).ToPoint(unit);

      list<string> cls = db->SplitClassNames(parentclass+imagenet_allcl);
      if (!include_terminal)
        cls.remove_if(ends_with_only);

      for (list<string>::const_iterator it=cls.begin(); it!=cls.end(); it++) {
        string cn = *it;

        if (include_terminal)
          StripLastWord(cn);

        string fbase = "_"+cn+"_"+feat;
        string fn = OutDirEvenDot()+
          (filename.empty()?"mapclassprob":filename)+fbase+".dat";

        map<string, simple::FloatMatrix>::iterator pit = mapclassprobs.find(fn);
        if (pit == mapclassprobs.end()) {
          if (!FileExists(fn)) {
            string s = fn+" not found!";
            if (!skipnonexistent)
              return ShowError(msg, s);
            if (debug)
              WriteLog(msg, s);
            pit = mapclassprobs.insert(pit, 
                                       make_pair(fn, simple::FloatMatrix()));
          } else {
            simple::FloatMatrix tmp(fn.c_str());
            pit = mapclassprobs.insert(pit, make_pair(fn, tmp));
          }
        }

        const simple::FloatMatrix& m = pit->second;
        if (!m.Size())
          continue;

        float val = prob*m.Get(pt.Y(), pt.X());

        if (debug)
          WriteLog(msg, feat+" ("+ToStr(pt.X())+","+ToStr(pt.Y())+"), "+cn+"="+
                   ToStr(val));
        // if (val < 1e-3)
        //   continue;
        
      	if (cn==parentclass)
          ShowError(msg, cn+"=="+parentclass+"!!");

        if (!include_terminal || !db->IsMetaClassFile(cn))
          InsertClassProb(probs, index, cn, val);

        if (db->IsMetaClassFile(cn))
          ok = ok && CalculateMapClassProbabilities(index, cn, probs, val,
                                                    include_terminal);

      }
    }
      
    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  inline float imagenet_norm_apriori(float f, float, float ap) {
    return f*ap;
  }

  inline float imagenet_norm_normalize(float f, float sum, float) {
    return f/sum;
  }

  inline float imagenet_func_min(float f, float prob) {
    return prob > f ? f : prob;
  }

  inline float imagenet_func_max(float f, float prob) {
    return prob < f ? f : prob;
  }

  inline float imagenet_func_prod(float f, float prob) {
    return prob*f;
  }
  
  inline float imagenet_func_sum(float f, float prob) {
    return prob+f;
  }  

  bool Analysis::CalculateSVMClassProbabilities(size_t index,
                                                const string& parentclass,
                                                classprobs_t& probs,
                                                float prob, 
                                                bool include_terminal,
                                                int depth) {
    bool ok = true;
    bool debug = false;
    typedef map<string,double> precalc_t;
    static map<string, precalc_t> mapclassprobs;
    static map<string, ground_truth> gt_cache;
    string msg = "CalculateMapClassProbabilitiesSVM() : ";

    DataBase *db = CheckDB();

    // if (depth > 2) {
    //   if (debug)
    //     cout << "Reached max depth." << endl;
    //   return ok;
    // }      

    // for (list<string>::const_iterator it = featurechoices.begin();
    //      it!=featurechoices.end(); it++) {
    string feat = featurechoices.front();
    
    vector<float> val;
    vector<int> csize;
    float sum = 0.0;
    float sum_ap = 0.0;
    int totsize = 0;

    list<string> cls = db->SplitClassNames(parentclass+imagenet_allcl);
    if (!include_terminal)
      cls.remove_if(ends_with_only);

    for (list<string>::const_iterator it=cls.begin(); it!=cls.end(); it++) {
      string cn = *it;

      map<string, ground_truth>::iterator gtp = gt_cache.find(cn);
      if (gtp == gt_cache.end()) {
        gtp = gt_cache.insert(gtp,
                              make_pair(cn,
                                        GroundTruthExpression(cn, Target(), 
                                                              -1, true)));
      }
      ground_truth& cgt = gtp->second;  
                                        
      csize.push_back(cgt.positives());
      totsize += csize.back();

      // cout << "cn size=" << csize.back() << endl << endl;

      if (include_terminal)
        StripLastWord(cn);

      string fn = imagenet_inputprefix+"::"+feat+"#"+cn+imagenet_specialpre;
      string dir = OutDirEvenDot();

      map<string, precalc_t>::iterator pit = mapclassprobs.find(fn);
      if (pit == mapclassprobs.end()) {
        if (!FileExists(dir+fn+".pre")) {
          string s = fn+" not found!";
          if (!skipnonexistent)
            return ShowError(msg, s);
          //    if (debug)
          WriteLog(msg, s+" SKIPPING.");
          pit = mapclassprobs.insert(pit, 
                                     make_pair(fn, precalc_t()));
        } else {
          PreCalculatedIndex tmp(db, fn, fn, dir, "", NULL);
          tmp.ReadPreCalculatedFile();
          pit = mapclassprobs.insert(pit, make_pair(fn, tmp.precalc));
        }
      }

      precalc_t& pc = pit->second;
      float vv = pc[Label(index)];
      
      val.push_back(vv);
      sum_ap += vv*csize.back();
      sum += vv;
    }


    int i=0;
    if (sum==0)
      sum = 1.0;
    if (sum_ap==0)
      sum_ap = 1.0;

    for (list<string>::const_iterator it=cls.begin(); it!=cls.end();
	 it++, i++) {
      string cn = *it;

      if (imagenet_norm_func) {
        double oldval = val[i];
        val[i] = (*imagenet_norm_func)(val[i], (float)csize[i]/sum_ap, sum);
        if (debug)
          WriteLog(msg, feat+" "+cn+", normalisation: "+ToStr(oldval)+"=>"+
                   ToStr(val[i]));
          
      }

      float cur_val = (*imagenet_mode_func)(val[i], prob);
      
      // if (cur_val < 1e-3)
      //   continue;

      if (cn==parentclass)
        ShowError(msg, cn+"=="+parentclass+"!!");

      if (debug)
        WriteLog(msg, feat+" "+cn+", cur_val="+ToStr(cur_val)+"="+ToStr(prob)+
                 "*"+ToStr(val[i]));

      if (!include_terminal || !db->IsMetaClassFile(cn))
        InsertClassProb(probs, index, cn, cur_val);

      if (db->IsMetaClassFile(cn)) 
        ok = ok && CalculateSVMClassProbabilities(index, cn, probs, cur_val,
                                                  include_terminal, depth+1);
    }
    

    // }
    
    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseImageFile(const vector<string>& a) {
    string msg = "AnalyseImageFile() : ";
    
    WriteLog("AnalyseImageFile");

    for (size_t i=0; i<a.size(); i++) {
      WriteLog("Starting to process entry <", a[i], ">");
      try {
	picsom::imagefile imgf(a[i]);
	cout << "  " << imgf.info() << endl;
	if (verbose>1)
	  for (int j=0; j<imgf.nframes(); j++)
	    cout << "    frame #" << j << " : " << imgf.frame(j).info()
		 << endl;

      } catch (string& err) {
	cout << "  ERROR: \"" << err << "\"" << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseImageNet(const vector<string>&
						     /*a*/) {
    string msg = "AnalyseImageNet() : ";

    // should we include virtual terminal nodes for non-leaf nodes
    // if false, we instead evaluate non-leaf nodes with all their sub-nodes
    bool include_terminal = false;  

    if (featurechoices.size() != 1)
      return ShowError(msg, "Currently AnalyseImageNet requires that you have "
                       "exactly one feature in featurechoices!");
    
    string cname = classname.empty() ? "*" : classname;
    ground_truth cls = GroundTruthExpression(cname, Target(), -1, true);

    string parentclass = imagenet_rootclass;

    if (imagenet_normalize == "apriori")
      imagenet_norm_func = &imagenet_norm_apriori;
    else if (imagenet_normalize == "norm") 
      imagenet_norm_func = &imagenet_norm_normalize;
    else
      imagenet_norm_func = NULL;
   
    if (imagenet_func == "min")
      imagenet_mode_func = &imagenet_func_min;
    else if (imagenet_func == "max")
      imagenet_mode_func = &imagenet_func_max;
    else if (imagenet_func == "prod")
      imagenet_mode_func = &imagenet_func_prod;
    else if (imagenet_func == "sum")
      imagenet_mode_func = &imagenet_func_sum;
    else
      return ShowError(msg, "Unknown value for parameter imagenet_func=",
                       imagenet_func);

    ProgressBar pb(cls.positives(), 50, msg);
    WriteLog(msg, "calculating class probabilities ...");

    classprobs_t probs;
    for (size_t i=0; i<cls.size(); i++) {
      if (cls[i]!=1)
        continue;
      pb.Inc();
      if (svm.empty())
        CalculateMapClassProbabilities(i, parentclass, probs, 1.0,
                                       include_terminal);
      else
        CalculateSVMClassProbabilities(i, parentclass, probs, 1.0,
                                       include_terminal, 1);
    }

    for (classprobs_t::const_iterator it=probs.begin(); it!=probs.end(); it++) {
      const string& cn = it->first;

      string nn = imagenet_normalize;
      if (!nn.empty())
        nn = string("_")+nn;

      string fn = featurechoices.front()+"_"+(filename.empty()?"":filename+"_")+
        (classname.empty() ? "all" : classname)+"_"+cn+"_"+imagenet_func+
        nn+imagenet_specialpre+".pre";
      ofstream fp(fn.c_str(), ios_base::out|ios_base::trunc);
      fp << "# PRECALCULATEDFILE" << endl;

      for (map<string,float>::const_iterator mit=it->second.begin();
           mit!=it->second.end(); mit++) 
        fp << mit->second << " " << mit->first << endl;
      
      // const map<string,float>& pp = it->second;
      // for (size_t i=0; i<CheckDB()->Size(); i++) {
      //   const string& l = Label(i);
      //   map<string,float>::const_iterator mit = pp.find(l);
      //   fp << (mit==pp.end() ? 0.0 : mit->second) << " " << l << endl;
      // }

      fp.close();
      WriteLog(msg, "Wrote <"+fn+">");
    }
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::RunAnalyseDivEachClass(const vector<string>& a, 
                                   const list<string>& cls) {
    string msg = "RunAnalyseDivEachClass() : ";
    if (cls.empty()) 
      return ShowError(msg+"SplitClassNames() class=["+classname+"] failed");

    script_exp_t scr = ScriptExpand(script, true);

    if (!ScriptReplace(scr, "analyse", "div", false, false))
      return ShowError(msg+"ScriptReplace() failed with <analyse>");
    if (!ScriptReplace(scr, "class", "", false, false))
      return ShowError(msg+"ScriptReplace() failed with <class>");
    if (!ScriptReplace(scr, "imagefile", "/dev/null", true, false))
      return ShowError(msg+"ScriptReplace() failed with <imagefile>");

    list<string> scr_choices = ScriptMakeChoices(scr, "LIST", "positive", cls);

    Analysis analysis(Picsom(), this, NULL, a);
    analysis.Script(scr_choices);
    analysis.StoreMatrices(true);
    return analysis.Optimize();
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseMapClassProbability(const vector<string>& a) {
    string msg = "AnalyseMapClassProbability() : ";

    list<string> cls = CheckDB()->SplitClassNames(classname);

    cls.remove_if(ends_with_only);

    stringstream ss;
    ss << msg << "with classes:";
    for (list<string>::iterator it=cls.begin(); it!=cls.end(); it++) {
      *it += "&all-train";
      ss << " " << *it;
    }
    WriteLog(ss.str());

    analyse_result res = RunAnalyseDivEachClass(a,cls);

    list<analyse_result>& r = res.sub_result;
    if (r.empty())
      return ShowError(msg+"empty sub_result");

    typedef map<string,simple::FloatMatrix> conv_t;
    conv_t& conv = r.begin()->conv_matrix;
    if (conv.empty())
      return ShowError(msg+"empty conv_matrix");

    typedef list<analyse_result> r_t;

    for (conv_t::const_iterator f=conv.begin(); f!=conv.end(); f++) {
      const string& feat = f->first;
      int cols = f->second.Columns();
      int rows = f->second.Rows();

      vector<string> cnames;
      vector<simple::FloatMatrix> cp;
      for (r_t::iterator j=r.begin(); j!=r.end(); j++) {
        const simple::FloatMatrix& m = j->conv_matrix[feat];
        cp.push_back(simple::FloatMatrix(rows,cols));
        cnames.push_back(j->params);
        if (!cp.back().SizesMatch(m)) {
          stringstream ss;
          ss << " m1=" << rows     << "x" << cols
             << " m2=" << m.Rows() << "x" << m.Columns();
          return ShowError(msg+"matrix sizes differ : "+ss.str());
        }
      }

      size_t len = 0;
      for (int x=0; x<cols; x++)
        for (int y=0; y<rows; y++) {
          float sum = 0;
          len=0;
          for (r_t::iterator j=r.begin(); j!=r.end(); j++, len++) {
            const simple::FloatMatrix& m = j->conv_matrix[feat];
            cp[len].Set(y, x, m(y, x));
            sum += m(y, x);
          }
          for (size_t i=0; i<len; i++)
            if (sum <= 0.0)
              cp[i].Set(y, x, 1.0/len);
            else
              cp[i].Multiply(y, x, 1.0/sum);
        }

      for (size_t i=0; i<len; i++) {
        simple::FloatMatrix& m = cp[i];
        string cn = cnames[i];
        if (cn.substr(0,9) == "positive=")
          cn = cn.substr(9);
        StripLastWord(cn,'-');
        StripLastWord(cn,'&');
        // string pn = classname;
        // StripLastWord(pn,'-');
        string fbase = /*"_"+pn+*/"_"+cn+"_"+feat;
        string fn = OutDirEvenDot()+
          (filename.empty()?"mapclassprob":filename)+fbase+".dat";

        m.Zipped(zipped);
        m.FileName(fn);
        if (!m.Write(fn))
          return ShowError(msg+"Could not write data to <", fn, ">"
                           " n=\""+ToStr(m.Nitems())+"\"");
        WriteLog("Wrote "+ToStr(m.Rows())+"x"+ToStr(m.Columns())+
                 " matrix data in <", fn, ">");

        string mfile = MatlabName();
        if (!mfile.empty()) {
          string mlab = Simple::MakeMatlabCompliant(mfile+fbase);
          m.Label(mlab);
          mfile = OutDirEvenDot()+mlab+".m";
          if (!m.WriteMatlab(mfile))
            return ShowError(msg+"Could not write data to <", mfile, ">"
                             " n=\""+ToStr(m.Nitems())+"\"");
          WriteLog("Wrote "+ToStr(m.Rows())+"x"+ToStr(m.Columns())+
                   " matrix data in <", mfile, ">");
        }
      
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseMapArea(const vector<string>& a) {
    string msg = "AnalyseMapArea() : ";

    analyse_result res = 
      RunAnalyseDivEachClass(a, CheckDB()->SplitClassNames(classname));

    list<analyse_result>& r = res.sub_result;
    if (r.empty())
      return ShowError(msg+"empty sub_result");

    typedef map<string,simple::FloatMatrix> conv_t;
    conv_t& conv = r.begin()->conv_matrix;
    if (conv.empty())
      return ShowError(msg+"empty conv_matrix");

    typedef list<analyse_result> r_t;

    for (conv_t::const_iterator f=conv.begin(); f!=conv.end(); f++) {
      const string& feat = f->first;
      cout << "Feature <" << feat << ">" << endl;

      simple::FloatMatrix max = f->second;
      simple::FloatMatrix snd(max.Rows(), max.Columns());
      IntMatrix   idx(max.Rows(), max.Columns());

      size_t cidx = 0;
      for (r_t::iterator j=r.begin(); j!=r.end(); j++, cidx++) {
        if (cidx==0)
          continue;
      
        const simple::FloatMatrix& m = j->conv_matrix[feat];
        if (!max.SizesMatch(m)) {
          stringstream ss;
          ss << "max=" << max.Rows() << "x" << max.Columns()
             << " m="  <<   m.Rows() << "x" <<   m.Columns();
          return ShowError(msg+"matrix sizes differ : "+ss.str());
        }

        for (int x=0; x<max.Columns(); x++)
          for (int y=0; y<max.Rows(); y++)
            if (m(y, x)>max(y, x)) {
              snd.Set(y, x, max(y, x));
              max.Set(y, x, m(y, x));
              idx.Set(y, x, cidx);

            } else if (m(y, x)>snd(y, x))
              snd.Set(y, x, m(y, x));
      }

      imagedata img(max.Columns(), max.Rows(), 1, imagedata::pixeldata_uchar);
      for (int x=0; x<max.Columns(); x++)
        for (int y=0; y<max.Rows(); y++) {
          float rr = numeric_limits<float>::max();
          if (snd(y, x))
            rr = (max(y, x)-snd(y, x))/snd(y, x);

          unsigned char color = 0;
          if (rr>=classmargin && max(y, x)>0)
            color = idx(y, x)+2;

          img.set(x, y, color);
        }
    
      string fname = imagefilename+feat+".png";

      try {
        img.colorize();
        imagefile::write(img, fname);
        WriteLog(msg+"wrote <"+fname+">");
      }
      catch (const string& err) {
        return ShowError(msg+err);
      }
    }

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseColorNames(const vector<string>&) {
  string msg = "AnalyseColorNames() : ";

  const size_t n = 20;

  ostream *os = &cout;
  ofstream ofile;
  if (imagefilename!="") {
    string fname = imagefilename+".tex";
    ofile.open(fname.c_str());
    if (!ofile)
      return ShowError(msg+"failed to open <"+fname+">"); 
    os = &ofile;
  }

  imagedata img(n, 1, 1, imagedata::pixeldata_uchar);
  for (size_t x=0; x<img.width(); x++)
    img.set(x, 0, (unsigned char) x);
  img.colorize();

  for (size_t x=0; x<img.width(); x++) {
    vector<unsigned char> rgb = img.get_uchar(x, 0);
    if (rgb.size()!=3)
      return ShowError(msg+"not rgb");

    *os << "\\definecolor{picsomidx" << x << "}{rgb}";
    for (size_t c=0; c<rgb.size(); c++)
      *os << (c?",":"{") << rgb[c]/255.0;
    *os << "}" << endl;
  }

  for (size_t x=2; x<img.width(); x++) {
    vector<unsigned char> rgb = img.get_uchar(x, 0);
    *os << "\\definecolor{picsomcls" << x-2 << "}{rgb}";
    for (size_t c=0; c<rgb.size(); c++)
      *os << (c?",":"{") << rgb[c]/255.0;
    *os << "}" << endl;
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseMapCollage(const vector<string>& a) {
  string msg = "AnalyseMapCollage() : ";

  if (maptnspec=="" || imagefilename=="")
    return ShowError(msg+"maptnspec (e.g. a46x46+2+2) and "
                     "imagefile should be set");

  bool ok = ReadFiles();

  string s_pre, s_pos;
  size_t c = segmentspec.find(':');
  if (c!=string::npos) {
    s_pre = segmentspec.substr(0, c+1);
    s_pos = segmentspec.substr(c+1);
  }

  for (size_t m=0; ok && m<Nfeatures(); m++) {
    TSSOM &tssom = TsSom(m);
    int l = level>=0 ? level : tssom.Nlevels()-1;
    if (l<0) {
      ok = ShowError("level could not be solved");
      continue;
    }

    imagedata b;
    if (!dummy_tssom->BackGround().empty())
      b = dummy_tssom->BackGround().begin()->second;

    vector<int> v(4);
    if (a.size()) {
      string arg = a[0];
      const size_t len = arg.length();
      if (arg[0]=='(' && arg[len-1]==')')
        arg = arg.substr(1,len-2);
      vector<string> vs = SplitInCommasObeyParentheses(arg);
      if (vs.size()>=3) {
        // top left corner
        v[0] = atoi(vs[0].c_str());
        v[1] = atoi(vs[1].c_str());

        if (vs[2][0]=='+') {
          // width, height
          size_t h, w = atoi(vs[2].substr(1).c_str());
          if (vs.size()==3)
            h = w;
          else
            h = atoi(vs[3].substr(vs[3][0]=='+'?1:0).c_str());
          v[2] = v[0]+w-1;
          v[3] = v[1]+h-1;
        } else if (vs.size()>=4) {
          // bottom right corner
          v[2] = atoi(vs[2].c_str());
          v[3] = atoi(vs[3].c_str());
        }
      }
    }

    TSSOM::map_tn_spec_t spec = TSSOM::SolveMapTnSpec(maptnspec);
    imagedata img = tssom.CreateMapCollage(l, spec, b, bgcolor,
                                           v[0], v[1], v[2], v[3],
                                           s_pre, s_pos);

    string fname = imagefilename+tssom.Name()+".png";
    imagefile::write(img, fname);

    WriteLog("Wrote map collage image <"+fname+">");
  }

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result
Analysis::AnalyseRandomCollage(const vector<string>&) {
  string msg = "AnalyseRandomCollage() : ";

  if (maptnspec=="" || imagefilename=="" || !columns)
    return ShowError(msg+"columns, maptnspec and imagefile should be set");

  bool ok = ReadFiles();

  TSSOM::map_tn_spec_t spec = TSSOM::SolveMapTnSpec(maptnspec);
  stringstream ss;
  ss << (spec.keepaspect?"a":"") << spec.iw << "x" << spec.ih;
  string ispec = ss.str();  
  imagedata empty(0, 0);

  size_t nrounds = rounds>0 ? rounds : 1;

  for (size_t i=0; i<nrounds; i++) {
    if (!CheckQuery()->RandomUnseenObjects(true, false))
      return ShowError(msg+"RandomUnseenObjects() failed");

    list<string> set;
    for (size_t o=0; o<(size_t)CheckQuery()->NnewObjects(); o++)
      set.push_back(CheckQuery()->NewObject(o).Label());

    imagedata img = CheckDB()->CreateImageCollage(set, ispec, columns,
                                                  spec.bw, spec.bh, empty);

    stringstream ifss;
    ifss << imagefilename;
    if (nrounds>1)
      ifss << "-" << i;
    ifss << ".png"; 
    string fname = ifss.str();

    imagefile::write(img, fname);

    WriteLog("Wrote random collage image <"+fname+"> with rndseed="+
             ToStr(CheckQuery()->RndSeed()));

    if (i<nrounds-1)
      CheckQuery()->RndSeedStep(true);
  }

  return ok;
}

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCreateCollage(const vector<string>& args) {
    string msg = "AnalyseCreateCollage() : ";

    if (imagefilename=="" || !args.size())
      return ShowError(msg+"imagefile should be set and argument(s) given");

    bool ok = ReadFiles();
  
    DataBase *db = CheckDB();

    for (size_t i=0; i<args.size(); i++) {
      string lab = args[i];
      int    idx = db->LabelIndex(lab);
      if (idx==-1 || !db->ObjectsTargetTypeContains(idx, target_collage))
	return ShowError(msg+"not a collage object");

      string path = db->SolveObjectPath(lab);
      if (path=="")
	return ShowError(msg+"path of <"+lab+"> not solved");

      XmlDom xml = XmlDom::Parse(path);
      if (!xml.DocOK())
	return ShowError(msg+"parsing <"+path+"> failed");

      imagedata img = DataBase::CreateImageCollage(xml, db, NULL);
      if (img.width()==0)
	return ShowError(msg+"CreateImageCollage() failed");

      string fname = imagefilename;
      if (fname.find('.')==string::npos)
	fname += ".png";

      imagefile::write(img, fname);

      WriteLog("Wrote collage image <"+fname+">");

      xml.DeleteDoc();
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCreateVideoCollage(const vector<string>& args) {
    string msg = "AnalyseCreateVideoCollage() : ";

    size_t cols = 4, rows = 4, ntot = rows*cols, bw = 200, bh = 150, m = 5;
    string spec = "a"+ToStr(bw)+"x"+ToStr(bh);

    if (imagefilename=="" || !args.size())
      return ShowError(msg+"imagefile should be set and argument(s) given");

    bool ok = ReadFiles();
  
    DataBase *db = CheckDB();

    for (size_t i=0; i<args.size(); i++) {
      ground_truth gt = db->GroundTruthExpression(args[i]);
      for (size_t idx=0; idx<gt.size(); idx++) 
	if (gt[idx]==1) {
	  string lab = db->Label(idx);
	  if (!db->ObjectsTargetTypeContains(idx, target_video))
	    return ShowError(msg+"<"+lab+"> is not a video object");

	  string path = db->SolveObjectPath(lab);
	  if (path=="")
	    return ShowError(msg+"path of <"+lab+"> not solved");

	  const object_info *oi = db->FindObject(idx);
	  if (!oi)
	    return ShowError(msg+"FindObject("+ToStr(idx)+") failed");

	  vector<string> labset1, labset2;

	  size_t nc = oi->children.size(), ncc = 0;

	  oi->dump();
	  for (size_t c=0; c<nc; c++) {
	    int cidx = oi->children[c];
	    const object_info *oci = db->FindObject(cidx);
	    if (!oci)
	      return ShowError(msg+"FindObject("+ToStr(cidx)+") failed");

	    cout << "  ";
	    oci->dump();

	    for (size_t d=0; d<oci->children.size(); d++) {
	      int didx = oci->children[d];
	      const object_info *odi = db->FindObject(didx);
	      if (!odi)
		return ShowError(msg+"FindObject("+ToStr(didx)+") failed");
	      cout << "    ";
	      odi->dump();

	      if (d==0)
		labset1.push_back(odi->label);
	      else
		labset2.push_back(odi->label);
	    }
	    ncc += oci->children.size();
	  }

	  RandVar rv;
	  while (labset1.size()>ntot) {
	    size_t n = (size_t)rv.RandomInt(labset1.size()-2);
	    labset1.erase(labset1.begin()+n+1);
	  }

	  while (labset1.size()<ntot && labset2.size()) {
	    size_t n = (size_t)rv.RandomInt(labset2.size());
	    size_t m = n*labset1.size()/labset2.size();
	    labset1.insert(labset1.begin()+m, labset2[n]);
	    labset2.erase(labset2.begin()+n);
	  }

	  list<string> labset(labset1.begin(), labset1.end());
	  imagedata bimg;
	  imagedata img = CheckDB()->CreateImageCollage(labset, spec,
							cols, bw+m, bh+m, bimg);

	  string fname = imagefilename+"-"+lab+".png";
	  imagefile::write(img, fname);

	  WriteLog("Wrote video collage image <"+fname+">");
	}
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseGazeTrace(const vector<string>& a) {
    string msg = "AnalyseGazeTrace() : ";
  
    if (imagefilename=="")
      return ShowError(msg+"imagefile should be set");

    if (a.empty())
      return ShowError(msg+"arguments missing");

    for (size_t i=0; i<a.size(); i++) {
      const string& fname = a[i];
      string msgfile = msg+"file <"+fname+"> : ";

      if (!FileExists(fname))
        return ShowError(msgfile+"not found");

      XmlDom xml = XmlDom::Parse(fname);
      if (!xml.DocOK())
        return ShowError(msgfile+"is not proper XML");

      XmlDom start = xml.Root();
      if (start.NodeName()!="start")
        return ShowError(msgfile+"root node is not <start>");

      string stimulus = start.FindContent("setup/tracking_conditions/stimulus",
                                          true);
      if (stimulus=="")
        return ShowError(msgfile+"<stimulus> not found");

      cout << "stimulus=[" << stimulus << "]" << endl;

      string sfname = CheckDB()->SolveObjectPath(stimulus);
      if (sfname=="")
        return ShowError(msg+"file of label <"+stimulus+"> not found");

      cout << "sfname=[" << sfname << "]" << endl;

      imagedata img;
      try {
        picsom::imagefile ifile(sfname);
        img = ifile.frame(0);
      } catch (...) {
        return ShowError(msg+"failed to open image file <"+stimulus+">");
      }
      img.force_three_channel();
      img.convert(imagedata::pixeldata_uchar);
      vector<unsigned char> red(3);
      red[0] = 255;
      red[1] = red[2] = 0;

      bool show_err = false;

      XmlDom list = start.FindPath("image/gaze/samples", show_err);
      bool gaze_samples = list;
      if (!GazeTraceDraw(img, list, "sample", "right", "eye/x", "eye/y",
                         "red", "red"))
        return ShowError(msgfile+"drawing image/gaze/samples failed");

      if (!GazeTraceDraw(img, list, "sample", "left", "eye/x", "eye/y",
                         "yellow", "yellow"))
        return ShowError(msgfile+"drawing image/gaze/samples failed");

      list = start.FindPath("image/gaze/fixations", show_err);
      bool gaze_fixations = list;
      if (!GazeTraceDraw(img, list, "fixation", "", "x", "y", "green", ""))
        return ShowError(msgfile+"drawing image/pointer/samples failed");

      list = start.FindPath("image/pointer/samples", show_err);
      bool pointer_samples = list;
      if (!GazeTraceDraw(img, list, "sample", "", "x", "y", "blue", "blue"))
        return ShowError(msgfile+"drawing image/pointer/samples failed");

      list = start.FindPath("image/pointer/clicks", show_err);
      bool pointer_clicks = list;
      if (!GazeTraceDraw(img, list, "click", "", "x", "y", "black", ""))
        return ShowError(msgfile+"drawing image/pointer/samples failed");

      if (!gaze_samples && !pointer_samples && !gaze_fixations &&
          !pointer_clicks)
        return ShowError(msgfile+"no <samples> nor <fixations>"
                         " nor <clicks> found");

      string outf = fname;
      size_t p = outf.find(".xml");
      if (p!=string::npos)
        outf.erase(p);
      string dir = outf;
      p = outf.rfind('/');
      if (p!=string::npos) {
        dir.erase(p+1);
        outf.erase(0, p+1);
      } else
        dir = "";

      outf = dir+imagefilename+outf+".jpg";

      try {
        imagefile::write(img, outf);
        WriteLog("Successfully wrote <"+outf+">");
      } catch (...) {
        return ShowError(msgfile+"failed to write <"+outf+">");
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////
  /*
  Analysis::analyse_result
  Analysis::AnalyseGazeTrace(const vector<string>& a) {
    string msg = "AnalyseGazeTrace(vector<string>) : ";
  
    if (imagefilename=="")
      return ShowError(msg+"imagefile should be set");

    if (a.empty())
      return ShowError(msg+"arguments missing");

    for (size_t i=0; i<a.size(); i++) {
      const string& fname = a[i];
      string msgfile = msg+"file <"+fname+"> : ";

      if (!FileExists(fname))
        return ShowError(msgfile+"not found");

      XmlDom xml = XmlDom::Parse(fname);
      if (!xml.DocOK())
        return ShowError(msgfile+"is not proper XML");

      XmlDom start = xml.Root();

      imagedata img;
      try {
        picsom::imagefile ifile(sfname);
        img = ifile.frame(0);
      } catch (...) {
        return ShowError(msg+"failed to open image file <"+stimulus+">");
      }
      img.force_three_channel();
      img.convert(imagedata::pixeldata_uchar);

      if (!AnalyseGazeTrace(start, img))
        return ShowError(msgfile+"failed");

      string outf = fname;
      size_t p = outf.find(".xml");
      if (p!=string::npos)
        outf.erase(p);
      string dir = outf;
      p = outf.rfind('/');
      if (p!=string::npos) {
        dir.erase(p+1);
        outf.erase(0, p+1);
      } else
        dir = "";

      outf = dir+imagefilename+outf+".jpg";

      try {
        imagefile::write(img, outf);
        WriteLog("Successfully wrote <"+outf+">");
      } catch (...) {
        return ShowError(msgfile+"failed to write <"+outf+">");
      }
    }

    return true;
  }
  */
  /////////////////////////////////////////////////////////////////////////////
  /*
  Analysis::analyse_result
  Analysis::AnalyseGazeTrace(const XmlDom& start, imagedata& img) {
    string msg = "AnalyseGazeTrace(XmlDom) : ";

      XmlDom start = xml.Root();
      if (start.NodeName()!="stream.start") // was "start"
        return ShowError(msgfile+"root node is not <start>");

      string stimulus = start.FindContent("setup/tracking_conditions/stimulus",
                                          true);
      if (stimulus=="")
        return ShowError(msgfile+"<stimulus> not found");

      cout << "stimulus=[" << stimulus << "]" << endl;

      string sfname = CheckDB()->SolveObjectPath(stimulus);
      if (sfname=="")
        return ShowError(msg+"file of label <"+stimulus+"> not found");

      cout << "sfname=[" << sfname << "]" << endl;

      vector<unsigned char> red(3);
      red[0] = 255;
      red[1] = red[2] = 0;

      bool show_err = false;

      XmlDom list = start.FindPath("image/gaze/samples", show_err);
      bool gaze_samples = list;
      if (!GazeTraceDraw(img, list, "sample", "right", "eye/x", "eye/y",
                         "red", "red"))
        return ShowError(msgfile+"drawing image/gaze/samples failed");

      if (!GazeTraceDraw(img, list, "sample", "left", "eye/x", "eye/y",
                         "yellow", "yellow"))
        return ShowError(msgfile+"drawing image/gaze/samples failed");

      list = start.FindPath("image/gaze/fixations", show_err);
      bool gaze_fixations = list;
      if (!GazeTraceDraw(img, list, "fixation", "", "x", "y", "green", ""))
        return ShowError(msgfile+"drawing image/pointer/samples failed");

      list = start.FindPath("image/pointer/samples", show_err);
      bool pointer_samples = list;
      if (!GazeTraceDraw(img, list, "sample", "", "x", "y", "blue", "blue"))
        return ShowError(msgfile+"drawing image/pointer/samples failed");

      list = start.FindPath("image/pointer/clicks", show_err);
      bool pointer_clicks = list;
      if (!GazeTraceDraw(img, list, "click", "", "x", "y", "black", ""))
        return ShowError(msgfile+"drawing image/pointer/samples failed");

      if (!gaze_samples && !pointer_samples && !gaze_fixations &&
          !pointer_clicks)
        return ShowError(msgfile+"no <samples> nor <fixations>"
                         " nor <clicks> found");

    }

    return true;
  }
  */
  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::GazeTraceDraw(imagedata& img, XmlDom& samples,
                               const string& elem, const string& side,
                               const string& xel, const string& yel,
                               const string& cc, const string& cl) {
    string msg = "GazeTraceDraw() : ";
    bool debug = false;
    int max = numeric_limits<int>::max(), px = max, py = max;

    XmlDom sample = samples.FirstChild();
    while (sample) {
      while (sample && !sample.IsElement())
        sample = sample.Next();
      if (!sample)
        break;

      if (sample.NodeName()!=elem)
        return ShowError(msg+"<"+elem+"> not found");

      string xs, ys;

      if (side=="") {
        xs = sample.FindContent(xel, true);
        ys = sample.FindContent(yel, true);

      } else {
        for (size_t skip=0;; skip++) {
          XmlDom eye = sample.FindChild("eye", skip);
          if (!eye)
            break;
          if (eye.Property("side")==side) {
            xs = eye.FindContent("x", true);
            ys = eye.FindContent("y", true);
            break;
          }
        }
            
        if (xs=="" || ys=="") {
          sample = sample.Next();
          continue;
        }
      }

      if (xs=="" || ys=="")
        return ShowError(msg+"<"+xel+"> or <"+yel+"> not found");

      if (debug)
        cout << elem << " " << side << " xs=<" << xs
	     << "> ys=<" << ys << ">" << endl;

      int x = atoi(xs.c_str()), y = atoi(ys.c_str());
      if (px!=max && cl!="")
        img.line(px, py, x, y, 1, cl);

      if (cc!="")
        img.circle(x, y, 5.5, 0.0, cc);
      
      px = x;
      py = y;

      sample = sample.Next();
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseGazeRelevance(const vector<string>& a) {
    using namespace cox;

    bool norm = false, nozeros = false;
    size_t k = 11;

    for (size_t i=0; i<a.size(); i++) {
      if (a[i]=="norm")
	norm = true;
      if (a[i]=="nozeros")
	nozeros = true;
      if (a[i].find("k=")==0)
	k = atoi(a[i].substr(2).c_str());
    }

    string msg = "AnalyseGazeRelevance() : ";

    vector<pair<string,string> > idcls;
    idcls.push_back(make_pair("00003000", "aeroplane"));
    idcls.push_back(make_pair("00003508", "dog"));
    idcls.push_back(make_pair("00004021", "dog"));
    idcls.push_back(make_pair("00004215", "motorbike"));
    idcls.push_back(make_pair("00004470", "aeroplane"));
    idcls.push_back(make_pair("00004851", "cat"));
    idcls.push_back(make_pair("00005309", "cat"));
    idcls.push_back(make_pair("00005534", "motorbike"));
    idcls.push_back(make_pair("00006846", "dog"));
    idcls.push_back(make_pair("00008720", "cat"));
    idcls.push_back(make_pair("00008905", "aeroplane"));
    idcls.push_back(make_pair("00009457", "motorbike"));

    string dir = CheckDB()->ExpandPath("analysis/gaze-relevance");

    size_t vlen = 33;

    map<string,gaze_data_t> all_data;

    for (size_t i=0; i<idcls.size(); i++)
      for (size_t u=1; u<7; u++) {
	string p = "user"+ToStr(u)+"-"+idcls[i].first+"-"+idcls[i].second;
	string f = "march2010-"+p+".dat";
	string ff = dir+"/"+f;
	// cout << "<" << f << "> " << FileExists(ff) << endl;
	if (!FileExists(ff))
	  return ShowError(msg+"file <"+ff+"> not found");

	gaze_data_t dall = sompak::data(ff), dnz;
	if (nozeros)
	  for (gaze_data_t::const_iterator j=dall.begin(); j!=dall.end(); j++) {
	    bool nz_found = false;
	    for (size_t k=0; !nz_found && k<vlen; k++)
	      if ((*j)[k]!=0.0)
		nz_found = true;
	    if (nz_found)
	      dnz.push_back(*j);
	  }
	all_data[p] = nozeros ? dnz : dall;
      }

    vector<float> w(vlen), wd(w);

    w[0]  = 1;
    w[13] = 1;
    w[2]  = 1;
    w[16] = 1;
    w[17] = 1;
    w[7]  = 1;
    w[1]  = 1;
    w[8]  = 1;
    w[18] = 1;
    w[20] = 1;

    int seed = 123;
    RandVar randvar(seed);

    float best = 0.0;

    for (size_t i=0; i<100000; i++) {
      vector<float> wx = blas::vec_plus(w, wd);
      vector<size_t> res = GazeDataRunAllUsers(all_data, wx, norm, k);
      size_t corrs = res[0], naive = res[1], tot = res[2];
      size_t tp = res[3], fp = res[4], tn = res[5], fn = res[6];
      float r = float(corrs)/tot;

      float ppg = float(tp+fn)/tot, png = float(tn+fp)/tot;
      float H  = -(ppg*log(ppg)+png*log(png))/log(2.0);

      float ppc = float(tp+fp)/tot, pnc = float(tn+fn)/tot;
      float ptp = float(tp)/tot, pfp = float(fp)/tot;
      float ptn = float(tn)/tot, pfn = float(fn)/tot;
      float I  = (ptp*log(ptp/(ppg*ppc))+
		  pfp*log(pfp/(png*ppc))+
		  ptn*log(ptn/(png*pnc))+
		  pfn*log(pfn/(ppg*pnc)))/log(2.0);
      float Hc = H-I;

      cout << TimeStamp() << " i=" << i << " TOTAL : " << r << " / " << best
	   << " (" << float(naive)/tot << ") with norm=" << norm
	   << " k=" << k << " nozeros=" << nozeros << " tot=" << tot
	   << "  " << tp << " " << fp << " " << tn << " " << fn
	   << " H=" << H << " Hc=" << Hc << " I=" << I
	   << endl;

      if (r>best) {
	best = r;
	w = wx;
	cout << "BEST i=" << i << " r=" << r << " ";
	blas::show(w) << endl;
	if (i)
	  continue;
      }

      for (size_t j=0; j<wd.size(); j++) {
	float rnd = randvar;
	rnd -= 0.5;
	rnd /= 100;
	wd[j] = rnd;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<size_t> 
  Analysis::GazeDataRunAllUsers(const map<string,gaze_data_t>& all_data,
				const vector<float>& w,
				bool norm, size_t k) {
    size_t corrs_tot = 0, naive_tot = 0, tot_tot = 0;
    size_t tp_tot = 0, fp_tot = 0, tn_tot = 0, fn_tot = 0;

    for (size_t u=1; u<7; u++) {
      string user = "user"+ToStr(u);

      list<pair<string,bool> > spec_tra, spec_tes;

      spec_tra.push_back(make_pair(user, false));
      spec_tes.push_back(make_pair(user, true ));

      vector<size_t> res = GazeDataRun(all_data, spec_tra, spec_tes,
				       w, norm, k);
      size_t corrs = res[0], naive = res[1], tot = res[2];
      size_t tp = res[3], fp = res[4], tn = res[5], fn = res[6];

      if (verbose>1)
	cout << user << " : " << float(corrs)/tot << " ("
	     << float(naive)/tot << ")" << endl;

      corrs_tot += corrs;
      naive_tot += naive;
      tot_tot   += tot;
      tp_tot 	+= tp;
      fp_tot 	+= fp;
      tn_tot 	+= tn;
      fn_tot 	+= fn;
    }

    vector<size_t> r(7);
    r[0] = corrs_tot;
    r[1] = naive_tot;
    r[2] = tot_tot;
    r[3] = tp_tot;
    r[4] = fp_tot;
    r[5] = tn_tot;
    r[6] = fn_tot;

    return r;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<size_t> 
  Analysis::GazeDataRun(const map<string,gaze_data_t>& m,
			const list<pair<string,bool> > &tra,
			const list<pair<string,bool> > &tes,
			const vector<float>& w,
			bool norm, size_t k) {

    //gaze_data_t train = sompak::data("testxx.dat");
    gaze_data_t train = GazeData(m, tra);
    gaze_data_t test  = GazeData(m, tes);

    if (verbose>2)
      cout << "train: " << train.size() << "  test: " << test.size() << endl;

    vector<float> mean(w.size()), mul(w.size());
    for (size_t i=0; i<mul.size(); i++)
      mul[i] = std::pow(10.0f, w[i]);

    if (norm) {
      pair<vector<float>,vector<float> >  mv = cox::stat::mean_variance(train);
      mean = mv.first;
      vector<float> std = mv.second;
      for (size_t i=0; i<std.size(); i++)
	if (std[i]>0) {
	  std[i] = sqrt(std[i]);
	  mul[i] /= std[i];
	}

      bool show = verbose>2;
      if (show) {
	cout << "mean = ";
	cox::blas::show(mean) << endl;
	cout << "std = ";
	cox::blas::show(std) << endl;
      }
    }

    GazeDataNormalize(train, mean, mul);
    GazeDataNormalize(test,  mean, mul);

    return GazeDataClassify(train, test, k);
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::gaze_data_t Analysis::GazeData(const map<string,gaze_data_t>& m,
					   const list<pair<string,bool> >& s) {
    gaze_data_t ret;

    for (map<string,gaze_data_t>::const_iterator i=m.begin();
	 i!=m.end(); i++) {
      const string& k = i->first;
      bool drop = false;
      for (list<pair<string,bool> >::const_iterator j=s.begin();
	   !drop && j!=s.end(); j++) {
	const string& c = j->first; 
	bool b = j->second; 
	if ((k.find(c)==string::npos&&b)||
	    (k.find(c)!=string::npos&&!b))
	  drop = true;
      }
      if (!drop)
	ret.insert(ret.end(), i->second.begin(), i->second.end());
    }

    return ret;
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::GazeDataNormalize(gaze_data_t& d,
				   const vector<float>& m,
				   const vector<float>& s) {

    for (gaze_data_t::iterator i=d.begin(); i!=d.end(); i++)
      *i = cox::blas::vec_times(cox::blas::vec_minus(*i, m), s);
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<size_t> Analysis::GazeDataClassify(const gaze_data_t& train,
					    const gaze_data_t& test,
					    size_t k) {
    cox::knn knn(k, train);

    vector<size_t> ret(7);
    size_t &corrs = ret[0], &naive = ret[1];
    size_t &tp = ret[3], &fp = ret[4], &tn = ret[5], &fn = ret[6];

    for (gaze_data_t::const_iterator i=test.begin();
	 i!=test.end(); i++) {
      const cox::labeled<vector<float> >& v = *i;
      string res = knn.classify(v);
      if (verbose>3)
	cout << v.label() << " -> " << res << endl;

      bool t = v.label()==res;
      if (t)
	corrs++;

      if (v.label()=="non")
	naive++;

      if (res=="rel")
	(t ? tp : fp)++;
      else
	(t ? tn : fn)++;
    }

    if (2*naive<test.size())
      naive = test.size()-naive;

    ret[2] = test.size();

    return ret;
  }

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseVideoStream(const vector<string>&) {
#ifdef PICSOM_USE_CSOAP
  string err = "AnalyseVideoStream() : ";

  bool ok = true;

  string soap_url    = "http://localhost:10000/ui-art";
  string soap_urn    = "urn:ui-art";
  string soap_method = "get_frame";
  Connection *c = Picsom()->CreateSoapClientConnection(soap_url);

  videofile mplayer("-", true);

  for (;;) {
    imagedata img = c->SoapClientGetFrame(soap_urn, soap_method);

    cout << img.info() << endl;

    if (img.iszero()) //!isempty
      break;

    mplayer.add_frame(img);
  }

  return ok;
#else
  return ShowError("AnalyseVideoStream() not implemented");
#endif // PICSOM_USE_CSOAP
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalyseConvertDiv(const vector<string>&) {
  bool ok = ReadFiles();
  for (size_t m=0; ok && m<Nfeatures(); m++)
    ok = ok && TsSom(m).WriteXmlDivisionFile(true);
  return ok;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result Analysis::AnalysePost(const vector<string>& a) {
  string err = "AnalysePost() : ";

  if (!a.size())
    return ShowError(err+"missing arguments");

  if (verbose>1) {
    GnuPlot::Debug(1);
    GnuPlotData::Keep(true);
  }
    
  string cmd = a[0];
  size_t esp  = cmd.find('=');
  string spec = esp==string::npos ? "" : cmd.substr(esp+1);
  if (esp!=string::npos)
    cmd.erase(esp);

  if (cmd=="-help" || (cmd!="-plot" && cmd!="-plotpdf" &&
		       cmd!="-dir" && cmd!="-show")) {
    cout << endl
         << "analyse=post : " << endl
         << "  -help ...          : this message" << endl
         << "  -dir xxx ...       : dir dump of xxx ..." << endl
         << "  -show=spec xxx ... : show stored values of xxx ..." << endl
         << "  -plot=spec xxx ... : plot something" << endl
         << "  -plotpdf=spec xxx ... : plot something" << endl
         << endl;
    return true;
  }

  bool ok = true;
  analyse_result ar_all;
  if (a.size()==2)
    ar_all = a[1];
  else
    for (size_t i=1; ok && i<a.size(); i++)
      ar_all.add_sub_result(a[i]);

  if (cmd!="-dir" && !Picsom()->Quiet()) {
    cout << endl << "Structure of all in one :" << endl << endl;
    ar_all.dump(cout, "", true, false);
    cout << endl;
  }

  if (cmd=="-show")
    ok = Show(ar_all, spec, ar_all.rescount==0?"*":"");

  gnuplot_extra.clear();
  if (cmd=="-plotpdf") {
    cmd = "-plot";
    gnuplot_extra.push_back("pdf");
  }
  
  if (cmd=="-plot")
    ok = Plot(ar_all, spec, ar_all.rescount==0?"*":"");

  for (size_t i=1; ok && i<a.size(); i++) {
    analyse_result r(a[i]);

    stringstream ss;
    ss << i-1;
    string istr = a.size()>2 ? ss.str() : "";

//     if (cmd=="-plot")
//       ok = Plot(r, spec, istr);

    if (cmd=="-dir") {
      cout << endl << "Structure of <" << a[i] << "> :" << endl << endl;
      ok = r.dump(cout, istr, true, false);
    }
  }
  if (cmd=="-dir")
    cout << endl;

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::Show(const analyse_result& r, const string& a,
                    const string& istr) {
  string err = "Show() : ";

  return Plot(r, "show"+a, istr);
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::Plot(const analyse_result& r, const string& ain, 
		    const string& istr) {
  string err = "Plot() : ";

  string a = ain!="" ? ain : plot;
  if (a=="")
    return ShowError(err+"no plot specification");

  if (r.errored())
    return ShowError(err+"result errored");

  if (r.empty() && r.sub_result.empty())
    return ShowError(err+"result empty");

  WriteLog("Plot("+a+")");

  if (a.substr(0, 4)=="show")
    return PlotShow(r, a.substr(4), istr);

  if (a.substr(0, 3)=="roc")
    return PlotRoc(r, a.substr(3), istr);

  if (a.substr(0, 3)=="mar")
    return PlotMinAccRec(r, a.substr(3), istr);

  if (a.substr(0, 2)=="rp")
    return PlotRP(r, a.substr(2), istr);

  return ShowError(err+"unknown plot type <"+a+">");
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::PlotShow(const analyse_result& r, const string& sin,
                       const string& istr) {
  WriteLog("PlotShow(["+sin+"],["+istr+"])");

  GnuPlot gp;

  vector<string> sv = SplitInCommas(sin);
  if (sv.empty())
    sv.push_back(istr);
  
  bool ok = true;
  for (size_t i=0; ok && i<sv.size(); i++)
    ok = PlotAdd(gp, r, "show", "", sv[i]);

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

  bool Analysis::PlotShowBySpec(const analyse_result& r, const string& s) {
  WriteLog("PlotShowBySpec(["+s+"])");

  vector<string> sv = SplitInCommas(s);
  bool ok = true;
  float div = r.rescount?r.rescount:1;

  for (size_t i=0; ok && i<sv.size(); i++)
    if (sv[i]=="time_cpu")
      cout << r.time_cpu << endl;
    else if (sv[i]=="avgprec")
      cout << r.avgprec/div << endl;
    else if (sv[i]=="avgprecadv_a")
      cout << r.avgprecadv_a/div << endl;
    else if (sv[i]=="avgprecadv_g")
      cout << r.avgprecadv_g_value(div) << endl;
    else
      ok = ShowError("PlotShowBySpec() cannot recognize ["+sv[i]+"]"); 

  return ok;
}

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::PlotRoc(const analyse_result& r, const string& sin,
			 const string& istr) {
    WriteLog("PlotRoc(["+sin+"],["+istr+"])");

    string s = sin;

    float tic = 0.1, xltic = tic;
    float x_0 = 0, x_1 = 1, y_0 = 0, y_1 = 1;

    if (s[0]=='x') {
      tic   = 0.01;
      xltic = 0.02;
      x_1 = 0.2;
      y_0 = 0.8;
      s.erase(0, 1);
    }

    bool diag = false;
    if (s[0]=='d') {
      diag = true;
      s.erase(0, 1);
    }

    list<string> cmd = PlotCommandCommon1(tic, xltic);
    if (s!="")
      cmd.push_front(s);

    GnuPlot gp(cmd);
    PlotCommandCommon2(gp, x_0, x_1, y_0, y_1);

    string spec = s;
    vector<string> sv = SplitInCommas(spec);
    if (sv.empty())
      sv.push_back(istr);

    if (diag) {
      FloatPointVector v(2);
      v[0] = FloatPoint(0, 0);
      v[1] = FloatPoint(1, 1);
      gp.AddPlot(v, "");
      v[0] = FloatPoint(0, 1);
      v[1] = FloatPoint(1, 0);
      gp.AddPlot(v, "");
    }
  
    bool ok = true;
    for (size_t i=0; ok && i<sv.size(); i++)
      ok = PlotAdd(gp, r, "roc", "", sv[i]);

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::PlotMinAccRec(const analyse_result& r, const string& sin,
			       const string& istr) {
    WriteLog("PlotMinAccRec(["+sin+"],["+istr+"])");

    string s = sin;

    float tic = 0.5, xltic = tic;
    float x_0 = 0, x_1 = 1, y_0 = -10, y_1 = 1;

    list<string> cmd = PlotCommandCommon1(tic, xltic);
    if (s!="")
      cmd.push_front(s);

    // GnuPlot::Debug(99);
    GnuPlot gp(cmd);
    PlotCommandCommon2(gp, x_0, x_1, y_0, y_1);

    string spec = s;
    vector<string> sv = SplitInCommas(spec);
    if (sv.empty())
      sv.push_back(istr);

    bool ok = true;
    for (size_t i=0; ok && i<sv.size(); i++)
      ok = PlotAdd(gp, r, "mar", "", sv[i]);

    return ok;
  }

///////////////////////////////////////////////////////////////////////////////

bool Analysis::PlotRP(const analyse_result& r, const string& sin,
                       const string& istr) {
  WriteLog("PlotRP(["+sin+"],["+istr+"])");

  string s = sin;

  bool full = false;
  if (s.find("full")==0) {
    full = true;
    s.erase(0, 4);
  }

  float tic = 0.1, xltic = tic;
  float x_0 = 0, x_1 = 1, y_0 = 0, y_1 = 1;

  if (s[0]=='x') {
    tic = 0.01;
    y_1 = 0.1;
    string ss = s.substr(1);
    size_t p = ss.find_first_not_of("0123456789.,", 1);
    if (p!=string::npos)
      ss.erase(p);
    vector<string> av = SplitInCommas(ss);
    if (av.size())
      y_1 = atof(av[0].c_str());
    if (av.size()>1)
      tic = atof(av[1].c_str());
    s.erase(0, 1+ss.size());
  }

  list <string> cmd = PlotCommandCommon1(tic, xltic);
  if (s!="")
    cmd.push_front(s);

  // GnuPlot::Debug(99);
  GnuPlot gp(cmd);
  PlotCommandCommon2(gp, x_0, x_1, y_0, y_1);

  string spec = s;
  vector<string> sv = SplitInCommas(spec);
  if (sv.empty())
    sv.push_back(istr);
  
  bool ok = true;
  for (size_t i=0; ok && i<sv.size(); i++)
    ok = PlotAdd(gp, r, string("rp")+(full?"full":""), "", sv[i]);

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

list<string> Analysis::PlotCommandCommon1(float tic, float xltic) const {
  list<string> cmd;

  cmd.push_back("-persist");
  if (filename!="")
    cmd.push_back(filename);

  cmd.insert(cmd.end(), gnuplot_extra.begin(), gnuplot_extra.end());
  
  // cmd.push_back("set size 500,500");
  cmd.push_back("set ytics "+ToStr(tic));
  cmd.push_back("set xtics "+ToStr(xltic));
  if (xltic!=tic) {
    cmd.push_back("set mxtics 2");
    cmd.push_back("show mxtics");
    cmd.push_back("set grid mxtics");
  }
  cmd.push_back("set size square");
  cmd.push_back("set key below left");

  return cmd;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::PlotCommandCommon2(GnuPlot& gp, float x_0, float x_1,
                                  float y_0, float y_1) const {
  stringstream ss;

  ss << "[" << x_0 << ":" << x_1 << "] [" << y_0 << ":" << y_1 << "]";
  string range = ss.str();
  gp.Range(range.c_str());

  return true;
}

///////////////////////////////////////////////////////////////////////////////

FloatPointVector Analysis::PlotVector(const vector<float>& x,
                                      const vector<float>& y,
                                      double mul) const {
  size_t l = x.size();
  if (y.size()<l)
    l = y.size();
  FloatPointVector v(l);
  for (size_t i=0; i<l; i++)
    v[i] = FloatPoint(mul*x[i], mul*y[i]);

  return v;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::PlotAdd(GnuPlot& gp, const analyse_result& r, const string& t,
                       const string& d, const string& spec) {
  bool ok = true;

  vector<string> dv = SplitInSomething(".", false, d);
  vector<string> sv = SplitInSomething(".", false, spec);

  if (!Picsom()->Quiet()) {
    cout << "t=[" << t << "] d=[" << d << "] spec=[" << spec 
	 << "] dv.size()=" << dv.size() << " sv.size()="
	 << sv.size() << endl;
  }
  
  bool dis = false, any = false;
  if (dv.size()>=sv.size()) {
    dis = true;
    for (size_t i=0; dis && !any && i<sv.size(); i++)
      if (sv[i]=="**")
        any = true;
      else if (sv[i]!="*" && sv[i]!=dv[i])
        dis = false;
    dis = any || (dis && dv.size()==sv.size());
  }

  if (!Picsom()->Quiet()) {
    cout << "[" << spec <<"] "
	 << (dis ? "DISPLAYING     " : "NOT displaying ");
    r.dump(cout, d, false, false);
  }

  if (t=="show" && !dis && spec!="" && spec!="*")
    ok = PlotShowBySpec(r, spec);

  if (dis)
    ok = PlotAddInner(gp, r, t, d);

  size_t j = 0;
  for (list<analyse_result>::const_iterator i=r.sub_result.begin();
       ok && i!=r.sub_result.end(); i++, j++) {
    stringstream ss;
    ss << d << (d!=""?".":"") << j;
    ok = PlotAdd(gp, *i, t, ss.str(), spec);
  }
  
  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::PlotAddInner(GnuPlot& gp, const analyse_result& r,
                            const string& t, const string& d) {
  if (t=="show") {
    string mstr;
    WriteAnalyseResults("Show", r, mstr, true, true, true);
    return true;
  }

  FloatPointVector v;

  if (t=="roc")
    v = PlotRocVector(r);

  else if (t=="mar")
    v = PlotMinAccRecVector(r);

  else if (t=="rp")
    v = PlotRPVector(r);

  else if (t=="rpfull")
    v = PlotRPfullVector(r);

  else
    return ShowError("PlotAddInner() : t=[", t, "] not recognized");

  string lab = r.params;
  if (lab.size()>40)
    lab = d;
  if (lab=="")
    lab = t;

  string spec;
  size_t p = lab.find('|');
  if (p!=string::npos) {
    spec = lab.substr(p+1);
    lab.erase(p);
  }

  gp.AddPlot(v, lab.c_str(), spec.size()?spec.c_str():NULL);

  return true;
}

  /////////////////////////////////////////////////////////////////////////////

  FloatPointVector Analysis::PlotRPfullVector(const analyse_result& r) const {
    bool debug = false;
    vector<float> prec(r.true_pos.size());
    if (debug)
      cout << "r.rescount=" << r.rescount << " r.tot=" << r.tot
           << " r.corr=" << r.corr << " r.bias=" << r.bias << endl;
    for (size_t i=0; i<prec.size(); i++) {
      float tp = r.true_pos[i]*(r.corr-r.bias);
      float fp = r.false_pos[i]*(r.tot-r.corr);
      prec[i] = tp/(tp+fp)*r.rescount;
      if (debug)
        cout << "i=" << i << " true_pos=" << r.true_pos[i]
             << " false_pos=" << r.false_pos[i]
             << " tp=" << tp << " fp=" << fp << " prec=" << prec[i] << endl;
    }
    return PlotVector(r.true_pos, prec, 1.0/r.rescount);
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseAjax(const vector<string>& a) {
    string err = "AnalyseAjax() : ";

    if (a.empty())
      return ShowError(err+"no arguments");

    for (size_t i=0; i<a.size(); i++) {
      string s = a[i];
      cout << err << "starting to process <" << s  << ">" << endl;

      size_t p = s.find("//text/xml");
      if (p==string::npos)
        return ShowError(err+"<"+s+"> doesn't contain \"//text/xml\"");

      s.erase(p);

      XmlDom xml = XmlDom::ReadDoc(s);
      if (!xml.DocOK())
        return ShowError(err+"failed to parse <"+s+">");

      InitializeXmlResult(true);
      XmlDom xml_root = xml_result.Root();
      query->ProcessAjaxRequest(xml, true, true);
      query->AddToXMLajaxresponse(xml_root, NULL);
      
      xml.DeleteDoc();
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseNeuraltalkTest(const vector<string>& args) {
    string err = "AnalyseNeuraltalkTest() : ";
    WriteLog("AnalyseNeuraltalkTest");

    DataBase *db = CheckDB();

    map<string,string> spec;
    spec["model"] = "r-dep3-frcnn80detP3+3SpatGaussScaleP6grRBFsun397-gaA3cA3";
    spec["init"] = "frcnn80detP3+3SpatGaussScaleP6grRBFsun397";
    spec["persist"] = "c_in14_gr_pool5_d_aA3_ca3";
    spec["beam_size"] = "5";

    bool ok = true;
    for (size_t i=0; ok && i<args.size(); i++) {
      ground_truth gt = GTExpr(args[i]);
      vector<size_t> idx = gt.indices(1);
      db->GenerateSentencesNeuralTalk(idx, spec);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSqlTest(const vector<string>&) {
    string err = "AnalyseSqlTest() : ";

    // string storemethod = "sql";
    string storemethod = "bin";

    size_t ndet = 50, nobj = 10;

    Picsom()->PossiblyShowDebugInformation("AnalyseSqlTest 0");

    for (size_t ii=CheckDB()->Size(); ii<nobj; ii++) {
      upload_object_data uod;
      uod.path = "/home/jorma/picsom/c++/girl-corel.jpg";
      uod.use = "regular";
      uod.ctype = "image/jpeg";
      list<upload_object_data> uodl;
      uodl.push_back(uod);
      list<string> empty;
      vector<string> evec;
      XmlDom xml;
      CheckDB()->InsertObjects(uodl, empty, empty, empty, false, false,
			       evec, xml, "");
    }

    Picsom()->PossiblyShowDebugInformation("AnalyseSqlTest 1");

    double xv = 0; // getpid()/10000.0;

    int dummy = 0;
    CheckDB()->Interpret("storedetections", storemethod, dummy);

    for (size_t ii=0; ii<nobj; ii++) 
      for (size_t d=0; d<3; d++) {
	const char *s = "abc";
	for (size_t c=0; c<ndet; c++) {
	  stringstream nss;
	  nss << s[d] << "#" << c;
	  string n = nss.str();
	  float v = ii/float(100)+c/float(d==0?1000:1000000)+xv;
	  if (d==2) {
	    map<string,float> detects = CheckDB()->SqlRetrieveDetectionData(ii);
	    string an = n, bn = n;
	    an.replace(0, 1, "a");
	    bn.replace(0, 1, "b");
	    float v1 = detects[an];
	    float v2 = detects[bn];
	    v = v1+v2;
	  }
	  cout << ii << " " << n << " " << v << endl;
	  bool incore = false;
	  CheckDB()->StoreDetectionResult(ii, n, v, incore);
	}
      }

    Picsom()->PossiblyShowDebugInformation("AnalyseSqlTest 2");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSqlDump(const vector<string>& a) {
    string err = "AnalyseSqlDump() : ";

    if (filename=="")
      return ShowError(err+"filename should be set");

    string lang;
    if (a.size()>0 && a[0][0]=='(' && *a[0].rbegin()==')')
      lang = a[0].substr(1, a[0].size()-2);

    bool do_pipe = true;
    if (lang.size()>3 && lang.substr(lang.size()-3)=="txt") {
      do_pipe = false;
      lang.erase(lang.size()-3);
    }

    if (lang!="mysql" && lang!="sqlite3")
      return ShowError(err+"either sqldump(mysql[txt]) or "
		       "sqldump(sqlite3[txt]) should be specified");
    
    return CheckDB()->SqlDump(lang, do_pipe, filename,
			      a.size()>1?a[1]:"", query);
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSqlFile(const vector<string>& a) {
    string err = "AnalyseSqlFile() : ";

    DataBase *db = GetDataBase();

 #ifdef HAVE_MYSQL_H
    if (!db && a.size()==0) {
      list<string> dbs = DataBase::MysqlDataBaseList(Picsom());
      cout << "MySQL databases:" << endl;
      for (list<string>::const_iterator i=dbs.begin(); i!=dbs.end(); i++)
	cout << "  mysql:" << *i << endl;
      return true;
    }

    if (db && a.size()==1 && a[0]=="deletedatabase") {
      if (db->SqlMode()!=2)
	return ShowError(err+"not in read-write SQL mode");

      if (db->MysqlMode()!=2)
	return ShowError(err+"not a MySQL database");


      string dbname = "mysql:"+db->Name();
      Picsom()->DeleteDataBase(db); // this is still only in the core...
      db = NULL;

      return DataBase::SqlDeleteDataBase(dbname, Picsom());
    }

    if (!db && a.size()==1 && a[0].find("deletedatabase=")==0) {
      string dbname = a[0].substr(15);
      return DataBase::SqlDeleteDataBase(dbname, Picsom());
    }
#endif // HAVE_MYSQL_H

    if (db && (a.size()==1 || a.size()==2) && a[0]=="list") {
      string spec = a.size()==2 ? a[1] :"";
      cout << endl;
      cout << "Files in " << db->Name() << ":" << endl;
      list<sql_file_info> fi = db->SqlFileInfoList(spec);
      for (list<sql_file_info>::const_iterator i=fi.begin(); i!=fi.end(); i++)
	cout << "   " << i->name << "  " << i->size << "  " << i->user << "  "
	     << TimeString(i->moddate) << "  " <<  TimeString(i->insdate)
	     << endl;
      cout << endl;
      return true;
    }

    if (db && a.size()==2 && a[0]=="cat") {
      string str;
      if (db->SqlRetrieveFile(a[1], str))
	cout << str << flush;

      return true;
    }

    if (db && a.size()==2 && a[0]=="delete") {
      if (!db->SqlDeleteFile(a[1]))
	return ShowError(err+"SqlDeleteFile() failed");

      return true;
    }

    if (db && a.size()==2 && a[0]=="display") {
      string data;
      if (!db->SqlRetrieveFile(a[1], data))
	return ShowError(err+"SqlRetrieveFile() failed");

      string tmpfile = Picsom()->TempDirPersonal()+"/"+a[1];
      if (!StringToFile(data, tmpfile))
	return ShowError(err+"failed to write "+ToStr(data.size())+
			 " bytes in <"+tmpfile+">");

      Picsom()->ExecuteSystem("gm display "+tmpfile, true, true, true);

      Unlink(tmpfile);
      
      return true;
    }

    if (db && a.size()==2 && a[0]=="edit") {
      string data;
      if (!db->SqlRetrieveFile(a[1], data))
	return ShowError(err+"SqlRetrieveFile() failed");

      string tmpfile = Picsom()->TempDirPersonal()+"/"+a[1];
      if (!StringToFile(data, tmpfile))
	return ShowError(err+"failed to write "+ToStr(data.size())+
			 " bytes in <"+tmpfile+">");

      string editor = "emacs";
      char *enveditor = getenv("EDITOR");
      if (enveditor && *enveditor)
	editor = enveditor;
      
      Picsom()->ExecuteSystem(editor+" "+tmpfile, true, true, true);

      string datanew = FileToString(tmpfile);

      if (datanew!="" && datanew!=data &&
	  !db->SqlStoreFileFromFile(a[1], tmpfile))
	return ShowError(err+"SqlStoreFileFromFile() failed");

      Unlink(tmpfile);
    }

    if (db && a.size()==3 && a[0]=="store") {
      if (!db->SqlStoreFileFromFile(a[2], a[1]))
	return ShowError(err+"SqlStoreFileFromFile() failed");

      return true;
    }

    if (db && a.size()==3 && a[0]=="retrieve") {
      string data;
      if (!db->SqlRetrieveFile(a[1], data))
	return ShowError(err+"SqlRetrieveFile() failed");

      if (!StringToFile(data, a[2]))
	return ShowError(err+"failed to write "+ToStr(data.size())+
			 " bytes in <"+a[2]+">");
      return true;
    }
    
    if (db && a.size()==4 && a[0]=="storesegmentation") {
      int idx = db->LabelIndex(a[2]);
      if (!db->SqlStoreSegmentationFile(idx, a[3], a[1]))
	return ShowError(err+"SqlStoreSegmentationFile() failed");

      return true;
    }

    if (db && a.size()==4 && a[0]=="retrievesegmentation") {
      int idx = db->LabelIndex(a[1]);
      if (!db->SqlRetrieveSegmentationFile(idx, a[2], a[3]))
	return ShowError(err+"SqlRetrieveSegmentationFile() failed");

      return true;
    }
    
    if (db && a.size()==1 && a[0]=="tables") {
      cout << "Tables:" << endl;
      list<sql_table_info> tl = db->SqlTableInfoList("");
      for (auto i=tl.begin(); i!=tl.end(); i++) {
	cout << "  " << i->name << " #=" << i->rows
	     << " " << i->schema
	     << endl;
	for (size_t j=0; j<i->spec.size(); j++)
	  cout << "    [" << i->spec[j].first << "]=["
	       << i->spec[j].second << "]" << endl;
      }

      return true;
    }
    
    if (db && a.size()==1 && a[0]=="aliases") {
      cout << "Aliases:" << endl;
      const map<string,string>& sa = db->SqlAliases();
      for (map<string,string>::const_iterator i=sa.begin();
	   i!=sa.end(); i++)
	cout << "  " << i->first << " = " << i->second << endl;

      return true;
    }
    
    if (db && a.size()==1 && a[0]=="version") {
      return true;
    }
    
    if (db && a.size()==1 && a[0]=="history") {
      return true;
    }
    
    return ShowError(err+"USAGE analyse=sqlfile [database=dbname] -\n"
		     "  list |\n"
		     "  store <file> <sqlname> |\n"
		     "  retrieve <sqlname> <file> |\n"
		     "  storesegmentation <file> <index> <method> |\n"
		     "  retrievesegmentation <index> <method> <file> |\n"
		     "  delete <sqlname> |\n"
		     "  cat <sqlname> |\n"
		     "  tables |\n"
		     "  aliases |\n"
		     "  version |\n"
		     "  history |\n"
#ifdef HAVE_MYSQL_H
		     "  deletedatabase=<dbname>\n"
#endif // HAVE_MYSQL_H
		     );
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSqlTables(const vector<string>& a) {
    // using picsom::DataBase::sql_table_info;

    string err = "AnalyseSqlTables() : ";

    set<string> tl(a.begin(), a.end());

    list<sql_table_info> t = GetDataBase()->SqlTableInfoList("");

    for (list<sql_table_info>::const_iterator i=t.begin(); i!=t.end(); i++)
      if (tl.empty() || tl.find(i->name)!=tl.end()) {
	cout << ">>> " << i->name << " " << i->rows << endl;
	if (verbose>1) {
	  for (auto j=i->spec.begin(); j!=i->spec.end(); j++)
	    cout << "  " << j->first << " = " << j->second << endl;
	  cout << endl;
	}
      }
  
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseSqlUpdate(const vector<string>& a) {
    string msg = "AnalyseSqlUpdate() : ";

    DataBase *db = GetDataBase();
    db->SqlBeginTransaction();

    if (a.size()) {
      bool ok = SqlUpdateOneSet(a);
      db->SqlEndTransaction();
      return ok;
    }

    WriteLog("Starting to read update instructions from stdin");
    
    for (;;) {
      string line;
      getline(cin, line);
      if (!cin)
	break;

      vector<string> vs = SplitInSpaces(line);
      if (!SqlUpdateOneSet(vs))
	return ShowError(msg+"failed with <"+line+">");
    }

    db->SqlEndTransaction(); 

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::SqlUpdateOneSet(const vector<string>& a) {
    string msg = "SqlUpdateOneSet() : ";

    DataBase *db = CheckDB();

    map<string,string> m;
    ground_truth gt(db->Size());

    for (size_t i=0; i<a.size(); i++)
      if (a[i].find('=')!=string::npos)
	m.insert(SplitKeyEqualValueNew(a[i]));
      else
	gt = gt.TernaryOR(db->GroundTruthExpression(a[i]));

    gt = gt.TernaryAND(QueryRestrictionGT());
    vector<size_t> idxs = gt.indices(1);

    WriteLog(msg+"applying "+ToStr(m.size())+" updates to "+ToStr(idxs.size())+
	     " objects");

    for (size_t i=0; i<idxs.size(); i++)
      if (!db->UpdateOriginsInfoSqlUpdate(idxs[i], m))
	return ShowError(msg+"#"+ToStr(idxs[i])+" failed");
  
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseEraseFeatures(const
							  vector<string>&) {
    string err = "AnalyseEraseFeatures() : ";

    if (!CheckDB()->UseBinFeaturesRead() || !CheckDB()->UseBinFeaturesWrite())
      return ShowError(err+"works still only with binary features");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(err+"database should be opened read-write for features");

    //ReadFiles(false);

    size_t nwas = 0, nera = 0;
    for (size_t m=0; m<Nindices(); m++) {
      VectorIndex& vi = query->vectorIndex(m);

      WriteLog("Starting to erase features ", IndexFullName(m),
               " ["+vi.FeatureTargetString()+"]");

      const string augm;
      if (!vi.BinDataOpen(true, CheckDB()->Size(), false, augm))
	return ShowError(err+"BinDataOpen() failed");

      for (size_t i=0; i<DataBaseSize(); i++)
	if (QueryRestrictionGT()[i]==1) {
	  if (CheckDB()->ObjectsTargetType(i)!=query->Target()) {
	    continue;
	  }

	  if (vi.BinDataExists(i))
	    nwas++;

	  vi.BinDataErase(i);
	  nera++;
	}

      WriteLog(IndexFullName(m)+" "+ToStr(nera)+" vectors were erased,"
	       " of which "+ToStr(nwas)+" existed");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseImportFeatures(const
							   vector<string>&) {
    string err = "AnalyseImportFeatures() : ";

    if (sourcedatabase=="")
      return ShowError(err+"sourcedatabase unspecified");

    DataBase *source = Picsom()->FindDataBase(sourcedatabase);
    if (!source)
      return ShowError(err+"sourcedatabase=<"+sourcedatabase+"> not found");

    if (!CheckDB()->UseBinFeaturesRead() || !CheckDB()->UseBinFeaturesWrite())
      return ShowError(err+"works still only with binary features");

    if (!source->UseBinFeaturesRead() || !source->UseBinFeaturesWrite())
      return ShowError(err+"works still only with binary features (source)");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(err+"database should be opened read-write for features");

    for (size_t m=0; m<Nindices(); m++) {
      VectorIndex& vi = query->vectorIndex(m);

      WriteLog("Starting to import features to ", IndexFullName(m),
               " ["+vi.FeatureTargetString()+"]");

      const string augm;
      if (!vi.BinDataOpen(true, CheckDB()->Size(), false, augm))
	return ShowError(err+"BinDataOpen() failed");

      Index *sidx = source->FindIndex(IndexFullName(m), "", true);
      if (!sidx)
	return ShowError(err+"index <"+IndexFullName(m)+"> not found in"
			 " sourcedatabase");
      
      VectorIndex *vsidx = dynamic_cast<VectorIndex*>(sidx);
      if (!vsidx)
	return ShowError(err+"index <"+IndexFullName(m)+"> cast failed");

      if (!vsidx->BinDataOpen(false, source->Size(), false, augm))
	return ShowError(err+"BinDataOpen() failed (source)");

      size_t nwas = 0, nimp = 0, nnot = 0, nnan = 0;

      for (size_t i=0; i<DataBaseSize(); i++)
	if (QueryRestrictionGT()[i]==1) {
	  if (verbose>1)
	    cout << CheckDB()->ObjectDump(i) << " ";

	  target_type ott  = CheckDB()->ObjectsTargetType(i);
	  target_type ottm = PicSOM::TargetTypeFileFullMasked(ott);
 
	  if (ottm!=query->Target()) {
	    if (verbose>1)
	      cout << "TARGET TYPES DON'T MATCH" << endl;
	    continue;
	  }

	  if (vi.BinDataExists(i)) {
	    if (verbose>1)
	      cout << "EXISTS" << endl;
	    nwas++;
	    continue;
	  }
	  const string& label = Label(i);
	  int slabelidx = source->LabelIndexGentle(label);
	  if (slabelidx<0) {
	    if (verbose>1)
	      cout << "NOT IN SOURCE" << endl;

	    nnot++;
	    continue;
	  }

	  if (verbose>1)
	    cout << " source " << source->ObjectDump(slabelidx) << " ";

	  target_type stt  = source->ObjectsTargetType(slabelidx);
	  target_type sttm = PicSOM::TargetTypeFileFullMasked(stt);
 
	  if (sttm!=query->Target()) {
	    if (verbose>1)
	      cout << "SOURCE'S TARGET TYPE DOESN'T MATCH" << endl;
	    continue;
	  }

	  FloatVector *v = vsidx->BinDataFloatVector(slabelidx);
	  if (!v) {
	    if (verbose>1)
	      cout << "NO DATA" << endl;

	    nnan++;
	    continue;
	  }
	  
	  if (!vi.BinDataStoreFeature(*v))
	    return ShowError(err+"BinDataStoreFeature() failed");
	  delete v;

	  if (verbose>1)
	    cout << "IMPORTED" << endl;

	  nimp++;
	}

      WriteLog(IndexFullName(m)+" "+ToStr(nimp)+" vectors were imported, "
	       +ToStr(nnot)+" were not found in source database, "
	       +ToStr(nnan)+" did not have feature data, "
	       +ToStr(nwas)+" existed already and were NOT OVERWRITTEN");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseImportDatFeatures(const vector<string>& args) {
    string err = "AnalyseImportDatFeatures() : ";

    if (!CheckDB()->UseBinFeaturesRead() || !CheckDB()->UseBinFeaturesWrite())
      return ShowError(err+"works still only with binary features");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(err+"database should be opened read-write for features");

    if (Nindices()!=1)
      return ShowError(err+"exactly one feature should be specified");

    size_t m = 0;
    VectorIndex& vi = query->vectorIndex(m);

    WriteLog("Starting to import features to ", IndexFullName(m),
	     " ["+vi.FeatureTargetString()+"]");

    const string augm;
    if (!vi.BinDataOpen(true, CheckDB()->Size(), false, augm))
      return ShowError(err+"BinDataOpen() failed");

    vector<string> a = args;
    
    if (a.size()==0) {
      WriteLog("Starting to read filenames from stdin");

      while (true) {
	string line;
	getline(cin, line);
	if (!cin)
	  break;
	a.push_back(line);
      }
    }

    WriteLog("About to read features from "+ToStr(a.size())+" dat files");

    size_t n = 0;
    for (auto ai=a.begin(); ai!=a.end(); ai++) {
      const string& line = *ai;
      if (FileSize(line)<1)
	return ShowError(err+"failed to open file <"+line+">");
      
      FloatVectorSet vset(line.c_str());

      for (int i=0; i<vset.Nitems(); i++) {
	const FloatVector *v = vset.Get(i);
	if (!v)
	  return ShowError(err+"failed to get data "+ToStr(i)+"/"+
			   ToStr(vset.Nitems()));
	
	int idx = CheckDB()->LabelIndexGentle(v->Label(), false);
	if (idx==-1) {
	  if (!addlabels)
	    return ShowError(err+"label <"+v->Label()+"> not found,"
			     " consider addlabels=true"
			     " insertobjectsrealinfo=false");
	  if (!CheckDB()->AddLabelAndParents(v->Label(), Target(), false))
	    return ShowError(err+"adding label <"+v->Label()+"> failed");

	  idx = CheckDB()->LabelIndex(v->Label());
	  map<string,string> oi;
	  oi["colors"] = ">256"; 
	  oi["dimensions"] = "7x8";
	  oi["checksum"] = "-";
	  int nframes = 0;
	  float framerate = 0.0;
	  XmlDom xml;
	  string dbname = v->LabelStr()+".jpeg";
	  target_type tt = Target();
	  if (!CheckDB()->InsertOriginsInfo(idx, false, "", dbname, "", "", "",
					    "", oi, "-", tt,
					    nframes, framerate, xml))
	    return ShowError(err+"InsertOriginsInfo() failed");

	  string parstr = CheckDB()->ParentObjectStringByPruning(v->Label());
	  int par = CheckDB()->LabelIndexGentle(parstr, false);
	  if (par!=-1) {
	    vector<size_t> idxv { (size_t)idx };
	    if (!CheckDB()->AppendSubobjectsFile(par, idxv))
	      return ShowError(err+"AppendSubobjectsFile() failed");
	  }

	  if (verbose>1)
	    WriteLog("  added object <"+v->LabelStr()+">");
	}

	if (!vi.BinDataStoreFeature(*v))
	  return ShowError(err+"failed to store data <"+v->Label()+">");

	n++;
      }

      if (verbose>1)
	WriteLog("Imported "+ToStr(vset.Nitems())+" feature \""
		 +IndexFullName(m)+"\" vectors from <"+line+">");
    }

    WriteLog("Imported "+ToStr(n)+" feature vectors");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseImportExternalFeatures(const vector<string>&) {
    string err = "AnalyseImportExternalFeatures() : ";

    if (!CheckDB()->UseBinFeaturesRead() || !CheckDB()->UseBinFeaturesWrite())
      return ShowError(err+"works still only with binary features");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(err+"database should be opened read-write for features");

    if (Nindices()!=1)
      return ShowError(err+"exactly one feature should be specified");

    size_t m = 0;
    VectorIndex& vi = query->vectorIndex(m);

    WriteLog("Starting to import features to ", IndexFullName(m),
	     " ["+vi.FeatureTargetString()+"]");

    const string augm;
    if (!vi.BinDataOpen(true, CheckDB()->Size(), false, augm))
      return ShowError(err+"BinDataOpen() failed");

    WriteLog(err+"starting to read filenames from stdin");

    size_t n = 0;
    while (true) {
      string line;
      getline(cin, line);
      if (!cin)
	break;

      size_t p = line.rfind('.');
      string ext = p==string::npos ? "" : line.substr(p+1);

      string txt = FileToString(line);
      if (txt=="")
	return ShowError(err+"failed to open file <"+line+">");
      
      string lab = line;
      p = lab.rfind('/');
      if (p!=string::npos)
	lab.erase(0, p+1);
      p = lab.rfind('.');
      if (p!=string::npos)
	lab.erase(p);

      lab = "0000000000"+lab;
      lab.erase(0, lab.size()-CheckDB()->LabelLength());

      int idx = CheckDB()->LabelIndexGentle(lab);
      if (idx<0)
	return ShowError(err+"failed to solve index of <"+lab+">");

      FloatVector fv;
      fv.Label(lab);

      if (ext=="txt") {
	vector<string> vstr = SplitInSomething("\n", true, txt);
	if (vstr.size()>1 && vstr.back()=="")
	  vstr.erase(vstr.begin()+vstr.size()-1);

	if (vstr.size()==0 || (vstr.size()==1 && vstr[0]==""))
	  return ShowError(err+"failed to read file <"+line+">");

	fv.Lengthen(vstr.size());
	for (size_t i=0; i<vstr.size(); i++)
	  fv[i] = atof(vstr[i].c_str());

      } else if (ext=="dat") {
	fv.Lengthen(txt.size()/sizeof(float));
	memcpy((float*)fv, &txt[0], txt.size());

      } else
	return ShowError(err+"failed to interpret file extension of <"+
			 line+">");

      if (!vi.BinDataStoreFeature(fv))
	return ShowError(err+"failed to store data for <"+lab+">");

      if (verbose>1)
	WriteLog("Imported feature \""+IndexFullName(m)+
		 "\" vector from <"+line+">");

      n++;
    }

    WriteLog("Imported "+ToStr(n)+" feature vectors");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseExportLmdbFeatures(const vector<string>& arg) {
    string err = "AnalyseExportLmdbFeatures() : ";

    if (arg.size()>1)
      return ShowError(err+"max one argument 'key_name' is needed, "
		       "defaults to 'label'");

    string key_name = "label";
    if (arg.size())
      key_name = arg[0];

    DataBase *db = CheckDB();

    for (size_t f=0; f<query->Nindices(); f++) {
      WriteLog(err, "starting <"+query->IndexFullName(f)+">");
      VectorIndex& vidx = query->IndexDataVectorIndex(f).Vectorindex();
      vidx.BinDataOpen(false, db->Size(), false, "");
      vidx.LmdbDataOpen(true, db->Size(),  true, "");
      size_t n = 0;
      for (size_t i=0; i<DataBaseSize(); i++)
	if (QueryRestrictionGT()[i]==1) {
	  FloatVector *v = vidx.BinDataFloatVector(i);
	  if (v) {
	    // v->Dump();
	    string key = db->Label(i);
	    if (key_name!="label") {
	      map<string,string> m = db->ReadOriginsInfo(i, false, true);
	      key = m[key_name];
	      if (key=="" && key_name=="subrange") { // in COCO...
		key = m["url"];
		size_t p = key.find('[');
		if (p!=string::npos)
		  key.erase(0, p+1);
		p = key.find(']');
		if (p!=string::npos)
		  key.erase(p);
	      }
	    }
	    if (key=="")
	      return ShowError(err+"empty key for <"+db->Label(i)+">");
	    vidx.LmdbDataStoreFeature(*v, key);
	    delete v;
	    n++;
	  }
	}
      WriteLog(err, "copied "+ToStr(n)+" <"+query->IndexFullName(f)+
	       "> vectors with '"+key_name+"' as keys");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCreateDummyFeatures(const vector<string>&) {
    string err = "AnalyseCreateDummyFeatures() : ";

    if (!CheckDB()->UseBinFeaturesRead() || !CheckDB()->UseBinFeaturesWrite())
      return ShowError(err+"works still only with binary features");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(err+"database should be opened read-write for features");

    if (Nindices()!=1)
      return ShowError(err+"exactly one feature should be specified");

    size_t m = 0;
    VectorIndex& vi = query->vectorIndex(m);

    WriteLog("Starting to create dummy features based on ", IndexFullName(m),
	     " ["+vi.FeatureTargetString()+"]");

    const string augm;
    if (!vi.BinDataOpen(true, CheckDB()->Size(), false, augm))
      return ShowError(err+"BinDataOpen() failed");

    Index *dummy1 = CheckDB()->FindIndex("dummy", "", true);
    if (!dummy1)
      return ShowError(err+"BinDataOpen() failed to get pointer to dummy");

    VectorIndex *dummy = dynamic_cast<VectorIndex*>(dummy1);
    if (!dummy)
      return ShowError(err+"BinDataOpen() failed to get VectorIndex* dummy");

    vector<float> dv(1);
    dv[0] = 7;

    size_t nno = 0, nyes = 0;
    for (size_t i=0; i<CheckDB()->Size(); i++) {
      bool exists = vi.BinDataExists(i); // or BinDataFullTest(i)
      if (verbose>1)
	cout << CheckDB()->ObjectDump(i) << " : "
	     << (exists?"EXISTS":"doesn't exist") << endl;
      if (exists) {
	dummy->BinDataStoreFeature(i, dv);
	nyes++;
      } else {
	dummy->BinDataErase(i);
	nno++;
      }
    }

    WriteLog(ToStr(nyes)+" feature vectors existed, "+ToStr(nno)+
	     " did not exist");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseEraseDetections(const
							    vector<string>&) {
    string err = "AnalyseEraseDetections() : ";

    return ShowError(err+"not implemented yet");

    /*
    if (!CheckDB()->UseBinDetectionsRead() || !
         CheckDB()->UseBinDetectionsWrite())
      return ShowError(err+"works still only with binary detections");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(err+"database should be opened read-write for detections");

    //ReadFiles(false);

    size_t nwas = 0, nera = 0;
    for (size_t m=0; m<Nindices(); m++) {
      VectorIndex& vi = query->vectorIndex(m);

      WriteLog("Starting to erase detections ", IndexFullName(m),
               " ["+vi.DetectionTargetString()+"]");

      if (!vi.BinDataOpen(true, CheckDB()->Size(), false))
	return ShowError(err+"BinDataOpen() failed");

      for (size_t i=0; i<DataBaseSize(); i++)
	if (QueryRestrictionGT()[i]==1) {
	  if (CheckDB()->ObjectsTargetType(i)!=query->Target()) {
	    continue;
	  }

	  if (vi.BinDataExists(i))
	    nwas++;

	  vi.BinDataErase(i);
	  nera++;
	}

      WriteLog(IndexFullName(m)+" "+ToStr(nera)+" vectors were erased,"
	       " of which "+ToStr(nwas)+" existed");
    }

    return true;
    */
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseImportDetections(const
							     vector<string>&) {
    string err = "AnalyseImportDetections() : ";

    return ShowError(err+"not implemented yet");

    /*
    if (sourcedatabase=="")
      return ShowError(err+"sourcedatabase unspecified");

    DataBase *source = Picsom()->FindDataBase(sourcedatabase);
    if (!source)
      return ShowError(err+"sourcedatabase=<"+sourcedatabase+"> not found");

    if (!CheckDB()->UseBinDetectionsRead() || !CheckDB()->UseBinDetectionsWrite())
      return ShowError(err+"works still only with binary detections");

    if (!source->UseBinDetectionsRead() || !source->UseBinDetectionsWrite())
      return ShowError(err+"works still only with binary detections (source)");

    if (!CheckDB()->OpenReadWriteFea())
      return ShowError(err+"database should be opened read-write for detections");

    for (size_t m=0; m<Nindices(); m++) {
      VectorIndex& vi = query->vectorIndex(m);

      WriteLog("Starting to import detections to ", IndexFullName(m),
               " ["+vi.DetectionTargetString()+"]");

      if (!vi.BinDataOpen(true, CheckDB()->Size(), false))
	return ShowError(err+"BinDataOpen() failed");

      Index *sidx = source->FindIndex(IndexFullName(m), "", true);
      if (!sidx)
	return ShowError(err+"index <"+IndexFullName(m)+"> not found in"
			 " sourcedatabase");
      
      VectorIndex *vsidx = dynamic_cast<VectorIndex*>(sidx);
      if (!vsidx)
	return ShowError(err+"index <"+IndexFullName(m)+"> cast failed");

      if (!vsidx->BinDataOpen(false, source->Size(), false))
	return ShowError(err+"BinDataOpen() failed (source)");

      size_t nwas = 0, nimp = 0, nnot = 0, nnan = 0;

      for (size_t i=0; i<DataBaseSize(); i++)
	if (QueryRestrictionGT()[i]==1) {
	  if (verbose>1)
	    cout << CheckDB()->ObjectDump(i) << " ";

	  target_type ott  = CheckDB()->ObjectsTargetType(i);
	  target_type ottm = PicSOM::TargetTypeFileFullMasked(ott);
 
	  if (ottm!=query->Target()) {
	    if (verbose>1)
	      cout << "TARGET TYPES DON'T MATCH" << endl;
	    continue;
	  }

	  if (vi.BinDataExists(i)) {
	    if (verbose>1)
	      cout << "EXISTS" << endl;
	    nwas++;
	    continue;
	  }
	  const string& label = Label(i);
	  int slabelidx = source->LabelIndexGentle(label);
	  if (slabelidx<0) {
	    if (verbose>1)
	      cout << "NOT IN SOURCE" << endl;

	    nnot++;
	    continue;
	  }

	  if (verbose>1)
	    cout << " source " << source->ObjectDump(slabelidx) << " ";

	  target_type stt  = source->ObjectsTargetType(slabelidx);
	  target_type sttm = PicSOM::TargetTypeFileFullMasked(stt);
 
	  if (sttm!=query->Target()) {
	    if (verbose>1)
	      cout << "SOURCE'S TARGET TYPE DOESN'T MATCH" << endl;
	    continue;
	  }

	  FloatVector *v = vsidx->BinDataFloatVector(slabelidx);
	  if (!v) {
	    if (verbose>1)
	      cout << "NO DATA" << endl;

	    nnan++;
	    continue;
	  }
	  
	  if (!vi.BinDataStoreDetection(*v))
	    return ShowError(err+"BinDataStoreDetection() failed");
	  delete v;

	  if (verbose>1)
	    cout << "IMPORTED" << endl;

	  nimp++;
	}

      WriteLog(IndexFullName(m)+" "+ToStr(nimp)+" vectors were imported, "
	       +ToStr(nnot)+" were not found in source database, "
	       +ToStr(nnan)+" did not have detection data, "
	       +ToStr(nwas)+" existed already and were NOT OVERWRITTEN");
    }

    return true;
    */
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseImportExternalDetections(const vector<string>& args) {
    string err = "AnalyseImportExternalDetections() : ";

    if (!CheckDB()->OpenReadWriteDet())
      return ShowError(err+
		       "database should be opened read-write for detections");

    if (detections.size()!=1)
      return ShowError(err+"exactly one detection should be specified");

    string fname;
    if (args.size()!=1 || !FileExists(fname = args[0]))
      return ShowError(err+"exactly one file name should be given as argument");

    WriteLog("Starting to import detections from <"+fname+"> to <"
	     +detections.front()+">");

    // obs! should we erase existing detections?  currently just adding new
    
    size_t n = 0;
    ifstream in(fname);
    for (;;) {
      string line, label;
      getline(in, line);
      if (!in)
	break;

      if (line[0]=='#')
	continue;
      
      istringstream ss(line);
      float val = -1;
      ss >> val >> label;

      int idx = CheckDB()->LabelIndex(label);
      if (idx<0)
	return ShowError(err+"LabelIndex("+label+") failed");
      
      if (val<0 || val>1)
	return ShowError(err+"detection value out of bounds in <"+line+">");

      bool incore = false;
      if (!CheckDB()->StoreDetectionResult(idx, detections.front(), val, incore))
	return ShowError(err+"storing detection value failed for <"+line+">");

      n++;
    }

    WriteLog("Imported "+ToStr(n)+" detection values in "+detections.front());

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseExportWadm(const vector<string>& args) {
    string err = "AnalyseExportWadm() : ";

    string textindex = GetQuery()->TextIndex();
    if ((detections.size()==0 && textindex=="") || detections.size()>1 ||
	(detections.size() && textindex!=""))
      return ShowError(err+"exactly one detection or textindex "
		       "should be specified");

    if (args.size()!=2)
      return ShowError(err+"expected arguments: output_file_name baseurl");

    string fname = args[0];
    string url   = args[1];

    DataBase *db = CheckDB();
    vector<size_t> idxs = QueryRestrictionGT().indices(1);

    WriteLog("Starting to export textindex <"+textindex+"> to <"+fname+">");

    size_t n = 0;
#if defined(HAVE_JSON_JSON_H)
    Json::Value doc;
    for (auto& i : idxs) {
      size_t t = i;
      if (db->ObjectsTargetTypeContains(i, target_video))
	t = db->VideoOrSegmentMiddleFrame(i).first;

      textline_t tl = db->TextIndexLine(textindex, "text", t);
      // cout << tl.str(true, true) << endl;

      map<string,string> m = db->ReadOriginsInfo(i, false, true);
      string target = m["auxid"];
      if (target=="") {
	size_t p = db->RootParent(i);
	map<string,string> mp = db->ReadOriginsInfo(p, false, true);
	target = mp["auxid"];
      }
      if (target=="")
	target = "http://example.com/"+db->Label(i);
      
      if (db->ObjectsTargetTypeContains(i, target_videosegment)) {
	double start = tl.start, end =tl.end;
	if (start<0) {
	  auto psd = db->ParentStartDuration(i, target_videofile);
	  start = psd.second.first;
	  end   = start+psd.second.second;
	}
	target += "#t="+ToStr(start)+","+ToStr(end);
      }

      Json::Value body;
      body["type"]     = "TextualBody";
      body["value"]    = tl.txt_val[0].first;
      body["format"]   = "text/plain";
      body["language"] = "en";

      Json::Value item;
      item["@context"] = "http://www.w3.org/ns/anno.jsonld";
      item["id"]       = url+textindex+"/"+db->Label(i);
      item["body"]     = body;
      item["target"]   = target;
      doc.append(item);
      n++;
    }
    //ofstream(fname) << doc;
    ofstream(fname) << Json::FastWriter().write(doc);
    WriteLog("Exported "+ToStr(n)+" textindex <"+textindex+"> lines to <"
	     +fname+">");
#else
    WriteLog("No JSON library available to write <"+fname+">");
#endif // HAVE_JSON_JSON_H

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseImportBinData(const vector<string>& args) {
    string err = "AnalyseImportBinData() : ";

    string fnamein;

    if (args.size()!=2 || !FileExists(fnamein = args[0]))
      return ShowError(err+"arguments should be: file.dat file.bin");

    DataBase *db = CheckDB();

    string fnameout = args[1];
    bin_data::header::format_type fmt = bin_data::header::format_size_t;
    size_t fmt_mul = 8;
    bin_data out;

    WriteLog("Starting to vector data from <"+fnamein+"> to <"
	     +fnameout+">");

    size_t n = 0, vl = 0;
    ifstream in(fnamein);
    for (;;) {
      string line;
      getline(in, line);
      if (!in)
	break;

      if (line[0]=='#')
	continue;
      
      if (vl==0) {
	vl = atoi(line.c_str());
	out.open(fnameout, true, fmt, fmt_mul*vl, vl);
	out.resize(db->Size());
	continue;
      }

      size_t p = line.rfind(' ');
      if (p==string::npos)
	return ShowError(err+"no space found");

      string label = line.substr(p+1);
      line.erase(p);
      IntVector v;
      v.ValueFromString(line);

      int idx = db->LabelIndex(label);
      if (idx<0)
	return ShowError(err+"LabelIndex("+label+") failed");

      vector<size_t> vs(vl);
      for (size_t j=0; j<vl; j++)
	vs[j] = v[j];

      out.set_size_t((size_t)idx, vs);
      
      n++;
    }

    WriteLog("Imported "+ToStr(n)+" bin vectors in <"+fnameout+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseBinDataTest(const vector<string>& a) {
    string msg = "Analysis::AnalyseBinDataTest() : ";

    size_t l = 100, n = 100;
    if (a.size())
      n = atoi(a[0].c_str());
    if (a.size()>1)
      l = atoi(a[1].c_str());

    string f = "test.bin";
    Unlink(f);

    bin_data b(f, true,  bin_data::header::format_float, 4*l, l);
    for (size_t i=0; i<n; i++) {
      vector<float> v(l);
      for (size_t j=0; j<l; j++)
	v[j] = i+float(j)/l;
      b.resize(i+1);
      b.set_float(i, v);
    }
      
    bool ok = true;
    for (size_t i=0; i<n; i++) {
      vector<float> v = b.get_float(i);
      for (size_t j=0; j<l; j++)
	if (v[j]!= i+float(j)/l) {
	  cout << "ERROR i=" << i << " j=" << j << endl;
	  ok = false;
	}
    }

    if (ok)
      WriteLog(msg+"Successfully wrote and read "+ToStr(n)+
	       " vectors of dimensionality "+ToStr(l));

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseBinData(const vector<string>& a) {
    string msg = "Analysis::AnalyseBinData() : ";

    if (a.size()<1)
      return ShowError(msg+"<file.bin> argument missing");

    vector<string> fa = SplitInCommas(a[0]);
    while (fa.size()<5)
      fa.push_back("0");

    bin_data d(fa[0], atoi(fa[1].c_str()),
	       bin_data::header::format_type(atoi(fa[2].c_str())),
	       atoi(fa[3].c_str()), atoi(fa[4].c_str()));

    cout << fa[0] << " : " << d.str() << endl;

    bool strings = false;

    for (size_t i=1; i<a.size(); i++) {
      string s = a[i], cmd;
      size_t p = s.find('(');
      if (p!=string::npos)
	cmd = s.substr(0, p);

      if (cmd=="strings") {
	strings = true;
	continue;
      }

      if (cmd=="get_float" || cmd=="get_bool" || cmd=="get_size_t" ||
	  cmd=="get_string" || cmd=="resize") {
	size_t idx = atoi(s.substr(p+1).c_str());

	if (cmd=="get_float") {
	  vector<float> v = d.get_float(idx);
	  for (size_t j=0; j<v.size(); j++)
	    cout << (j?" ":"") << v[j];
	  cout << endl;
	}
	if (cmd=="get_bool") {
	  vector<bool> v = d.get_bool(idx);
	  for (size_t j=0; j<v.size(); j++)
	    cout << (j?" ":"") << v[j];
	  cout << endl;
	}
	if (cmd=="get_size_t") {
	  vector<size_t> v = d.get_size_t(idx);
	  for (size_t j=0; j<v.size(); j++)
	    cout << (j?" ":"") << v[j];
	  cout << endl;
	}
	if (cmd=="get_string") {
	  string v = d.get_string(idx);
	  if (strings)
	    cout << "\"" << v << "\" ";
	  stringstream ss;
	  ss << hex;
	  for (size_t j=0; j<v.size(); j++)
	    ss << (j?" ":"") << "0x" << (int)(unsigned char)v[j];
	  cout << ss.str() << endl;
	}
	if (cmd=="resize") {
	  d.resize(idx);
	}
	continue;
      }

      return ShowError(msg+"command \""+cmd+"\" not understood");
    }

    cout << fa[0] << " : " << d.str() << endl;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseBinDump(const vector<string>&) {
    float version = 1.0;

    bool debug = verbose>1;
    string err = "AnalyseBinDump() : ";

    bool check_most_auth = false;

    DataBase* db = CheckDB();

    bool ok = true;

    for (size_t m=0; m<Nindices(); m++) {
      VectorIndex& vi = CheckQuery()->vectorIndex(m);

      WriteLog("Starting to create bin dump for ", IndexFullName(m),
               " ["+vi.FeatureTargetString()+"]");

      if (debug)
        cout << "Determining vector length ... ";

      int len = 0;
      for (size_t i=0; i<db->Size() && len <= 0; i++) {
        string datfile = db->MostAuthoritativeDataFile(i, &vi);
        if (datfile.empty())
          continue;
        FloatVectorSet data(datfile.c_str());
        len = data.VectorLength();
      }

      if (!len)
        return ShowError(err+"unable to find a single datafile from which to "
                         "determine vector length.");

      if (debug)
        cout << len << endl;

      ios_base::openmode mode = ios_base::out;

      string oname = IndexFullName(m)+".bin";
      bool exists = FileExists(oname);

      if (version>0.0 && exists)
	return ShowError(err+"after version 0.0 appending PSBD files has "
			 "not been supported");

      string infostr;

      size_t filesize = 0, filevecs = 0;
      if (exists) { // so we have version=0.0...
	float vlenf = 0.0;
	ifstream in(oname);
	in.read((char*)&vlenf, sizeof(float));
	in.close();
	int filevlen = vlenf;
	if (!filevlen)
	  return ShowError(err+"file <"+oname+"> exist, but non-zero "
			   "vector length could not be read.");
	if (filevlen!=len)
	  return ShowError(err+"vector lengths "+ToStr(len)+" and "+
			   ToStr(filevlen)+" from <"+oname+"> differ.");

	filesize = FileSize(oname);
	filevecs = (filesize-sizeof(float))/(len*sizeof(float));
	if ((filevecs*len+1)*sizeof(float)!=filesize)
	  return ShowError(err+"file size "+ToStr(filesize)+" of <"+
			   oname+"> doesn't match with vector length "+
			   ToStr(len)+".");

	if (filevecs>db->Size())
	  return ShowError(err+"file <"+oname+"> already contains "+
			   ToStr(filevecs)+" vectors which exceed the size "+
			   ToStr(db->Size())+" of the database.");

	mode |= ios_base::app;

	WriteLog("File <"+oname+"> exists in "+ToStr(filesize)+
		 " bytes and consist probably of "+ToStr(filevecs)+
		 " vectors of dimension "+ToStr(len)+".");
	if (filevecs)
	  WriteLog("Last vector possibly corresponds to "+
		   db->ObjectDump(filevecs-1));
      }

      WriteLog("About to "+string(exists?"append":"write")+" "+
	       ToStr(db->Size()-filevecs)+" vectors of dimension "+
	       ToStr(len)+".");

      size_t hdrsize = sizeof(float); // in version=0.0

      if (db->Size()>filevecs) {
	WriteLog("First vector corresponds to "+db->ObjectDump(filevecs));
	WriteLog("Last  vector corresponds to "+db->ObjectDump(db->Size()-1));

	ofstream out(oname.c_str(), mode);

	if (!exists) {
	  float flen = len;
	  if (version==0.0)
	    out.write((char*)&flen, hdrsize);
	  else {
	    bin_data::header info;
	    info.rlength = sizeof(float)*len;
	    info.vdim = len;
	    info.format = bin_data::header::format_float;
	    hdrsize = sizeof(info);
	    out.write((char*)&info, hdrsize);
	    infostr = info.str();
	  }
	}

	FloatVector zero(len), nan(len);
	memset((char*)(float*)nan, 255, len*sizeof(float));
	const FloatVector& fill = version==0.0 ? zero : nan;
	FloatVectorSet *data = NULL;
	string current_datfile = "";

	ProgressBar pb((db->Size()-filevecs)/100+1, 60, err);

	size_t n = 0;
	for (size_t i=filevecs; i<db->Size(); i++) {
	  const FloatVector *v = vi.GetDataFromFile(i, data, current_datfile,
						    check_most_auth);

	  if (!v) {
	    v = &fill;
	    if (db->ObjectsTargetType(i) & vi.FeatureTarget())
	      cout <<  "WARNING: No data for " << Label(i) 
		   << " [" << TargetTypeString(db->ObjectsTargetType(i)) << "]"
		   << endl;

	  } else if (data->VectorLength()!=len) {
	    v = &fill;
	    if (db->ObjectsTargetType(i) & vi.FeatureTarget())
	      cout <<  "WARNING: vector length of " << Label(i) 
		   << " [" << TargetTypeString(db->ObjectsTargetType(i))
		   << "] " << data->VectorLength() << "!=" << len
		   << endl;
	  } else
	    n++;

	  out.write((char*)(float*)*v, len*sizeof(float));

	  if ((i-filevecs)%100==0)
	    pb.Inc();
	}

	out.close();
      
	delete data;
      
	cout << endl;

	off_t corrsize = sizeof(float)*db->Size()*len+hdrsize;
	off_t fsize = FileSize(oname);

	if (fsize==corrsize) {
	  WriteLog("Wrote ", ToStr(fsize-filesize), " bytes in <"+
		   oname+"> from "+ToStr(db->Size()-filevecs)+
		   " total and "+ToStr(n)+" genuine vectors\n  resulting to "+
		   ToStr(fsize)+" bytes including "+ToStr(hdrsize)+
		   " bytes of header version "+ToStr(version));
	  if (infostr!="")
	    WriteLog("  "+infostr);

	} else
	  ok = ShowError(err, "Wrote only "+ToStr(fsize-filesize)
			 +" of "+ToStr(corrsize)+" bytes in <"+oname+">");
      }
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCOCOmasks(const vector<string>& argv) {
    string err = "AnalyseCOCOmasks() : ";

    bool debug_m = verbose>1;
    bool debug_i = verbose>1;
    bool debug_v = verbose>1;

    if (mapgrid=="")
      return ShowError(err, "mapgrid should be defined");

    if (classname=="")
      return ShowError(err, "class should be defined");

    bool unitnorm = false, iunorm = false;
    string mg = mapgrid;
    if (mg[0]=='n' || mg[0]=='i') {
      unitnorm = mg[0]=='n';
      iunorm   = mg[0]=='i';
      mg.erase(0, 1);
    }
    size_t yn = 0, xn = 0;
    if (sscanf(mg.c_str(), "%zdx%zd", &xn, &yn)!=2)
      return ShowError(err, "mapgrid should be WxH or nWxH or iWxH");

    DataBase *db = CheckDB();
    list<string> classes = db->SplitClassNames(classname);

    for (size_t i=0; i<argv.size(); i++) {
      vector<size_t> idxs = db->GroundTruthExpression(argv[i]).indices(1);
      for (auto idx=idxs.begin(); idx!=idxs.end(); idx++) {
	if (debug_m) {
#ifdef HAVE_JSON_JSON_H
	  auto r = db->COCOmasks(*idx);
	  for (auto j=r.begin(); j!=r.end(); j++) {
	    auto& e = *j;
	    cout << "#" << *idx << " [" << e.first << "]";
	    for (auto k=e.second.begin(); k!=e.second.end(); k++) {
	      cout << " [";
	      for (auto l=k->begin(); l!=k->end(); l++)
		cout << " " << l->first << "," << l->second;
	      cout << " ]";
	    }
	    cout << endl;
	  }
#else
	  ShowError(err+"HAVE_JSON_JSON_H undef");
#endif // HAVE_JSON_JSON_H
	}

	map<string,vector<float> > comp;
	list<pair<string,imagedata> > m = db->ObjectMasksCombined(*idx);
	for (auto mi=m.begin(); mi!=m.end(); mi++) {
	  if (debug_i) {
	    string f = mi->first+"-"+db->Label(*idx)+".png";
	    imagefile::write(mi->second, f);
	    WriteLog(err+"wrote file <"+f+">");
	  }

	  size_t w = mi->second.width(), h = mi->second.height();
	  imagedata count(xn , yn, 1, imagedata::pixeldata_uint32), area = count;
	  size_t total = 0;
	  for (size_t x=0; x<xn; x++)
	    for (size_t y=0; y<yn; y++) {
	      size_t n = 0, a = 0;
	      for (size_t xi=x*w/xn; xi<(x+1)*w/xn; xi++)
		for (size_t yi=y*h/yn; yi<(y+1)*h/yn; yi++, a++)
		  if (mi->second.get_one_uchar(xi, yi))
		    n++;
	      count.set(x, y, (uint32_t)n);
	      area. set(x, y, (uint32_t)a);
	      total += n;
	    }

	  vector<float> v;
	  if (debug_v)
	    cout << db->Label(*idx) << " <" << mi->first << ">";
	  for (size_t y=0; y<yn; y++)
	    for (size_t x=0; x<xn; x++) {
	      float r = count.get_one_uint32(x, y);
	      float a = area. get_one_uint32(x, y);
	      float z = r ? ( unitnorm ? r/total : r/a) : 0;
	      if (iunorm && r)
		z = r/(a+total-r);
	      v.push_back(z);
	      if (debug_v)
		cout << " " << z;
	    }
	  comp[mi->first] = v;
	  if (debug_v)
	    cout << endl;
	}
	
	vector<float> v, empty(xn*yn);
	for (auto c=classes.begin(); c!=classes.end(); c++)
	  if (comp.find(*c)!=comp.end())
	    v.insert(v.end(), comp[*c].begin(), comp[*c].end());
	  else
	    v.insert(v.end(), empty.begin(), empty.end());

	cout << "ZZZ";
	for (auto q=v.begin(); q!=v.end(); q++)
	  cout << " " << *q;
	cout << " " << db->Label(*idx) << endl;
	
      }
    } 

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseMaskedDetection(const vector<string>& argv) {
    string err = "AnalyseMaskedDetection() : ";

    if (mapgrid=="")
      return ShowError(err, "mapgrid should be defined");

    if (classname=="")
      return ShowError(err, "class should be defined");

    size_t yn = 0, xn = 0;
    if (sscanf(mapgrid.c_str(), "%zdx%zd", &xn, &yn)!=2)
      return ShowError(err, "mapgrid should be WxH");

    size_t maxcomp = 100;
    bool use_pos = false, use_gauss = false;
    bool show_features = verbose>3, show_detections = verbose>1;
    bool store_masked_images = verbose>2, store_response_images = verbose>1;

    if (detections.size()==0 || detections.size()>2)
      return ShowError(err, "one or two detections should be specified");

    // if (!argv.size())
    //   return ShowError(err, "You must give at least one label/index/"
    //                    "filename as argument");

    // double mul = 80;
    vector<float> grey { 0.5, 0.5, 0.5 };    

    typedef struct {
      bool neg;
      size_t x, y;
      double x0, x1, y0, y1;
      string name;
    } area_t;

    list<area_t> area;
    area_t f = { true, (size_t)-1, (size_t)-1, 0, 0, 0, 0, "" };
    area.push_back(f);
    f.neg  = false;
    f.name = "/grey";
    if (use_pos)
      area.push_back(f);
    for (size_t y=0; y<yn; y++)
      for (size_t x=0; x<xn; x++) {
	stringstream n;
	n << y << ":" << x;
	string nss = n.str();
	area_t a1 = { true, x, y,
		      (x+0.0)/xn, (x+1.0)/xn, (y+0.0)/yn, (y+1.0)/yn,
		      "/neg:"+nss };
	area_t a2 = { true, x, y,
		      (x-1.0)/xn, (x+2.0)/xn, (y-1.0)/yn, (y+2.0)/yn,
		      "/neg:"+nss };
	area_t a = use_gauss ? a2 : a1;
	area.push_back(a);
	a.neg  = false;
	a.name = "/pos:"+nss;
	if (use_pos)
	  area.push_back(a);
      }

    DataBase* db = CheckDB();

    // size_t dcount = 0;
    string type = "picsom::imagedata*";
    
    list<pair<int,imagedata> > idatalist;

    // map<string,string> identmap;
    // map<string,imagedata> idatamap;
    // list<incore_feature_t> incore;
    for (size_t i=0; i<argv.size(); i++) {
      const string& arg = argv[i];

      if (FileExists(arg)) {
	imagedata data = imagefile(arg).frame(0);
	idatalist.push_back(make_pair(-1, data));
	continue;
      }

      ground_truth gt = db->GroundTruthExpression(arg);
      vector<size_t> idxs = gt.indices(1);
      if (!idxs.size())
	return ShowError(err+"<"+arg+"> is neither a class nor filename");
      for (auto j=idxs.begin(); j!=idxs.end(); j++) {
	imagedata data = db->ImageData(*j);
	idatalist.push_back(make_pair(*j, data));
      }
    }

    if (idatalist.empty()) {
      vector<size_t> idxs = QueryRestrictionGT().indices(1);
      for (auto j=idxs.begin(); j!=idxs.end(); j++) {
	imagedata data = db->ImageData(*j);
	idatalist.push_back(make_pair(*j, data));
      }
    }      

    WriteLog(err+"starting with "+ToStr(idatalist.size())+" images");

    list<string> classes = db->SplitClassNames(classname);

    size_t iii = 0, label_i = 0, iwidth = 0, iheight = 0;
    for (auto i=idatalist.begin(); i!=idatalist.end(); i++, iii++) {
      map<string,vector<float> > feamap;
      list<imagedata> ilist;

      string label = i->first>=0 ? db->Label(i->first) : ToStr(label_i++);

      string det = detections[0];
      size_t p = det.find("::");
      if (p==string::npos)
	return ShowError(err+"no :: found 1");
      size_t q = det.find("::", p+2);
      if (q==string::npos)
	return ShowError(err+"no :: found 2");
      size_t r = det.find("::", q+2);
      if (r==string::npos)
	return ShowError(err+"no :: found 3");
      size_t s = det.find("::", r+2);
      // if (s==string::npos)
      //   return ShowError(err+"no :: found 4");

      string pre = det.substr(0, p);
      string opt = det.substr(q+2, r-q-2);
      string xtr = s!=string::npos ? det.substr(r+2, s-r-2) : "";

      string fea = det.substr(p+2, q-p-2);
	
      list<incore_feature_t> incore_set;

      for (auto a=area.begin(); a!=area.end(); a++) {
	string fea_area = fea+a->name;

	if (feamap.find(fea_area)==feamap.end()) {
	  imagedata img(i->second);
	  iwidth  = img.width();
	  iheight = img.height();
	  if (!use_gauss) {
	    size_t x0 = img.width()*a->x0;
	    size_t x1 = img.width()*a->x1;
	    size_t y0 = img.height()*a->y0;
	    size_t y1 = img.height()*a->y1;
	    for (size_t x=0; x<img.width(); x++)
	      for (size_t y=0; y<img.height(); y++)
		if (( a->neg &&   x>=x0 && x<x1  && y>=y0 && y<y1) ||
		    (!a->neg && ( x<x0  || x>=x1 || y<y0  || y>=y1)))
		  img.set(x, y, grey);
	  } else {
	    int x0 = img.width()*a->x0;
	    int x1 = img.width()*a->x1;
	    int y0 = img.height()*a->y0;
	    int y1 = img.height()*a->y1;
	    float xc = (x0+x1)/2.0, yc = (y0+y1)/2.0;
	    float bx = 6.0*sqrt(log(2))/(x1-x0);
	    float by = 6.0*sqrt(log(2))/(y1-y0);
	    for (int x=0; x<(int)img.width(); x++)
	      for (int y=0; y<(int)img.height(); y++)
		if (!a->neg && ( x<x0  || x>=x1 || y<y0  || y>=y1))
		  img.set(x, y, grey);
		else if (x>=x0 && x<x1  && y>=y0 && y<y1) {
		  vector<float> blend = img.get_float(x, y);
		  float xd = bx*(x-xc), yd = by*(y-yc);
		  float m = exp(-(xd*xd+yd*yd));
		  for (size_t c=0; c<3; c++)
		    blend[c] = a->neg ? m*grey[c]+(1-m)*blend[c]
		      :             (1-m)*grey[c]+    m*blend[c];
		  img.set(x, y, blend);
		}
	  }
 
	  // imagefile::display(img);
	  if (store_masked_images) {
	    string ss = a->name;
	    size_t p = ss.find('/');
	    if (p!=string::npos)
	      ss[p] = '-';
	    if (ss[0]=='-')
	      ss.erase(0, 1);
	    string l = label+"-"+ss;
	    imagefile::write(img, "masked-"+l+".png");
	  }

	  ilist.push_back(img);
	  stringstream ss;
	  ss << (void*)&*ilist.rbegin();
	  string ident = ss.str();
	  incore_set.push_back(make_pair(make_pair(type, ident),
					 vector<float>()));
	}
      }

      if (incore_set.size()) {
	CheckQuery()->UnselectIndices(NULL, true);
	CheckQuery()->SelectIndex(NULL, fea, true);
	VectorIndex& vi = CheckQuery()->vectorIndex(0);

	vector<size_t> idx;
	set<string> done_segm;
	XmlDom xml;
	vi.CalculateFeatures(idx, incore_set, done_segm, xml, NULL);

	auto ici = incore_set.begin();
	for (auto a=area.begin(); a!=area.end(); a++, ici++) {
	  string fea_area = fea+a->name;

	  if (show_features) {
	    cout << fea_area;
	    for (size_t j=0; (maxcomp==0 || j<maxcomp)
		   && j<ici->second.size(); j++)
	      cout << " " << ici->second[j];
	    cout << endl;
	  }

	  feamap[fea_area] = ici->second;
	}
      }

      vector<float> locmapvec;

      size_t ci = 0;
      for (auto c=classes.begin(); c!=classes.end(); c++, ci++) {
	if (!db->HasSVM(pre, fea, opt, xtr, *c, "")) {
	  list<pair<string,string> > kv;
	  kv.push_back(make_pair("${feat}",       fea));
	  kv.push_back(make_pair("${cname}",      *c));
	  kv.push_back(make_pair("${inst}",       ""));
	  kv.push_back(make_pair("${instsep}",    ""));
	  kv.push_back(make_pair("${svmlibrary}", pre));
	  kv.push_back(make_pair("${svmopts}",    opt));
	  kv.push_back(make_pair("${svmextra}",   xtr));
	  kv.push_back(make_pair("verbose",       "0"));
	      
	  if (!db->SvmCommon(kv))
	    return ShowError(err+"create step failed");
	}
	SVM *svm = db->GetSVM(pre, fea, opt, xtr, *c, "", "");
	while (!svm->IsReady()) {
	  struct timespec ts = { 0, 1000000 }; // 1 millisecond
	  nanosleep(&ts, NULL);
	}
	// svm->ShowAllNames();

	double val0 = 0, minn = 1.0, maxn = 0.0;
	double valg = 0, minp = 1.0, maxp = 0.0;
	map<pair<size_t,size_t>,double> valmapn, valmapp;
	for (auto a=area.begin(); a!=area.end(); a++) {
	  string fea_area = fea+a->name;
	  string predict_str = "no";
	  int n = 0;
	  const vector<float>& fv = feamap[fea_area];
	  FloatVector vec(fv.size(), &fv[0]);
	  double val = svm->PredictProb(vec, predict_str, n);
	  if (show_detections)
	    cout << label << " " << fea_area << " " << det << "#" << *c
		 << " = " << val << endl;

	  if (a->x!=(size_t)-1 && a->y!=(size_t)-1) {
	    if (a->neg)
	      valmapn[make_pair(a->x, a->y)] = val;
	    else
	      valmapp[make_pair(a->x, a->y)] = val;
	  }

	  if (a->name=="")
	    val0 = val;
	  if (a->name=="/grey")
	    valg = val;

	  if (a->neg) {
	    if (val>maxn)
	      maxn = val;
	    if (val<minn)
	      minn = val;
	  }

	  if (!a->neg) {
	    if (val>maxp)
	      maxp = val;
	    if (val<minp)
	      minp = val;
	  }
	}

        double maxmax = val0;  // maxn

	double maxdet = 0;
	if (detections.size()==2) {
	  string detstr = detections[1]+"#"+*c;
	  bool dummy = false;
	  map<string,vector<float> > dets = 
	    db->RetrieveDetectionData(i->first, detstr, true, dummy);
	  if (dets.size()!=1)
	    return ShowError(err+"detection <"+detstr+"> for #"+ToStr(i->first)+
			     " empty");
	  if (dets.begin()->second.size()!=1)
	    return ShowError(err+"detection <"+detstr+"> for #"+ToStr(i->first)+
			     " strange");
	  maxdet = dets.begin()->second[0];
	  maxmax = maxdet;
        }

	if (show_detections)
	  cout << label << " " << *c
	       << " val0=" << val0 << " valg=" << valg
	       << " minn=" << minn << " maxn=" << maxn
	       << " minp=" << minp << " maxp=" << maxp
	       << " maxdet=" << maxdet << " maxmax=" << maxmax
	       << endl;

	double div = maxn-minn;
	if (div==0)
	  div = 1;
	for (auto pi=valmapn.begin(); pi!=valmapn.end(); pi++) {
	  float val = (maxn-pi->second)/div*maxmax;
	  locmapvec.push_back(val);
	}

	if (store_response_images) {
	  // scalinginfo si(xn, yn, iwidth, iheight);
	  // si.stretch(true);
	  imagedata resimgn(iwidth, iheight, 1);
	  for (auto pi=valmapn.begin(); pi!=valmapn.end(); pi++) {
	    float val = (maxn-pi->second)/div*maxmax;
	    val = 1-val;
	    // resimgn.set(pi->first.first, pi->first.second, val);
	    for (size_t x=pi->first.first*iwidth/xn;
		 x<(pi->first.first+1)*iwidth/xn; x++)
	      for (size_t y=pi->first.second*iheight/yn;
		   y<(pi->first.second+1)*iheight/yn; y++)
		resimgn.set(x, y, val);
	  }
	  // resimgn.rescale(si);
	  char tmp[10];
	  sprintf(tmp, "%02zd", ci);
	  string cis = tmp;
	  imagefile::write(resimgn, "result-"+label+"-"+cis+"-"+
			   detections[0]+"-"+*c+"-neg.png");

	  if (use_pos) {
	    // imagedata resimgp(xn, yn, 1);
	    imagedata resimgp(iwidth, iheight, 1);
	    for (auto pi=valmapp.begin(); pi!=valmapp.end(); pi++) {
	      float val = (pi->second-minp)/(maxp-minp)*maxmax;
	      val = 1-val;
	      // resimgp.set(pi->first.first, pi->first.second, val);
	      for (size_t x=pi->first.first*iwidth/xn;
		   x<(pi->first.first+1)*iwidth/xn; x++)
		for (size_t y=pi->first.second*iheight/yn;
		     y<(pi->first.second+1)*iheight/yn; y++)
		  resimgp.set(x, y, val);
	    }
	    // resimgp.rescale(si);
	    imagefile::write(resimgp, "result-"+label+"-"+cis+"-"+
			     detections[0]+"-"+*c+"-pos.png");
	    
	    // imagedata resimga(xn, yn, 1);
	    imagedata resimga(iwidth, iheight, 1);
	    for (size_t x=0; x<resimga.width(); x++)
	      for (size_t y=0; y<resimga.height(); y++)
		resimga.set(x, y, (resimgn.get_one_float(x, y)+
				   resimgp.get_one_float(x, y))/2);
	    // resimga.rescale(si);
	    imagefile::write(resimga, "result-"+label+"-"+cis+"-"+
			     detections[0]+"-"+*c+"-avg.png");
	  }
	}
      }
      cout << "ZZZ";
      for (auto q=locmapvec.begin(); q!=locmapvec.end(); q++)
	cout << " " << *q;
      cout << " " << label << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseFeatureTest(const vector<string>& argv) {
    string err = "AnalyseFeatureTest() : ";

    bool incore_img = true;

    size_t maxcomp = 100;

    if (!argv.size())
      return ShowError(err, "You must give at least one label/index/"
                       "filename as argument");

    DataBase* db = CheckDB();

    list<imagedata> idatalist;
    list<string> fnamelist;
    list<incore_feature_t> incore;
    for (size_t i=0; i<argv.size(); i++) {
      const string& arg = argv[i];
      if (arg=="noincore") {
	incore_img = false;
	continue;
      }
      if (arg=="incore") {
	incore_img = true;
	continue;
      }

      imagedata imgdata;
      int iidx = -1;

      if (FileExists(arg))
	imgdata = imagefile(arg).frame(0);

      else {
	if (arg[0]=='#')
	  iidx = atoi(arg.substr(1).c_str());
	else 
	  iidx = db->LabelIndexGentle(arg, false);
	
	if (iidx<0)
	  return ShowError(err+"<"+arg+"> is neither a label nor filename");

	if (incore_img && db->ObjectsTargetType(iidx)==target_image)
	  imgdata = db->ImageData(db->LabelIndex(arg));
      }

      if (!imgdata.empty() && incore_img) {
	string type = "picsom::imagedata*";
	idatalist.push_back(imgdata);
	stringstream ss;
	ss << (void*)&*idatalist.rbegin();
	incore.push_back(make_pair(make_pair(type, ss.str()),
				   vector<float>()));

      } else {
	string type = "string::filename*";
	string opath;
	if (FileExists(arg))
	  opath = arg;
	else
	  opath = db->ObjectPathEvenExtract(iidx);
	fnamelist.push_back(opath);
	stringstream ss;
	ss << (void*)&*fnamelist.rbegin();
	incore.push_back(make_pair(make_pair(type, ss.str()),
				   vector<float>()));
      }
    }

    for (size_t m=0; m<Nindices(); m++) {
      string f = CheckQuery()->IndexShortName(m);

      string dirstr = db->ExpandPath("features");
      VectorIndex& vi = CheckQuery()->vectorIndex(m);
      // VectorIndex vi(db, f, f, dirstr, "", NULL);

      WriteLog(err+vi.LongName()+" has "+ToStr(vi.DataSetSize())+
	       " items, with vector length "+ToStr(vi.VectorLength()));

      vector<size_t> idx;
      set<string> done_segm;
      XmlDom xml;
      vi.CalculateFeatures(idx, incore, done_segm, xml, NULL);
      for (auto i=incore.begin(); i!=incore.end(); i++) {
	cout << "[" << i->first.first << "][" << i->first.second << "] "
	     << i->second.size() << " :";
	for (size_t j=0; (maxcomp==0 || j<maxcomp) && j<i->second.size(); j++)
	  cout << " " << i->second[j];
	cout << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseBinDumpTest(const vector<string>& argv) {
    string err = "AnalyseBinDumpTest() : ";

    if (!argv.size())
      return ShowError(err, "You must give at least one label or index as "
                       "argument.");

    DataBase* db = CheckDB();

    for (size_t m=0; m<Nindices(); m++) {
      string f = CheckQuery()->IndexShortName(m);

      string dirstr = db->ExpandPath("features");
      VectorIndex vi(db, f, f, dirstr, "", NULL);

      cout << err << vi.LongName() << " has " << vi.DataSetSize()
           << " items, with vector length " << vi.VectorLength() << endl;

      vector<size_t> idx;

      for (size_t i=0; i<argv.size(); i++) {
        const string& arg = argv[i];
        
        if (arg[0] == '(') {
          continue;
        } else if (arg[0] == '#') {
          idx.push_back(atoi(arg.substr(1).c_str()));
        } else {
          int r = LabelIndex(arg);
          if (r==-1)
            return ShowError(err, "Invalid label: ", arg);
          idx.push_back(r);
        }
      }

      const string augm;
      FloatVectorSet data = vi.DataByIndicesBin(idx, augm, 
						tolerate_missing_features);

      for (size_t i=0; i<idx.size(); i++) {
        size_t ii = idx[i];
        const FloatVector *v = data.FindByNumber(ii);
  
        char buf[100];
        if (!v) 
          sprintf(buf, "NULL");
        else
          sprintf(buf, "[%d] %u %.9f, %.9f, %.9f, ...",
		  (int)ii, v->Length(),
		  (double)(*v)[0], (double)(*v)[1], (double)(*v)[2]);
        cout << err << Label(ii) << " " << buf << endl;
      }
      
    }
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::LibsvmDump() {
    // bool debug = true;
    string err = "AnalyseLibsvmDump() : ";

    bool check_most_auth = false;

    DataBase* db = CheckDB();

    ground_truth rst = DataBaseRestrictionGT()&TargetTypeGT();

    bool ok = true;

    for (size_t m=0; m<Nindices(); m++) {
      VectorIndex& vi = CheckQuery()->vectorIndex(m);

      WriteLog(err, "Starting to create libsvm dump for ", IndexFullName(m),
               " ["+vi.FeatureTargetString()+"]");

      string oname = IndexFullName(m)+"-libsvm.dat";
      ofstream out(oname.c_str());
      ok = ok && out.good();

      FloatVectorSet* data = NULL;
      string current_datfile = "";
      int n=0;

      ProgressBar pb(rst.size()/100, 60, err);

      for (size_t i=0; i<db->Size(); i++) {
        if (rst.Get(i) != 1)
          continue;

        const FloatVector *v = vi.GetDataFromFile(i, data, current_datfile,
                                                  check_most_auth);

        out << "0";
        for (int j=0; j<v->Length(); j++) {
          out << " " << (j+1) << ":" << v->Value(j);
        }
        out << endl;

        n++;

        if (i%100==0)
          pb.Inc();
      }

      out.close();
      
      delete data;
      
      cout << endl;

      WriteLog(err, "Wrote ", ToStr(n), " lines to <"+oname+">");
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseRewriteMapsLabelsOnly(const vector<string>&) {
    string err = "AnalyseRewriteMapsLabelsOnly() : ";

    //ReadFiles(false);

    for (size_t i=0; i<Nindices(); i++) {
      TsSom(i).ReadMapFile(false, true);
      string newname = TsSom(i).Map().FileName();
      newname += "-labelsonly";
      TsSom(i).Map().WriteLabelsOnly(true);
      TsSom(i).Map().Write(newname.c_str());
      cout << "    wrote " << FileSize(newname) << " bytes in <"
	   << newname << ">" << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseMathTest(const vector<string>& argv) {
    string msg = "AnalyseMathTest() : ";

    if (argv.size()<2)
      return ShowError(msg+"at least two arguments (variable and equation)"
		       " are needed OR :file: <filename>");

    vector<string> var;

    map<string,string> eqs;

    if (argv[0]==":file:") {
      map<string,string> emap;
      map<string,double> vmap, cmap;

      ReadEquationFile(argv[1], emap, vmap, cmap);
      cout << endl << "Equations:" << endl;
      for (auto i=emap.begin(); i!=emap.end(); i++) {
	cout << i->first << " = " << i->second << endl;
	eqs[i->first] = i->second;
	var.push_back(i->first);
      }

      cout << endl << "Variabless:" << endl;
      for (auto i=vmap.begin(); i!=vmap.end(); i++) {
	cout << i->first << " = " << i->second << endl;
	eqs[i->first] = ToStr(i->second);
	var.push_back(i->first);
      }

      cout << endl << "Constants:" << endl;
      for (auto i=cmap.begin(); i!=cmap.end(); i++) {
	cout << i->first << " = " << i->second << endl;
	eqs[i->first] = ToStr(i->second);
	var.push_back(i->first);
      }
      cout << endl;

    } else {
      var.push_back(argv[0]);
      for (size_t i=1; i<argv.size(); i++) {
	try {
	  pair<string,string> kv = SplitKeyEqualValueNew(argv[i]);
	  eqs.insert(kv);
	  var.push_back(kv.first);
	} catch (const string& s) {
	  return ShowError(msg+"failed to split \""+argv[i]+"\"");
	}
      }
    }
    
    vector<double> v = SolveMath(var, eqs, true);
    for (size_t i=0; i<var.size(); i++)
      cout << var[i] << " = " << v[i] << endl;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  extern "C" void openblas_set_num_threads(int);

  void *caffe_instance(void *ps) {
    PicSOM *pp = (PicSOM*)ps;
    Query *q = pp->NewQuery();
    Analysis a(pp, NULL, q, vector<string>());
    int ok = 0;
    q->SetAnalysis(&a);
    q->Interpret("database", "caffe", ok, NULL);
    q->Interpret("features", "c_in12_rn50_pool5o_d_c", ok, NULL);

    vector<string> argv { "girl.jpeg" };
    a.AnalyseFeatureTest(argv);
    delete q;
    return NULL;
  }

  void run_caffe_instance(PicSOM *ps)  {
    pthread_t p;
    pthread_create(&p, NULL, caffe_instance, ps);    
  }
  
  
  Analysis::analyse_result Analysis::AnalyseTest(const vector<string>& argv) {
    string msg = "AnalyseTest() : ";

    cout << CheckDB()->LuceneVersion("") << endl;
    return true;
    
    // DataBase *db = GetDataBase();
    // vector<string> fv = GetQuery()->SelectedIndices(NULL);
    // list<string> feat(fv.begin(), fv.end());
    // cout << db->DetectionName(detections[0], feat, "zzz", "doge", "", false)
    // 	 << endl;
    
#if defined(HAVE_JSON_JSON_H)
    DataBase* db = CheckDB();
    string zipf = db->ExpandPath("download/1.2/image_data.json.zip");
    string indata = Picsom()->UnZip(zipf);
    ifstream istr(indata);
    Json::Value doc;
    istr >> doc;

    //const Json::Value& px = doc["images"];
    for (size_t k=0; k<doc.size(); k++) {
      const Json::Value& img = doc[(int)k];
      cout << img["url"] << " " << img["image_id"] << endl;
    }

    return true;
#endif // HAVE_JSON_JSON_H

    //openblas_set_num_threads(1);
    DataBase::DebugFeatures(1);
    for (size_t n=0;; n++) {
      caffe_instance(Picsom());
      continue;
      if (n<10)
	run_caffe_instance(Picsom());
      //NanoSleep(0.1);
      NanoSleep(10);
    }
      
#if 0
    ifstream istr("girl.jpeg");
    stringstream ss;
    ss << istr.rdbuf();
    string str = ss.str();
    imagefile ifile = imagefile::unstringify(str, "image/jpeg");
    imagedata img = ifile.frame(0);
    imagefile::display(img);
#endif // 0
    
#if 0
    FloatVector *v = GetDataBase()->FeatureData("fasterRcnn_spatMapFeat3+3GaussScaleDet",
					      0, true);

    v = GetDataBase()->FeatureData("c_in14_gr_pool5_d_aA3_ca3",
				   0, true);
    delete v;

    v = GetDataBase()->FeatureData("frcnn80detP3+3SpatGaussScaleP6grRBFsun397", 
				   0, true);
    delete v;
#endif // 0

    bool all = true;
    set<string> todo;

    if (argv.size()) {
      const string& arg1 = argv[0];
      size_t last = arg1.size()-1;
      if (arg1[0] == '(' && arg1[last] == ')') {
        string optarg = arg1.substr(1,last-1);
        vector<string> v = SplitInCommas(optarg);
        
        for (size_t i=0; i<v.size(); i++)
          todo.insert(LowerCase(v[i]));

        all = false;
      }
    }

    if (all || todo.count("splitincommasobeyparentheses")) {
      for (size_t i=0; i<argv.size(); i++) {
        const string &a = argv[i];
        if (a[0] == '(')
          continue;

        vector<string> v = SplitInCommasObeyParentheses(a);
        
        cout << "\"" << a << "\" produced:" << endl;
        for (size_t j=0; j<v.size(); j++)
          cout << "[" << j << "]: \"" << v[j] << "\"" << endl;
        cout << endl;
      }
    
      // "zzz,foo(xx,yy),gnats,bar(zz,qq),ooo(),xxx222d2d3d3d3,()()()dd23d23d,,3d23d23d()dd,,89,()," produced:
      // [0]: "zzz"
      // [1]: "foo(xx,yy)"
      // [2]: "gnats"
      // [3]: "bar(zz,qq)"
      // [4]: "ooo()"
      // [5]: "xxx222d2d3d3d3"
      // [6]: "()()()dd23d23d"
      // [7]: ""
      // [8]: "3d23d23d()dd"
      // [9]: ""
      // [10]: "89"
      // [11]: "()"
      // [12]: ""
      
      // "()(a,b)(((" produced:
      // [0]: "()(a,b)((("
    }

    if (all || todo.count("lscom")) {
      cout << "LscomName(\"trecvid2011\", \"003\", true) = " 
           << DataBase::LscomName(Picsom(), "003", true, lscommap) 
           << " should equal Running|100" << endl;
      cout << "LscomName(\"trecvid2011\", \"lscom006\", true) = " 
           << DataBase::LscomName(Picsom(), "lscom006", true, lscommap) 
           << " should equal Demonstration_Or_Protest|41" << endl;
      cout << "LscomName(\"trecvid2011\", \"Demonstration_Or_Protest\", false) = "
           << DataBase::LscomName(Picsom(), "Demonstration_Or_Protest",
				  false, lscommap)
           << " should equal 006" << endl;
      cout << "LscomName(\"trecvid2011\", \"100\", false) = "
           << DataBase::LscomName(Picsom(), "100", false, lscommap)
           << " should equal 003" << endl;
      
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

bool Analysis::SolveAndWriteAnalyseResults(const string& head, 
                                           analyse_result& res, 
                                           const string& mat_in,
                                           bool non_vec, bool separator) {
  string mat = mat_in;

  int apmq    = query->MaxQuestions();
  int apsize  = int(res.avgprecision.size());
  int appoint = apmq<apsize?apmq:apsize;
  float ap    = AvgPrecision(res, appoint);
  if (ap>=0) {
    res.avgprec = res.rescount*ap; // corrected? 15.8.2006
    res.appoint = appoint;
  }

  if (!rank_mode.empty()) {
    float comp_value;
    if (rank_mode == "trecvid") {
      if (optimize.empty())
        ShowError("No optimize value given for rank_mode=",rank_mode);
      pair<float,float> opt = OptimizeValue(res);
      comp_value = opt.first;
    } else 
      return ShowError("SolveAndWriteAnalyseResults::Bad rank mode: ",
                       rank_mode);

    res.ranking     = GetRanking(comp_value);
    res.old_ranking = GetRanking(old_rank_value);
    res.old_avgprec = old_rank_value;
  }

  return WriteAnalyseResults(head, res, mat_in, non_vec, separator);
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::WriteAnalyseResults(const string& head, 
                                   const analyse_result& res, 
                                   const string& mat_in,
                                   bool non_vec, bool separator,
                                   bool idxval) {

  bool interpret_roc_as_function=false;
  //  bool interpret_roc_as_function=true;

  string hh  = "Analyse"+head+": ";
  string mat = mat_in;
  float corr = res.corr, tot = res.tot, bias = res.bias;
  float div  = res.rescount, ddd = corr&&tot ? div*corr/tot : 1;

  char tmps[1000];
  if (separator)
    DoubleLogSeparator(mat);
  DoubleLog(mat, hh+"depth:     ", ToStr(Depth()));
  DoubleLog(mat, hh+"taskstack: ", TaskStack());
  DoubleLog(mat, hh+"loopid:    ", loopid);
  DoubleLog(mat, hh+"params:    ", res.params);
  DoubleLog(mat, hh+"results:   ", ToStr(res.rescount));
  DoubleLog(mat, hh+"rounds:    ", ToStr(res.rounds/div));
  DoubleLog(mat, hh+"corrects:  ", ToStr(corr));
  DoubleLog(mat, hh+"total:     ", ToStr(tot));
  DoubleLog(mat, hh+"bias:      ", ToStr(bias));
  if (tot)
    DoubleLog(mat, hh+"a priori:  ", ToStr(corr/tot));

  sprintf(tmps, "%.1f/%.1f", res.seen/div, tot);
  DoubleLog(mat, hh+"seen:      ", tmps);

  sprintf(tmps, "%.1f/%.1f", res.found/div, corr);
  DoubleLog(mat, hh+"found:     ", tmps);

  sprintf(tmps, "positive objects in 1st round: %.1f", res.firstpos/div);
  DoubleLog(mat, hh+"", tmps);

  if (non_vec) {
    DoubleLog(mat, hh+"tau         = ", ToStr(res.tau/div));
    DoubleLog(mat, hh+"tauord      = ", ToStr(res.tauord/div));
    DoubleLog(mat, hh+"birds       = ", ToStr(res.birds/div));
    DoubleLog(mat, hh+"firsthit    = ", ToStr(res.firsthit/div));    

    DoubleLog(mat, hh+"firsthit2   = ", ((res.found/div)>0.001) ? 
              ToStr((res.firsthit/div)+1) : "-1" );
    DoubleLog(mat, hh+"recipr.rank = ", ((res.found/div)>0.001) ? 
              ToStr(1/((res.firsthit/div)+1)) : "0" );
    DoubleLog(mat, hh+"found       = ", ToStr(res.found/div));

    if (res.firsthitadv) {
      DoubleLog(mat, hh+"firsthitadv = ", ToStr(div/res.firsthitadv));
      DoubleLog(mat, hh+"firsthitadv_geo = ",
                ToStr(exp(double(res.firsthitadv_geo/div))));
    }

    stringstream ss;
    ss << res.roc_eer/div << " (" << 1-res.roc_eer/div << ")";

    DoubleLog(mat, hh+"roc_size()  = ", ToStr(res.roc_size()));
    DoubleLog(mat, hh+"roc_range() = ", res.roc_range());
    DoubleLog(mat, hh+"roc_eer     = ", ss.str());
    DoubleLog(mat, hh+"roc_auc     = ", ToStr(res.roc_auc/div));
  }

  if (res.avgprec>=0) {
    float ap_round = RankRound(res.avgprec/div),
      ap_old = res.old_avgprec;
    char ap_oper = '?';
    if (ap_round == ap_old) ap_oper = '=';
    else if (ap_round > ap_old) ap_oper = '>';
    else if (ap_round < ap_old) ap_oper = '<';
    
    string logstr = hh+"avgprec"+(AveragePrecisionInferred()?"i":"")+
      "("+ToStr(res.appoint)+") = "+
      ToStr(res.avgprec/div)+" ("+ToStr(ap_round);
    if (ap_old != -1)
      logstr += string(" ")+ap_oper+" "+ToStr(ap_old);
    logstr += ")";
    DoubleLog(mat, logstr);
    DoubleLog(mat, hh+"avgprecbl    = "+ToStr(res.avgprecbl));
    DoubleLog(mat, hh+"avgprecadv_a = "+ToStr(res.avgprecadv_a/div));
    DoubleLog(mat, hh+"avgprecadv_g = "+ToStr(res.avgprecadv_g_value(div)));
  }

//   if (res.inferredap>=0) {
//     DoubleLog(mat, hh+"infap: ", ToStr(res.inferredap));
//   }

  if (res.ranking>=0)
    DoubleLog(mat, hh+"ranking: ",ToStr(res.ranking/div),
              " ("+ToStr(res.old_ranking/div)+")");

  if (res.rescount && MatlabName()!="") {
    string n(ExpandedMatlabName());
    Rename(n+".m", n+"_old.m");
    ofstream matlabos((n+".m").c_str());

    matlabos << endl << mat << "%\n% " << TimeStamp() << endl << endl;

    write_matlab(multiply(res.recall, 1/div),        matlabos, n+"_r");
    matlabos << endl;
    write_matlab(multiply(res.precision, 1/div),     matlabos, n+"_p");
    matlabos << endl;
    write_matlab(multiply(res.avgprecision, 1/div),  matlabos, n+"_a");
    matlabos << endl;
    write_matlab(multiply(res.precision, 1/ddd),     matlabos, n+"_x");
    matlabos << endl;
    write_matlab(multiply(res.instprecision, 1/div), matlabos, n+"_i");
    matlabos << endl;
    write_matlab(multiply(res.instprecision, 1/ddd), matlabos, n+"_j");
    matlabos << endl;
    write_matlab(multiply(res.maxpr, 1/div),         matlabos, n+"_m");
    matlabos << endl;
    write_matlab(multiply(res.apriori, 1/div),       matlabos, n+"_l");
    matlabos << endl;
    if(!interpret_roc_as_function)
      write_matlab(multiply(res.false_pos, 1/div), matlabos, n+"_roc_fp");
    else
      write_matlab(multiply(res.false_pos, (float)1.0/*1/div*/),
                   matlabos, n+"_roc_fp");
    matlabos << endl;
    write_matlab(multiply(res.true_pos, 1/div), matlabos, n+"_roc_tp");
    matlabos << endl;
    matlabos << n+"_roc_tn = 1-"+n+"_roc_fp;" << endl;
    matlabos << n+"_roc_fn = 1-"+n+"_roc_tp;" << endl;
    matlabos << endl;

    WriteLog(hh, "wrote results in <", n, ".m>");
  }

  if (res.best.size() && idxval) {
    size_t n = 0;
    for (objectlist_t::const_iterator i=res.best.begin(); i!=res.best.end();
         i++)
      DoubleLog(mat, hh+"best #"+ToStr(n++)+": "+ToStr(i->first)+" "+
                ToStr(i->second));
  }

  DoubleLogSeparator(mat);

  return true;
}

///////////////////////////////////////////////////////////////////////////////

static void fix_vector_lengths(const vector<float>& s, vector<float>& d,
                               bool strict, bool sloppy) {
  if (d.size()) {
    if (d.size()==s.size())
      return;

    if (!strict && d.size()==s.size()-1)
      return;

    if (!strict && d.size()==s.size()+1) {
      d.erase(d.begin()+d.size()-1);
      return;
    }
    
    if (sloppy)
      return;

    stringstream ss;
    ss << "src.size()=" << s.size() << " dest.size()=" << d.size()
       << " strict=" << strict;
    Simple::ShowError("Analysis::AddToResult() vector sizes differ: ",
                      ss.str());
    return;
  }

  if (s.size())
    d = vector<float>(s.size());
  else if (!sloppy)
    Simple::ShowError("Analysis::AddToResult() zero size source vector");
}

///////////////////////////////////////////////////////////////////////////////

void Analysis::AddToResult(const analyse_result& src, analyse_result& dest,
                           bool strict) {
  string msg = "Analysis::AddToResult() : ";

  //  bool interpret_roc_as_function=false;
  bool interpret_roc_as_function=false;
  bool sloppy = true; // forcedonly;

  fix_vector_lengths(src.recall,        dest.recall,        strict, sloppy);
  fix_vector_lengths(src.precision,     dest.precision,     strict, sloppy);
  fix_vector_lengths(src.avgprecision,  dest.avgprecision,  strict, sloppy);
  fix_vector_lengths(src.instprecision, dest.instprecision, strict, sloppy);
  fix_vector_lengths(src.maxpr,         dest.maxpr,         strict, sloppy);
  fix_vector_lengths(src.apriori,       dest.apriori,       strict, sloppy);
  if (!interpret_roc_as_function) {
    fix_vector_lengths(src.false_pos,   dest.false_pos,     strict, sloppy);
    fix_vector_lengths(src.true_pos,    dest.true_pos,      strict, sloppy);
  }

  if (dest.corr && dest.corr!=src.corr) {
    char tmp[100];
    sprintf(tmp, "dest.corr=%f src.corr=%f", dest.corr, src.corr);
    ShowError(msg+"disparity in corr: ", tmp);
  }

  if (dest.tot && dest.tot!=src.tot) {
    char tmp[100];
    sprintf(tmp, "dest.tot=%f src.tot=%f", dest.tot, src.tot);
    ShowError(msg+"disparity in tot: ", tmp);
  }

  if (dest.bias && dest.bias!=src.bias) {
    char tmp[100];
    sprintf(tmp, "dest.bias=%f src.bias=%f", dest.bias, src.bias);
    ShowError(msg+"disparity in bias: ", tmp);
  }

  if (dest.appoint!=-1 && src.appoint!=dest.appoint) {
    char tmp[100];
    sprintf(tmp, "dest.appoint=%d src.appoint=%d", dest.appoint, src.appoint);
    ShowError(msg+"disparity in appoint: ", tmp);
  }

  // if (!dest.corr && !dest.tot && src.corr && src.tot) {
  //   dest.corr = src.corr;
  //   dest.tot  = src.tot;
  // }

  if (dest.rescount==0 && src.rescount!=0)
    dest.roc_eer = 0;

  dest.rescount        += src.rescount;
  dest.rounds          += src.rounds;
  dest.seen            += src.seen;
  dest.found           += src.found;
  dest.firstpos        += src.firstpos;
  dest.tau             += src.tau;
  dest.tauord          += src.tauord;
  dest.birds           += src.birds;
  dest.firsthit        += src.firsthit;
  dest.firsthitadv     += src.firsthitadv;
  dest.firsthitadv_geo += src.firsthitadv_geo;
  dest.roc_eer         += src.roc_eer;
  dest.roc_auc         += src.roc_auc;
  dest.mean_inv_rank   += src.mean_inv_rank;  //obs! not correct?

  if (dest.ranking==-1 && src.ranking!=-1)
    dest.ranking = dest.old_ranking = 0;

  if (dest.avgprec==-1 && src.avgprec!=-1) {
    dest.avgprec = 0;
    dest.avgprecadv_a = 0.0;
    dest.avgprecadv_g = 1.0;
    dest.avgprecbl  = src.avgprecbl;
  }

  if (dest.appoint==-1 && src.appoint!=-1)
    dest.appoint = src.appoint;

  dest.ranking      += src.ranking;     // sanity checks here ?
  dest.old_ranking  += src.old_ranking;
  dest.avgprec      += src.avgprec;
  dest.avgprecadv_a += src.avgprecadv_a;
  dest.avgprecadv_g *= src.avgprecadv_g;

  if (dest.avgprecbl!=src.avgprecbl)
    dest.avgprecbl  = 0.0;

  if (src.recall.size()==dest.recall.size() ||
      (!strict && src.recall.size()==dest.recall.size()+1))
    for (size_t i=0; i<dest.recall.size(); i++) {
      dest.recall[i]        += src.recall[i];
      dest.precision[i]     += src.precision[i];
      dest.avgprecision[i]  += src.avgprecision[i];
      dest.instprecision[i] += src.instprecision[i];
      dest.maxpr[i]         += src.maxpr[i];
      dest.apriori[i]       += src.apriori[i];
    }
  dest.inferredap += src.inferredap;

  if (src.false_pos.size()==dest.false_pos.size() ||
      (!strict && src.false_pos.size()==dest.false_pos.size()+1))
    for (size_t i=0; i<dest.false_pos.size(); i++)
      if (!interpret_roc_as_function) {
        dest.false_pos[i] += src.false_pos[i];
        dest.true_pos[i]  += src.true_pos[i];
      }

  if (interpret_roc_as_function)
    SumRocs(dest.false_pos,dest.true_pos,src.false_pos,src.true_pos,
            dest.false_pos,dest.true_pos);
  
  // cout << "AddToResult() finishing." << endl;
}

///////////////////////////////////////////////////////////////////////////////

  void Analysis::SumRocs(const vector<float> &fp1,const vector<float> &tp1,
const vector<float> &fp2,const vector<float> &tp2,
                     vector<float> &res_fp,vector<float> &res_tp)
  {
    int l1=fp1.size();
    int l2=fp2.size();

   //  cout << "summing ROCs with lengths " << l1 << " and " << l2 << endl;

//     cout << "ROC 1:"<<endl;
//     for(int i=0;i<l1;i++)
//       cout << "[fp tp] = ["<<fp1[i]<<" "<<tp1[i]<<endl;

//     cout << "ROC 2:"<<endl;
//     for(int i=0;i<l2;i++)
//       cout << "[fp tp] = ["<<fp2[i]<<" "<<tp2[i]<<endl;

    if(l1==0){
      res_fp=fp2;
      res_tp=tp2;
      return;
    } else if(l2==0){
      res_fp=fp1;
      res_tp=tp1;
      return;
    }

    // we dont output the starting point (0,0)

    int i1=0,i2=0;

    float current_tp1=0;
    float current_tp2=0;


    while(i1<l1 && tp1[i1] == current_tp1) i1++; 
    while(i1<l1-1 && fp1[i1] == fp1[i1+1]) i1++; // and then up the curve

    while(i2<l2 && tp2[i2] == current_tp2) i2++;
    while(i2<l2-1 && fp2[i2] == fp2[i2+1]) i2++;

    vector<float> tp,fp;

    while(i1 <l1 || i2 < l2){
      float next_fp1,next_fp2;

      if(i1<l1)
        next_fp1=fp1[i1];  
      else
        next_fp1=1.5; // any value > 1.0
 
      if(i2<l2)
        next_fp2=fp2[i2];  
      else
        next_fp2=1.5; // any value > 1.0
   
      if(next_fp1==next_fp2){
        if(next_fp1 !=0){ // do not output point (0,0)
          fp.push_back(next_fp1);
          tp.push_back(current_tp1+current_tp2);
        }
        // update current_tp
    
        current_tp1=tp1[i1];
        current_tp2=tp2[i2];

        fp.push_back(next_fp1);
        tp.push_back(current_tp1+current_tp2);
        
        // find next plateau locations of both rocs
    
        while(i1<l1 && tp1[i1] == current_tp1) i1++;
        while(i1<l1-1 && fp1[i1] == fp1[i1+1]) i1++;

        while(i2<l2 && tp2[i2] == current_tp2) i2++;
        while(i2<l2-1 && fp2[i2] == fp2[i2+1]) i2++;

      } else if(next_fp1<next_fp2){
        // roc 1 is the next one to jump to a new value
    
        if(next_fp1 !=0){ // do not output point (0,0)
          fp.push_back(next_fp1);
          tp.push_back(current_tp1+current_tp2);
        }

        // update current_tp
    
        current_tp1=tp1[i1];

        fp.push_back(next_fp1);
        tp.push_back(current_tp1+current_tp2);
        
        // find next plateau of roc 1
    
        while(i1<l1 && tp1[i1] == current_tp1) i1++;
        while(i1<l1-1 && fp1[i1] == fp1[i1+1]) i1++;
      } else{
        // roc 2 is the next one to jump to a new value
        if(next_fp2 !=0){ // do not output point (0,0)    
          fp.push_back(next_fp2);
          tp.push_back(current_tp1+current_tp2);
        }
    
        // update current_tp
    
        current_tp2=tp2[i2];

        fp.push_back(next_fp2);
        tp.push_back(current_tp1+current_tp2);
        
        // find next plateau of roc 2
    
        while(i2<l2 && tp2[i2] == current_tp2) i2++;
        while(i2<l2-1 && fp2[i2] == fp2[i2+1]) i2++;
      }
    }

    // if the last transition is not vertical, insert point (1,max)

    if(fp[fp.size()-1]!=1){
      float m=tp1[l1-1]+tp2[l2-1];
      fp.push_back(1);
      tp.push_back(m);
    }

    res_fp=fp;
    res_tp=tp;

   //  cout << "summed ROC:"<<endl;
//     for(size_t i=0;i<res_fp.size();i++)
//       cout << "[fp tp] = ["<<res_fp[i]<<" "<<res_tp[i]<<endl;

  }

///////////////////////////////////////////////////////////////////////////////

double Analysis::TauEstimateMax(const IntVector& n, const IntVector& c,
                                        int total, int correct, int perround) {
  if (n.Length() != c.Length()) {
    ShowError("Analysis::TauEstimateMax vector lengths differ");
    return 1;
  }

//   int vlength = total/perround;
//   if (total%perround!=0)
//     vlength++;

  int vlength = (int)ceil(n.Length()+(total-n.Sum())/(float)perround);

  IntVector nn(vlength);
  IntVector cc(vlength);
  int i, csum=0;

  for (i=0; i< n.Length(); i++) {
    nn[i] = n[i];
    cc[i] = c[i];
    csum += c[i];
  }

  for (; i< nn.Length(); i++)
    nn[i] = perround;

  int correctleft = correct-csum;
  for (i = cc.Length()-1; correctleft>0; i--) {
    cc[i] = (correctleft < perround ? correctleft : perround);
    correctleft -= perround;
  }

  return CalculateTau(nn, cc);
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::TauEstimateMin(const IntVector& n, const IntVector& c,
                                     int total, int correct, int perround) {
  if (n.Length() != c.Length()) {
    ShowError("Analysis::TauEstimateMax vector lengths differ");
    return 1;
  }

//   int vlength = total/perround;
//   if (total%perround!=0)
//     vlength++;

  int vlength = (int)ceil(n.Length()+(total-n.Sum())/(float)perround);

  IntVector nn(vlength);
  IntVector cc(vlength);
  int i, csum=0;

  for (i=0; i< n.Length(); i++) {
    nn[i] = n[i];
    cc[i] = c[i];
    csum += c[i];
  }

  int correctleft = correct-csum;
  for (i++; i< nn.Length(); i++) {
    nn[i] = perround;
    if (correctleft>0) {
      cc[i] = (correctleft < perround ? correctleft : perround);
      correctleft -= perround;
    }
  }

  return CalculateTau(nn, cc);
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::TauEstimateMean(const IntVector& n,
                                         const IntVector& c,
                                         int total, int correct, int perround){
  if (n.Length() != c.Length()) {
    ShowError("Analysis::TauEstimateMax vector lengths differ");
    return 1;
  }

//   int vlength = total/perround;
//   if (total%perround!=0)
//     vlength++;

  int vlength = (int)ceil(n.Length()+(total-n.Sum())/(float)perround);

  IntVector nn(vlength);
  DoubleVector cc(vlength);
  int i, csum=0;

  for (i=0; i< n.Length(); i++) {
    nn[i] = n[i];
    cc[i] = c[i];
    csum += c[i];
  }
  
  int left = nn.Length()-i;
  for (; i< nn.Length(); i++) {
    nn[i] = perround;
    cc[i] = (double)(correct-csum)/(double)left;
  }
  
  return CalculateTau(nn, cc);
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::TauEstimateFit(const IntVector& n, const IntVector& c,
                                     int total, int correct, int perround) {
  if (n.Length() != c.Length()) {
    ShowError("Analysis::TauEstimateFit vector lengths differ");
    return 1;
  }

  if (n.Length()<2 || c.Sum()==0)
    return 1;

  FloatVector y(n.Length());
  float sum = 0;
  int i;

  for (i=0; i<y.Length(); i++) {
    sum += c[i];
    y[i] = correct-sum;
  }
  
  int left = total-n.Sum();
  int vlength = n.Length()+(int)ceil(float(left)/perround);

  IntVector    nn(vlength);
  DoubleVector cc(vlength);
  for (i=0; i<vlength; i++) {
    int use = left>perround ? perround : left;
    nn[i] = i<n.Length() ? n[i] : use;
    cc[i] = i<n.Length() ? c[i] : 0.0;
    if (i>=n.Length())
      left -= use;
  }

  if (sum!=correct) {
    FloatVector x(y.Length());
    x.SetIndices();
    float a, b;
    x.ExpFit(y, a, b);

    if (b==0)
      return 1;

    DoubleVector xf(vlength-n.Length()+1);
    xf.SetIndices().Add(n.Length());
    xf.Multiply(-b).SetExp().Multiply(a).SetDifference();
    xf.Divide(xf.Sum()).Multiply(correct-sum);
    cc.Lengthen(n.Length()).Append(xf);
  }

  return CalculateTau(nn, cc);
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::TauEstimateTrad(const IntVector& n,
                                         const IntVector& c) {
 return CalculateTau(n, c);
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::CalculateTau(const IntVector& n, const IntVector& c) {
  if (n.Length() != c.Length()) {
    ShowError("Analysis::CalculateTau(int,int) vector lengths differ");
    return 1;
  }

  int nsum = 0, sum=0;

  for (int i=0; i<n.Length(); i++) {
    sum  += c[i]*nsum;
    nsum += n[i];
  }

  double denom = nsum*(double)c.Sum();

  return denom ? sum/denom : 1;
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::CalculateTau(const IntVector& n,
                                      const DoubleVector& c) {
  if (n.Length() != c.Length()) {
    ShowError("Analysis::CalculateTau(int,double) "
              "vector lengths differ");
    return 1;
  }

  int   nsum = 0;
  double sum = 0.0;

  for (int i=0; i<n.Length(); i++) {
    sum  += c[i]*nsum;
    nsum += n[i];
  }

  double denom = nsum*c.Sum();

  return denom ? sum/denom : 1;
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::TauEstimateOrder(const IntVector& hits,
                                          int tot, int c) {

  //cout << "ATR-7c1: "; DumpMemoryUsage();

  int l = hits.Length();
  DoubleVector cc(l);
  //cout << "ATR-7c2: "; DumpMemoryUsage();
  for (int i=0; i<l; i++)
    cc[i] = hits[i];
  
  //cout << "ATR-7c3: "; DumpMemoryUsage();
  if (!ExpFitAndFill(cc, tot, c))
    return 1;

  //cout << "ATR-7c4: "; DumpMemoryUsage();
  IntVector nn(tot);
  nn.One();

  //cout << "ATR-7c5: "; DumpMemoryUsage();
  return CalculateTau(nn, cc);
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::TauEstimateBIRDS(const IntVector& hits,
                                          int correctsum) {

  // Note: This measure gives meaningful results only if window > correctsum:

  int window = hits.Length();
  int found  = hits.Sum();

  int missed = correctsum - found;
  int penalty = window + 1; // arbitrary, Manjunath uses 1.25*windows

  int rank = missed*penalty;

  for (int i=0; i<window; i++) {
    rank += (i+1)*hits[i];
  }

  double rrank = (double)rank / (double)correctsum; 

  double best = (1.0+(double)correctsum)/2;
  double worst = 1.0+(double)window;
  
  if (fabs(worst-best)<0.000001)
    return 0.0;

  return rrank / (worst-best); 
  //return (rrank-best) / (worst-best); 
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::MaxPR(const vector<int>& hits, int n) {
  bool dodebug = false;

  double max = 0;
  double sum = 0;

  for (size_t i = 0; i<hits.size(); i++) {
    sum += hits[i];
    double pr = sum*sum/(i+1);

    if (dodebug)
      cout << "  MaxPR: i=" << i << "  hits[i]=" << hits[i] << " sum=" << sum
           << " pr=" << pr << " pr/n=" << pr/n << (pr>max?" ***":"") << endl;

    if (pr>max)
      max = pr;
  }

  return max/n;
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::Precision(const IntVector& hits, int bias,
                                   vector<float> *vec) {
  if (!vec)
    return hits.Length()-bias <= 0 ? 0.0 :
      double(hits.Sum()-bias)/(hits.Length()-bias);

  double sum = 0.0;
  vec->resize(hits.Length());
  for (size_t i=0; i<vec->size(); i++) {
    sum += hits[i];
    (*vec)[i] = int(i)<bias ? 0.0 : (sum-bias)/(i+1-bias);
  }

  return vec->size() ? vec->back() : 0.0;
}
 
///////////////////////////////////////////////////////////////////////////////

double Analysis::Recall(const IntVector& hits, int c, int bias,
                                vector<float> *vec) {
  if (!vec)
    return double(hits.Sum()-bias)/(c-bias);

  double sum = 0.0;
  vec->resize(hits.Length());
  for (size_t i=0; i<vec->size(); i++) {
    sum += hits[i];
    (*vec)[i] = int(i)<bias ? 0.0 : (sum-bias)/(c-bias);
  }

  return vec->size() ? vec->back() : 0.0;
}
 
///////////////////////////////////////////////////////////////////////////////

double Analysis::AveragePrecision(const IntVector& hits, int c,
                                  int bias, vector<float> *vec) {
  int l = hits.Length();
  DoubleVector cc(l);
  for (int i=0; i<l; i++)
    cc[i] = hits[i];
 
  return AveragePrecision(cc, c, bias, vec);
}
 
///////////////////////////////////////////////////////////////////////////////

double Analysis::AveragePrecision(const DoubleVector& cc, int c,
                                  int bias, vector<float> *vec) {

  if (!vec) {
    float avg = 0.0, sum = 0.0;
    for (int j=bias; j<cc.Length(); j++)
      avg += cc[j]*(sum+=cc[j])/(j+1-bias);

    return c ? avg/c : 0.0;  // was avg/sum
  }

  double sum = 0.0, avg = 0.0;
  vec->resize(cc.Length());
  for (size_t i=0; i<vec->size(); i++)
    if (int(i)<bias)
      (*vec)[i] = 0.0;
    else {
      sum += cc[i];
      avg += cc[i]*sum/(i+1-bias);
      (*vec)[i] = c ? avg/c : 0.0;  // was avg/sum
    }

  return vec->size() ? vec->back() : 0.0;
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::InferredAveragePrecision(const DoubleVector& cc, int c) {
  double eps = 0.00001;

  double inf_ap = 0.0;
  double rel = 0.0, nonrel = 0.0, unjudged = 0.0;
  for (int j=0; j<cc.Length(); j++) {
    double val = cc[j];
    
    if (val==-1) nonrel++;
    else if (val==0) unjudged++;
    else if (val==-2) continue;
    
    if (val==1) {
      rel++;
      if (j==0) 
        inf_ap += 1.0;
      else {
        float k = j+1;
        inf_ap += 1.0/k + 
          (k-1)/k * (rel-1+nonrel+unjudged)/(k-1) * (rel-1+eps)/(rel-1+nonrel+2*eps);
      }       
      // cout << "InfAP[" << j << "] = " << inf_ap << ", " << inf_ap/c << endl;
    }
  }
  return inf_ap/c;
}

///////////////////////////////////////////////////////////////////////////////

double Analysis::AveragePrecisionEstimate(const IntVector& hits,
                                          int tot, int c, int bias) {
  int l = hits.Length();
  DoubleVector cc(l);
  for (int i=0; i<l; i++)
    cc[i] = hits[i];
  
  if (!ExpFitAndFill(cc, tot, c))
    return 1;

  return AveragePrecision(cc, c, bias);
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ExpFitAndFill(DoubleVector& cc, int tot, int corr) {
  //cout << "ATR-7c4a: "; DumpMemoryUsage();
  int l = cc.Length();

  if (l<2)
    return false;

  float ccsum = 0;
  FloatVector y(l);

  //cout << "ATR-7c4b: "; DumpMemoryUsage();

  for (int i=0; i<l; i++)
    y[i] = corr - (ccsum += cc[i]);

  if (!ccsum)
    return false;

  //cout << "ATR-7c4c: "; DumpMemoryUsage();

  if (ccsum==corr) {
    cc.Lengthen(tot);
    //cout << "ATR-7c4d: "; DumpMemoryUsage();
  } else {
    float a, b;
    //cout << "ATR-7c4e: "; DumpMemoryUsage();
    FloatVector x(l);
    x.SetIndices().ExpFit(y, a, b);
    //cout << "ATR-7c4f: "; DumpMemoryUsage();

    DoubleVector xf(tot-l+1);
    //cout << "ATR-7c4g: "; DumpMemoryUsage();
    xf.SetIndices().Add(l);
    xf.Multiply(-b).SetExp().Multiply(a).SetDifference();
    //cout << "ATR-7c4h: "; DumpMemoryUsage();
    double xfsum = xf.Sum();
    if (!xfsum)
      return false;

    //cout << "ATR-7c4i: "; DumpMemoryUsage();
    xf.Divide(xf.Sum()).Multiply(corr-xfsum); // or ccsum ???
    cc.Append(xf);
    //cout << "ATR-7c4j: "; DumpMemoryUsage();
  }

  //cout << "ATR-7c4k: "; DumpMemoryUsage();
  return true;
}

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::Interpret(const string& key, const string& val, int& res) {
    string err = "Analysis::Interpret("+key+","+val+") : ";

    res = 1;

    int intval = atoi(val.c_str());
    float floatval = atof(val.c_str());

    // BEGIN: picsom-analysis-attributes
    // ...
    // END:

    /*>> analysis_interpret
      analyse
      *DOCUMENTATION MISSING* */
    
    if (key=="analyse") {
      method = val;
      return true;
    }

    if (key=="args") {
      rest_argv_str.clear();
      vector<string> tmp = SplitInSpaces(val);
      bool concat = false;
      for (size_t i=0; i<tmp.size(); i++) {
	if (concat) {
	  string& s = rest_argv_str.back();
	  s += " "+tmp[i];
	  if (s[s.size()-1]=='"') {
	    s.erase(s.size()-1);
	    concat = false;
	  }
	  continue;
	}
	string s = tmp[i];
	if (s[0]=='"') {
	  s.erase(0, 1);
	  concat = true;
	}
	rest_argv_str.push_back(s);
      }

      return true;
    }

    if (key=="verbose") {
      verbose = intval;
      return true;
    }

    if (key=="loopid") {
      loopid = val;
      return true;
    }

    if (key=="detections") {
      detections = SplitInCommasObeyParentheses(val);
      return true;
    }

    if (key=="captionings") {
      captionings = SplitInCommasObeyParentheses(val);
      return true;
    }

    // if (key=="evaluations") {
    //   evaluations = SplitInCommasObeyParentheses(val);
    //   return true;
    // }

    if (key=="thresholds") {
      thresholds = val;
      return true;
    }

    if (key=="segmentations") {
      segmentations = SplitInCommasObeyParentheses(val);
      return true;
    }

    if (key=="treesomstruct") {
      treesomstruct = val;
      return true;
    }

    if (key=="multirescorrect") {
      multirescorrect = IsAffirmative(val);
      return true;
    }

    if (key=="avgquanterror") {
      avgquanterror = IsAffirmative(val);
      return true;
    }

    if (key=="neighkernel") {
      neighkernel = intval;
      return true;
    }

    if (key=="radiusbase") {
      radiusbase = floatval;
      return true;
    }

    if (key=="bmudivdepth") {
      res = bmudivdepth.ValueFromString(val).Length()>0;
      return true;
    }

    if (key=="traincount") {
      res = traincount.ValueFromString(val).Length()>0;
      return true;
    }

    if (key=="hard_negative_mining") {
      hard_negative_mining = intval;
      return true;
    }

    if (key=="rawdata") {
      rawdata = val;
      return true;
    }

    if (key=="units") {
      units = intval;
      return true;
    }

    if (key=="randproj") {
      randproj = intval;
      return true;
    }

    if (key=="concatfeat") {
      concatfeat = val;
      return true;
    }

    if (key=="elm") {
      elm = val;
      return true;
    }

    if (key=="svm") {
      svm = val;
      return true;
    }

    if (key=="libsvmdump") {
      libsvmdump = IsAffirmative(val);
      return true;
    }

    if (key=="filename") {
      filename = val;
      return true;
    }

    if (key=="outdir") {
      outdir = val;
      return true;
    }

    if (key=="writedata") {
      writedata = IsAffirmative(val);
      return true;
    }

    if (key=="stripvectors") {
      stripvectors = IsAffirmative(val);
      return true;
    }

    if (key=="fillorigins") {
      fillorigins = IsAffirmative(val);
      return true;
    }

    if (key=="featextbatchsize") {
      featextbatchsize = intval;
      return true;
    }

    if (key=="extractfeatures" || key=="extraction") {
      // until 2012-03-12 there was also bool extraction
      extractfeatures = IsAffirmative(val);
      return true;
    }

    if (key=="recalculatefeatures") {
      recalculatefeatures = IsAffirmative(val);
      return true;
    }

    if (key=="check_first_feature_only") {
      check_first_feature_only = IsAffirmative(val);
      return true;
    }

    if (key=="extractmedia") {
      extractmedia = IsAffirmative(val);
      return true;
    }

    if (key=="dodetections") {
      dodetections = IsAffirmative(val);
      return true;
    }

    if (key=="dosegments") {
      dosegments = IsAffirmative(val);
      return true;
    }

    if (key=="combineorphans") {
      combineorphans = IsAffirmative(val);
      return true;
    }

    if (key=="removecreated") {
      removecreated = IsAffirmative(val);
      return true;
    }

    if (key=="keeptmp") {
      keeptmp = IsAffirmative(val);
      return true;
    }

    if (key=="tolerate_missing_features") {
      tolerate_missing_features = IsAffirmative(val);
      return true;
    }

    if (key=="reextract_zero_vectors") {
      reextract_zero_vectors = IsAffirmative(val);
      return true;
    }

    if (key=="updatediv") {
      updatediv = IsAffirmative(val);
      return true;
    }

    if (key=="odlist") {
      odlist = SplitInCommas(val);
      return true;
    }

    if (key=="meandist") {
      meandist = IsAffirmative(val);
      return true;
    }

    if (key=="lbg") {
      lbg = IsAffirmative(val);
      return true;
    }

    if (key=="ord") {
      ord = IsAffirmative(val);
      return true;
    }

    if (key=="alien_data") {
      alien_data = val;
      return true;
    }

    if (key=="alien_map") {
      alien_map = val;
      return true;
    }

    if (key=="batchtrain") {
      batchtrain = IsAffirmative(val);
      return true;
    }

    if (key=="batchtrainperiod") {
      batchtrainperiod = val;
      return true;
    }

    if (key=="addlabels") {
      addlabels = IsAffirmative(val);
      return true;
    }

    if (key=="zipped") {
      zipped = IsAffirmative(val);
      return true;
    }
    
    if (key=="divxml") {
      divxml = IsAffirmative(val);
      return true;
    }

    if (key=="labelsonly") {
      labelsonly = IsAffirmative(val);
      return true;
    }

    if (key=="saveumatrix") {
      saveumatrix = IsAffirmative(val);
      return true;
    }

    if (key=="skiplabels") {
      skiplabels = val;
      return true;
    }

    if (key=="class") {
      classname = val;
      return true;
    }

    if (key=="classprefix") {
      classprefix = val;
      return true;
    }

    if (key=="watchclass") {
      watchclassname = val;
      return true;
    }

    if (key=="testsetname") {
      testsetname = val;
      return true;
    }

    if (key=="simulate") {
      simulate = val;
      return true;
    }

    if (key=="level") {
      level = val=="*" ? -1 : intval;
      return true;
    }

    if (key=="rounds") {
      rounds = intval;
      return true;
    }

    if (key=="classrounds") {
      classrounds = intval;
      return true;
    }

    if (key=="prfrounds") {
      prfrounds = intval;
      return true;
    }

    if (key=="prfobjects") {
      prfobjects = intval;
      return true;
    }

    if (key=="force") {
      force = IsAffirmative(val);
      return true;
    }

    if (key=="use_textindex") {
      use_textindex = IsAffirmative(val);
      return true;
    }

    if (key=="forcehit") {
      forcehit = IsAffirmative(val);
      return true;
    }

    if (key=="firstforcedidx") {
      firstforcedidx = intval;
      return true;
    }

    if (key=="usebias") {
      usebias = IsAffirmative(val);
      return true;
    }

    if (key=="truncate") {
      truncate = IsAffirmative(val);
      return true;
    }

    if (key=="dryrun") {
      dryrun = IsAffirmative(val);
      return true;
    }

    if (key=="recursive") {
      recursive = IsAffirmative(val);
      return true;
    }

    if (key=="insertcount") {
      insertcount = intval;
      return true;
    }

    if (key=="skipexisting") {
      skipexisting = val;
      return true;
    }

    if (key=="insertdirs") {
      insertdirs = val;
      return true;
    }

    if (key=="expand") {
      expand = IsAffirmative(val);
      return true;
    }

    if (key=="keeporder") {
      keeporder = IsAffirmative(val);
      return true;
    }

    if (key=="dirplot") {
      dirplot = IsAffirmative(val);
      return true;
    }

    if (key=="unseenzero") {
      unseenzero = IsAffirmative(val);
      return true;
    }

    if (key=="convolved") {
      convolved = IsAffirmative(val);
      return true;
    }

    if (key=="logarithm") {
      logarithm = IsAffirmative(val);
      return true;
    }

    if (key=="threshold") {
      threshold = floatval;
      return true;
    }

    if (key=="lscommap") {
      lscommap = val;
      return true;
    }

    if (key=="summarylength") {
       summarylength = floatval;
      return true;
    }

    if (key=="summarycliplength") {
       summarycliplength = floatval;
      return true;
    }

    if (key=="magnify") {
      magnify = intval;
      return true;
    }

    if (key=="histbins") {
      histbins = intval;
      return true;
    }

    if (key=="segments") {
      segments = intval;
      return true;
    }

    if (key=="segmentspec") {
      segmentspec = val;
      return true;
    }

    if (key=="segmentexpand") {
      segmentexpand = val;
      return true;
    }

    if (key=="optimize") {
      optimize = val;
      return true;
    }

    if (key=="optimize_expand_line") {
      optimize_expand_line = IsAffirmative(val);
      return true;
    }

    if (key=="imagefile") {
      imagefilename = val;
      return true;
    }

    if (key=="imagespec") {
      imagespec = val;
      return true;
    }

    if (key=="maptnspec") {
      maptnspec = val;
      return true;
    }

    if (key=="overlaps") {
      vcd_overlaps = val;
      return true;
    }

    if (key=="fusionmethod") {
      vcd_fusionmethod = val;
      return true;
    }

    if (key=="argstart") {
       vcd_argstart = intval;
      return true;
    }

    if (key=="argstop") {
       vcd_argstop = intval;
      return true;
    }

    if (key=="forkdisplay") {
      forkdisplay = IsAffirmative(val);
      return true;
    }

    if (key=="htmlfile" || key=="html") {
      htmlfile = val;
      return true;
    }

    if (key=="linkimages" || key=="htmlfile_linkimages") {
      if (val == "copy" || val == "2")
        htmlfile_linkimages = 2;
      else if (IsAffirmative(val) || val == "link" || val == "symlink")
        htmlfile_linkimages = 1;
      else
        htmlfile_linkimages = 0;
      return true;
    }

    if (key=="sourcedatabase") {
      sourcedatabase = val;
      return true;
    }

    if (key=="sourcefeature") {
      sourcefeature = val;
      return true;
    }

    if (key=="resultname" || key=="result") {
      vector<string> namvec = SplitInCommas(val);
      size_t depth = Depth();
      resultname = namvec.size()>depth ? namvec[depth] : "";
      return true;
    }

    if (key=="matlabname" || key=="matlab") {
      vector<string> namvec = SplitInCommas(val);
      size_t depth = Depth();
      MatlabName(namvec.size()>depth ? namvec[depth] : "");
      return true;
    }

    if (key=="clicks_min") {
      clicks_min = intval;
      return true;
    }

    if (key=="clicks_max") {
      clicks_max = intval;
      return true;
    }

    if (key=="bgcolor") {
      bgcolor = floatval;
      return true;
    }

    if (key=="trecvid") {
      trecvid = val;
      return true;
    }

    if (key=="trecvid_priority") {
      trecvid_priority = val;
      return true;
    }
  
    if (key=="trecvid_runid") {
      trecvid_runid = val;
      return true;
    }

    if (key=="trecvid_noexamples") {
      trecvid_noexamples = IsAffirmative(val);
      return true;
    }

    if (key=="trecvid_useaspects") {
      trecvid_useaspects = IsAffirmative(val);
      return true;
    }

    if (key=="trecvid_noprogressbar") {
      trecvid_noprogressbar = IsAffirmative(val);
      return true;
    }

    if (key=="treceval") {
      treceval = val;
      return true;
    }

    // Pass svm_* options to SVMsetParam
    if (key.substr(0,4) == "svm_") {
      SVMsetParam(key.substr(4), val);
      return true;
    }

    if (key=="instance") {
      instance = val;
      return true;
    }

    if (key=="imagenet_normalize") {
      imagenet_normalize = val;
      return true;
    }

    if (key=="imagenet_func") {
      imagenet_func = val;
      return true;
    }

    if (key=="imagenet_specialpre") {
      imagenet_specialpre = val;
      return true;
    }

    if (key=="imagenet_inputprefix") {
      imagenet_inputprefix = val;
      return true;
    }

    if (key=="imagenet_rootclass") {
      imagenet_rootclass = val;
      return true;
    }

    if (key=="imagenet_allcl") {
      imagenet_allcl = val;
      return true;
    }

    if (key=="callback") {
      callback = val;
      return true;
    }

    if (key=="alpha") {
      alpha = atof(val.c_str());
      return true;
    }

    if (key=="beta") {
      beta = atof(val.c_str());
      return true;
    }

    if (key=="labelextras") {
      labelextras = SplitInCommas(val);
      return true;
    }

    if (key=="sbdparams") {
      vector<string> par = SplitInCommas(val);
      if (par.size()>=5) {
        sbdparams.votepercent = atof(par[0].c_str());
        sbdparams.framegap = atoi(par[1].c_str());
        sbdparams.mindist = atoi(par[2].c_str());
        sbdparams.nframes = atoi(par[3].c_str());
        sbdparams.nframes_next = atoi(par[4].c_str());

        for (size_t mi=0; mi<(size_t)Nindices(); mi++) {
          if (par.size() >= (size_t)7+2*mi) {
            float be = atof(par[5+2*mi].c_str());
            float fw = atof(par[6+2*mi].c_str());

            if (mi >= sbdparams.boundaryexp.size())
              sbdparams.boundaryexp.push_back(be);
            else
              sbdparams.boundaryexp[mi] = be;
            
            if (mi >= sbdparams.feature_weight.size())
              sbdparams.feature_weight.push_back(fw);
            else
              sbdparams.feature_weight[mi] = fw;
            
          }
        }
      } else 
        ShowError(err+"invalid value for parameter 'sbdparams'");

      return true;
    }

    if (key=="sbdstepsize") {
      vector<string> par = SplitInCommas(val);
      if (par.size()>=7) {
        for (int si=0; si<7; si++) {
          sbdparams.stepsize[si] = atof(par[si].c_str());
        }
      } else 
        ShowError(err+"invalid value for parameter 'sbdstepsize'");
      
      return true;
    }

    // this can be used to control how to weight the abrupt and gradual 
    // transitions, and precision vs. recall in the parameter optimization.
    //
    // First parameter:
    // 0.0 == full weight for abrupt cuts
    // 1.0 == full weight for gradual cuts
    //
    // Second parameter:
    // 0.0 == full weight for recall
    // 1.0 == full weight for precision
    if (key=="sbdoptimizationslider") {
      vector<string> par = SplitInCommas(val);
      if (par.size()>=2) {
        sbdparams.gradualoptpercent = atof(par[0].c_str());
        if(sbdparams.gradualoptpercent<0.0) sbdparams.gradualoptpercent = 0.0;
        if(sbdparams.gradualoptpercent>1.0) sbdparams.gradualoptpercent = 1.0;
        sbdparams.precision_weight = atof(par[1].c_str());
        if(sbdparams.precision_weight<0.0) sbdparams.precision_weight = 0.0;
        if(sbdparams.precision_weight>1.0) sbdparams.precision_weight = 1.0;
      } else 
        ShowError(err+"invalid value for parameter 'sbdoptimizationslider'");

      return true;
    }

    if (key=="sbdgtfile") {
      sbdparams.gtfile = val;
      return true;
    }

    if (key=="topics") {
      topics = val;
      return true;
    }

    if (key=="metric") {
      string mval = val;

      size_t par_pos = val.find('(');
      if (par_pos != string::npos) {
        metric_weights = val.substr(par_pos+1);
        size_t end_par_pos = metric_weights.find(')');
        if (end_par_pos != string::npos)
          metric_weights.erase(end_par_pos);

        mval.erase(par_pos);
      }
      metric = mval;
      return true;
    }

    if (key=="namesuffix") {
      namesuffix = val;
      return true;
    }

    if (key=="featureaugmentation") {
      featureaugmentation = val;
      return true;
    }

    if (key=="distcomp") {
      if (val[0]>='0' && val[0]<='9')
        distcomp = intval;
      else
        distcomp = IsAffirmative(val);;
      return true;
    }

    if (key=="ntop") {
      ntop = intval;
      return true;
    }

    if (key=="knn") {
      WarnOnce("knn=<k> should be replaced with classifier=knn<k>");
      classifier = "knn"+val;
      return true;
    }

    if (key=="classifier") {
      classifier = val;
      return true;
    }

    if (key=="reject") {
      knn_reject = val;
      return true;
    }

    if (key=="vectorlength") {
      vectorlength = val;
      return true;
    }

    if (key=="normalization" || key=="preprocess") {
      preprocess = val;
      return true;
    }

    if (key=="componentorder") {
      componentorder = val;
      return true;
    }

    if (key=="compress") {
      compress = floatval;
      return true;
    }

    if (key=="bestall") {
      bestall = intval;
      return true;
    }

    if (key=="bestpositive") {
      bestpositive = intval;
      return true;
    }

    if (key=="bestother") {
      bestother = intval;
      return true;
    }

    if (key=="resultcount") {
      resultcount = intval;
      return true;
    }

    if (key=="forcedbest") {
      forcedbest = val;
      return true;
    }

    if (key=="forcedonly") {
      forcedonly = IsAffirmative(val);
      return true;
    }

    if (key=="relaxcounttest") {
      relaxcounttest = IsAffirmative(val);
      return true;
    }

    if (key=="skipresults") {
      skipresults = IsAffirmative(val);
      return true;
    }

    if (key=="field") {
      field = val;
      return true;
    }

    if (key=="value") {
      value = val;
      return true;
    }
    
    if (key=="skipnonexistent") {
      skipnonexistent = IsAffirmative(val);
      return true;
    }

    if (key=="classparams") {
      // this should be obsoleted and Query::Interpret() options used instead
      // now there is classifyparams=aa,bb,cc
      vector<string> vals = SplitInCommas(val);
      query->SetClassifyParams(vals[0], atoi(vals[1].c_str()), vals[2]);      
      return true;
    }

    if (key=="crossval") {
      crossval = val;
      return true;
    }

    if (key=="queryname") {
      queryname = val;
      return true;
    }

    if (key=="query") {
      res = FindQuery(val)!=NULL;
      return true;
    }

    if (key=="showrank") {
      string n, a;
      if (SplitParentheses(val, n, a)) {
        vector<string> args = SplitInCommas(a);
        if (n.substr(0,7) == "trecvid")
          ReadRankTrecvid(args);
        else if (n == "voc")
          ReadRankVoc2005(args);
        else 
          ShowError(err, n, ": format not recognized!");
      }
      return true;
    }

    if (key=="featurechoices") {
      featurechoices = ExpandFeaturesString(val);
      return true;
    }

    if (key=="plot") {
      plot = val;
      return true;
    }

    if (key=="scoredump") {
      scoredump = val;
      return true;
    }

    if (key=="scoredumponly") {
      scoredumponly = IsAffirmative(val);
      return true;
    }

    if (key=="scoredat") {
      scoredat = val;
      return true;
    }    

    if (key=="trainset") {
      gt_trainset = GTExpr(val);
      return true;
    }

    if (key=="testset") {
      gt_testset = GTExpr(val);
      return true;
    }

    if (key=="classmargin") {
      classmargin = floatval;
      return true;
    }

    if (key=="columns") {
      columns = intval;
      return true;
    }

    if (key=="xslname") {
      xslname = val;
      return true;
    }
    
    if (key=="pairdistancekernel") {
      pairdistancekernel = val;
      return true;
    }

    if (key.find("gt_")==0) {
      res = SetNoiseValue(key.substr(3), floatval);
      return true;
    }

    if (key=="elanconvert") {
      elanconvert = IsAffirmative(val);
      return true;
    }

    if (key=="elanoverwrite") {
      elanoverwrite = IsAffirmative(val);
      return true;
    }

    if (key=="mapgrid") {
      mapgrid = val;
      return true;
    }

#ifdef USE_MRML
    if (key=="mrmlserver") {
      mrmlserver = val;
      // the following boolean arguments have not been tested...
      mrml_connection = picsom->CreateUplinkConnection(val.c_str(),
                                                       true, false);
      return true;
    }
#endif //USE_MRML

    return false;
  }

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ProcessArguments(vector<string>& args) {
  const string hdr = "Analysis::ProcessArguments() : ";

  script.clear();

  bool ok = true;

  while (ok && !args.empty()) {
    string a = args[0];
    if (a.size()>1 && a[0]=='-')
      break;

    args.erase(args.begin());

    if (a=="-")
      break;

    if (a.find('=')!=string::npos)
      script.push_back(a);

    else {
      script_exp_t empty;
      list<string> tmp_script = ScriptRead(a, empty);
      script.insert(script.end(), tmp_script.begin(), tmp_script.end());
      ok = !tmp_script.empty();
    }
  }
  
  if (debug_script)
    ScriptDump(script, true);

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ScriptSplitBlocks(const list<string>& scr,
                                 string& blockname, list<string>& blockopts,
                                 list<string>& before, list<string>& block,
                                 list<string>& after) const {
  bool debug = debug_script;
  string msg = "Analysis::ScriptSplitBlocks() : ";

  before.clear(); 
  block.clear();
  after.clear();
  blockname.clear();
  blockopts.clear();

  list<string>::const_iterator blockstart = scr.end();
  list<string>::const_iterator i;
  for (i=scr.begin(); i!=scr.end(); i++) {
    string line = *i;
    size_t p = line.find_last_not_of(" \t");
    if (p<line.length()-1)
      line.erase(p+1);
    
    size_t ll = line.length();
    if (line[0]=='*' && blockname=="" && line[ll-1]!='*')
      return ShowError(msg+"block type not found before ["+line+"]");

    if (line[0] == '*' && line[ll-1] == '*') {
      if (blockstart == scr.end()) {
        string tmp = line.substr(1, ll-2);
        blockname = tmp;
        p = tmp.find_first_of(" \t");
        if (p!=string::npos) {
          blockname.erase(p);
          p = tmp.find_first_not_of(" \t", p);
          tmp = p!=string::npos ? tmp.substr(p) : "";
          if (tmp!="") {
            static set<string> known_opts;
            if (known_opts.empty()) {
              known_opts.insert("keep");
            }
            if (known_opts.find(tmp)==known_opts.end())
              return ShowError(msg+"option ["+tmp+"] not known");
              
            blockopts.push_back(tmp);
          }
        }

        if (blockname != "SUM" && blockname != "MAX" && blockname != "LIST")
          return ShowError(msg+"unknown block type: \""+blockname+"\"");

        blockstart = i;
      } else 
        break;
    }
    if (blockstart!=scr.end() && string("*# \t").find(line[0])==string::npos)
      break;
  }

  if (blockstart != scr.end()) {
    before.insert(before.end(), scr.begin(), blockstart);
    after.insert(after.end(), i, scr.end());

    list<string>::const_iterator j=blockstart;
    string longline;

    for (j++; j!=i; j++) {
      string line = *j;

      if (line[0] == '*') {
        if (!longline.empty())
          block.insert(block.end(),longline);
        line.erase(0,1);
        StripWhiteSpaces(line);
        longline = line;
        if (debug)
          cout << "LL = " << longline << endl;
      } else {
        size_t p = line.find_first_not_of(" \t");
        if (p > 0 && p != string::npos) { // indented line
          StripWhiteSpaces(line);
          longline += " ; "+line;
          if (debug)
            cout << "LL += " << line << endl;
        } else
          return ShowError(msg+"non-indented line <"+line+"> inside *-block");
      }
    }
    if (!longline.empty())
      block.insert(block.end(),longline);

    return true;
  }

  return false;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ScriptDump(const list<string>& scr, bool parts, bool t) const {
  if (t)
    cout << "SCRIPT DUMP depth=" << DepthAndTaskStack() << ":" << endl;

  if (parts) {
    list<string> before, block, after, opts;
    string blockname;

    if (ScriptSplitBlocks(scr, blockname, opts, before, block, after)) {
      if (!before.empty()) {
        cout << "*** BEFORE ***" << endl;
        ScriptDump(before, false, false);
        cout << endl;
      }

      cout << "*** BLOCK (" << blockname;
      for (list<string>::const_iterator oi=opts.begin(); oi!=opts.end(); oi++)
        cout << " [" << *oi << "]";
      cout << ") ***" << endl;
      ScriptDump(block, false, false);

      if (!after.empty()) {
        cout << endl << "*** AFTER ***" << endl;
        ScriptDump(after, false, false);
      }
      cout << endl;

    } else
      ScriptDump(scr, false, false);

    return true;
  }

  for (list<string>::const_iterator i=scr.begin(); i!=scr.end(); i++)
    cout << " [" << *i << "]" << endl;

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ScriptReplace(script_exp_t& s, const string& k, const string& v,
                             bool a, bool e) const {
  script_exp_t::iterator i = ScriptFind(s, k);
  if (i==s.end()) {
    if (!a)
      return false;
    
    i = s.insert(i, make_pair(k, string("*dummy*")));
  }

  if (v=="" && !e) {
    if (debug_script)
      cout << "SCRIPT erasing [" << i->first << "]=[" << i->second << "]"
           << endl;
    s.erase(i);
  } else {
    if (debug_script)
      cout << "SCRIPT replacing [" << i->first << "]=[" << i->second
           << "] => [" << v << "]" << endl;
    i->second = v;
  }
  
  return true;
}

///////////////////////////////////////////////////////////////////////////////

list<string> Analysis::ScriptMakeChoices(const script_exp_t& s,
                                         const string& t,
                                         const string& k,
                                         const list<string>& v) const {
  list<string> ret;

  bool found = false;
  for (script_exp_t::const_iterator i = s.begin(); true; i++) {
    if (i==s.end() && found)
      break;

    bool copy = i!=s.end() && i->first!=k, expand = i==s.end() || i->first==k;

    if (copy)
      ret.push_back(i->first+"="+i->second);

    if (expand) {
      ret.push_back("*"+t+"*");
      for (list<string>::const_iterator j=v.begin(); j!=v.end(); j++)
        ret.push_back("* "+k+"="+*j);

      if (i==s.end())
        break;
      else
        found = true;
    }
  }

  if (debug_script) {
    cout << "ScriptMakeChoices() created:" << endl;
    ScriptDump(ret, true);
  }

  return ret;
}

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ScriptExecuteAndShow() {
    bool ok = ScriptExecute();
      
    if (verbose)
      ScriptShow();

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ScriptShow() {
    WriteLog("Script: ", commands_str);
    WriteLog("Args:   ", ToStr(rest_argv_str));

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ScriptExecute(const list<string>& scr) {
  if (!query)
    CreateQuery();

  if (query->GetAnalysis() && query->GetAnalysis()!=this)
    return ShowError("Analysis::ScriptExecute() : Analysis pointer mismatch");

  query->SetAnalysis(this);

  script_exp_t pl = ScriptExpand(scr, false);

  return ScriptExecute(pl);
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ScriptExecute(const script_exp_t& pl) {
  return Picsom()->Interpret(pl.begin(), pl.end(), query, this, dummy_tssom);
}

///////////////////////////////////////////////////////////////////////////////

script_exp_t Analysis::ScriptExpand(const list<string>& scr,
				    bool keep_macros) const {
  script_exp_t plist, empty;

  for (list<string>::const_iterator i=scr.begin(); i!=scr.end(); i++) {
    if ((*i)[0]=='*') {
      ShowError("Analysis::ScriptExpand() : encountered * in ["+*i+"]");
      return empty;
    }

    size_t p = i->find_first_not_of(" \t");
    if (p==string::npos || (*i)[p]=='#')
      continue;
      
    if (i->find('=')!=string::npos) {
      SplitSemiColonsAndEqualSigns(plist, *i);
      continue;
    }

    script_exp_t tmp = ScriptExpandFile(*i, plist);
    plist.insert(plist.end(), tmp.begin(), tmp.end());
  }

  return ScriptExpandMacros(plist, keep_macros);
}

  /////////////////////////////////////////////////////////////////////////////

  script_exp_t 
  Analysis::ScriptExpandFile(const string& f, const script_exp_t& src) const {
    list<string> tmp_script = ScriptRead(f, src);
    
    return ScriptExpand(tmp_script, true);  // may lead to infinite recursion...
  }

  /////////////////////////////////////////////////////////////////////////////

  script_exp_t Analysis::ScriptDefaultMacros() const {
    struct timespec tt;
    SetTimeNow(tt);
    tm mytime;
    tm *time = localtime_r(&tt.tv_sec, &mytime);
    static char buf[100];
    strftime(buf, sizeof buf, "%Y%b%d", time); 

    script_exp_t m;
    m.push_back(make_pair(string("${root}"), Picsom()->RootDir()));
    m.push_back(make_pair(string("${user}"), Picsom()->UserName()));
    m.push_back(make_pair(string("${uid}"),  ToStr(getuid())));
    m.push_back(make_pair(string("${home}"), Picsom()->UserHomeDir()));
    m.push_back(make_pair(string("${cwd}"),  PicSOM::Cwd()));
    m.push_back(make_pair(string("${host}"), PicSOM::HostName()));
    m.push_back(make_pair(string("${date}"), string(buf)));
    m.push_back(make_pair(string("${scriptpath}"), string("*default*")));

    /*
      DataBase *db = CheckDB();
      if (db) {
        m.push_back(make_pair(string("${dbpath}"), db->Path()));
        for (auto i=db->Macro().begin(); i!=db->Macro().end(); i++)
        m.push_back(make_pair(i->first, i->second));
      }
    */

    const map<string,string>& e = Picsom()->Environment();
    for (map<string,string>::const_iterator i=e.begin(); i!=e.end(); i++) {
      string k = i->first, s = k;
      for (size_t j=0; j<k.size(); j++)
	if (k[j]>='A' && k[j]<='Z')
	  k[j] += 32;

      m.push_back(make_pair("${"+k+"}", i->second));

      if (s.find("SLURM_")==0 && e.find(s.substr(6))==e.end())
	m.push_back(make_pair("${"+k.substr(6)+"}", i->second));
    }
  
    list<pair<string,string> > kvl = Picsom()->DefaultKeyValues("env");
    for (list<pair<string,string> >::const_iterator i=kvl.begin();
	 i!=kvl.end(); i++)
      m.push_back(make_pair("${"+i->first+"}", i->second));

    if (debug_script)
      for (script_exp_t::const_iterator i=m.begin(); i!=m.end(); i++)
	cout << "SCRIPT DEFAULT defined [" << i->first << "]=["
	     << i->second << "]" << endl;

    return m;
  }

  /////////////////////////////////////////////////////////////////////////////

script_exp_t Analysis::ScriptExpandMacros(const script_exp_t& src,
                                                    bool keep_macros) const {
  script_exp_t ret, macro = ScriptDefaultMacros();

  for (script_exp_t::const_iterator i=src.begin();
       i!=src.end(); i++) {
    string key = ScriptExpandString(i->first,  macro);
    string val = ScriptExpandString(i->second, macro);

    pair<string,string> p(key, val);

    if (key.find("${")==0 && key[key.size()-1]=='}') {
      if (keep_macros)
        ret.push_back(p);

      macro.push_back(p);
      if (debug_script)
        cout << "SCRIPT defined  [" << p.first << "]=[" << p.second << "]"
             << endl;
    } else {
      ret.push_back(p);

      pair<string,string> q = make_pair("${"+key+"}", val);
      macro.push_back(q);
      if (debug_script)
        cout << "SCRIPT defined  [" << q.first << "]=[" << q.second << "]"
             << endl;
    }
  }
  
  return ret;
}

///////////////////////////////////////////////////////////////////////////////

string Analysis::ScriptExpandString(const string& s, const
                                    script_exp_t& m) const {
  bool debug = true && debug_script;
  string ret = s;
  stringstream ss;

  string from = "", to = "";

  size_t varpos = ret.find("${");
  size_t slashpos = string::npos, closepos = string::npos;
  if (varpos!=string::npos) {
    slashpos = ret.find('/', varpos+2);
    closepos = ret.find('}', varpos+2);
    if (slashpos>closepos)
      slashpos = string::npos;
  }

  if (slashpos!=string::npos) {
    size_t slash2pos = ret.find('/', slashpos+1);
    size_t fromlen = ret.length()-slashpos-2;

    if (slash2pos!=string::npos) {
      to = ret.substr(slash2pos+1,ret.length()-slash2pos-2);
      fromlen = slash2pos-slashpos-1;
    }

    from = ret.substr(slashpos+1,fromlen);
    ret = ret.substr(0,slashpos)+"}";

    if (debug)
      cout << "  found substitution from \"" << from << "\" to \"" << to 
           << "\", set ret=\"" << ret << "\"" << endl;          
  }

  for (;;) {
    bool found = false;
    for (script_exp_t::const_iterator i=m.begin(); i!=m.end(); i++) {
      size_t p = ret.find(i->first);
      if (debug)
        cout << "ret=[" << ret << "] p=" << (int)p << " i->first=["
             << i->first << "] i->second=[" << i->second << "]" << endl;
      if (p!=string::npos) {
        ss << "[" << ret << "]->";
        string value = i->second;
        if (!from.empty()) {
          size_t ii=0;
          while (true) {
            ii=value.find(from,ii);
            if (ii!=string::npos)
              value.replace(ii, from.size(), to);
            else
              break;
          } 
        }
        ret.replace(p, i->first.size(), value);
        found = true;
      }
    }

    if (!found)
      break;
  }

  if (debug_script && ret!=s)
    cout << "SCRIPT expanded " << ss.str() << "[" << ret << "]" << endl;

  return ret;
}

///////////////////////////////////////////////////////////////////////////////

  list<string> Analysis::ScriptExpandBlock(const list<string>& blk,
					   DataBase *db) const {
  bool debug = debug_script;

  if (blk.size()!=1)
    return blk;

  string s = *blk.begin(), k, v;
  if (!SplitKeyEqualValue(s, k, v))
    return blk;

  // if (k.find("${")!=0 || k[k.size()-1]!='}')
  //   return blk;
  
  size_t llength = db ? db->LabelLength() : 8;

  vector<string> c = SplitInSpaces(v);
  for (auto i=c.begin(); i<c.end(); i++)
    if (db && i->find("${")==0 && i->size()>3 && (*i)[i->size()-1]=='}') {
      string n = i->substr(2, i->size()-3);
      const map<string,string>& macro = db->Macro();
      auto j = macro.find(n);
      if (j!=macro.end()) {
	vector<string> z = SplitInSpaces(j->second);
	auto k = c.erase(i);
	c.insert(k, z.begin(), z.end());
      }
    }

  list<string> ret;

  for (size_t i=0; i<c.size(); i++) {
    const string& ci=c[i];
    if (i>0 && i<c.size()-1 && 
        ci[0]=='.' && ci[ci.length()-1]=='.') {
      // only simple integer cases for now...
      const string& val = ci.substr(1,ci.length()-2);
      float incr = val.length()?atof(val.c_str()):1;
      float beg = atof(c[i-1].c_str())+incr;
      float end = atof(c[i+1].c_str());
      for (; beg<end; beg+=incr) {
        string tmp = ToStr(beg);
        if (c[i-1].size()==llength && c[i+1].size()==llength) {
          tmp = string(llength-tmp.size(), '0')+tmp;
	  bool oklabel = !db || db->LabelIndexGentle(tmp, false)>=0;
	  if (oklabel)
	    ret.push_back(k+"="+tmp);
	  if (debug && !oklabel)
	    cout << "ScriptExpandBlock() : ["+s+"] <"+tmp+"> not valid label"
		 << endl;
	  continue;

	} else {
	  if (c[i-1].size()==c[i+1].size())
	    tmp = string(c[i-1].size()-tmp.size(), '0')+tmp;
	  ret.push_back(k+"="+tmp);
	}

	cout << "ScriptExpandBlock() : ["+s+"]->["+ret.back()+"]" << endl;
      }
      continue;
    }

    ret.push_back(k+"="+c[i]);
    if (debug)
      cout << "ScriptExpandBlock() : ["+s+"]->["+ret.back()+"]" << endl;
  }

  return ret;
}

///////////////////////////////////////////////////////////////////////////////

list<string> Analysis::ScriptRead(const string& ff,
                                  const script_exp_t& scr) const {
  string hdr = "Analysis::ScriptRead("+ff+") : ";

  list<string> path = ScriptSolveScriptPath(scr);

  if (debug_script) {
    string spm = "${scriptpath}", sp = ScriptExpandString(spm, scr);
    cout << hdr+"called with "+spm;
    if (sp==spm)
      cout << " undefined";
    else
      cout << "=["+sp+"]";
    if (!path.empty()) {
      cout << " =>";
      for (list<string>::const_iterator pi=path.begin(); pi!=path.end(); pi++)
        cout << " [" << *pi << "]";
    }
    cout << endl;
  }

  string f = ff;
  if (!FileExists(f) && f[0]!='/' &&
      f.substr(0, 2)!="./" && f.substr(0, 3)!="../")
    for (list<string>::const_iterator pi=path.begin(); pi!=path.end(); pi++) {
      string fp = *pi+"/"+ff;
      if (FileExists(fp)) {
        if (debug_script)
          cout << hdr+"found include file <"+fp+">" << endl;
        f = fp;
        break;
      } else if (debug_script)
        cout << hdr+"include file <"+fp+"> non-existent" << endl;
    }

  list<string> tmp_script;

  ifstream is(f.c_str());

  if (!is) {
    ShowError(hdr+"unable to read file <", f, ">");
    return tmp_script;
  }

  for (;;) {
    string line;
    getline(is, line);
    if (!is)
      break;
    
    if (IsBinaryDataContent(line)) {
      ShowError(hdr+"file <"+f+"> has binary content and"+
                " cannot be used (preceding dash [-] missing?)");
      return tmp_script;
    }

    size_t p = line.find_first_not_of(" \t");

    if (p==string::npos || line[p]=='#')
      continue;

    if (!tmp_script.empty()) {
      string& last = tmp_script.back();
      size_t bs = last.find_last_not_of(" \t");
      if (bs!=string::npos && last[bs]=='\\') {
        size_t ns = line.find_first_not_of(" \t");
        if (ns!=string::npos)
          line.erase(0, ns);
        last.replace(bs, string::npos, line);
        continue;
      }
    }

    tmp_script.push_back(line);
  }

  return tmp_script;
}

///////////////////////////////////////////////////////////////////////////////

list<string> Analysis::ScriptSolveScriptPath(const script_exp_t& scr) const {
  list<string> path;
  string spm = "${scriptpath}", p = ScriptExpandString(spm, scr);

  if (p=="*default*" || p==spm) {
    string subd = "scripts", dbm = "database";
    bool dev = Picsom()->Development();

    if (dev)
      path.push_back(Picsom()->RootDir()+"/"+subd);

    string db = ScriptExpandString(dbm, scr);
    if (db!=dbm) 
      for (;;) {
        path.push_back(Picsom()->ExpandDataBasePath(db, subd));
        size_t at = db.rfind('@');
        if (at==string::npos)
          break;
        db.erase(at);
      }

    path.push_back(Picsom()->Path()+"/"+subd);

  } else {
    vector<string> a = SplitInSpaces(p);
    if (a.size()==1 && p.find(';')!=string::npos)
      a = SplitInSomething(";", false, p); 

    path.insert(path.end(), a.begin(), a.end());
  }

  return path;
}

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::Insert() {
    string msg = "Analysis::Insert() : ";

    // ScriptExecuteAndShow(); // not needed as called in Analyse() ???

    if (!query)
      return ShowError(msg+"query==NULL");

    DataBase *db = query->GetDataBase();

    if (!db)
      return ShowError(msg+"missing database");

    WriteLog("About to insert/update some objects");

    vector<string> lines;

    bool emptyset = rest_argv_str.size()==1
      && ( rest_argv_str[0]=="" || rest_argv_str[0]=="\"\"" );

    if (!emptyset) {
      lines = rest_argv_str;
      if (lines.empty())
	lines = SplitInCommas(insertdirs);

      if (lines.empty() && HasCin()) {
	WriteLog("Reading filenames and instructions from standard input");
	for (; cin;)
	  try {
	    string line;
	    getline(cin, line);
	    if (cin) {
	      if (line[0]=='#')
		continue;
	      if (line.find("**")==0)
		lines.push_back(line);
	      else {
		vector<string> lp = SplitInSpacesObeyQuotes(line);
		for (size_t i=0; i<lp.size(); i++)
		  lines.push_back(lp[i]);
	      }
	    }
	  }
	  catch (...) {
	    break;
	  }
	stringstream s;
	s << lines.size();
	WriteLog("Read ", s.str(), " filenames/specifications");
      }
    }

    InitializeXmlResult(true);
    bool ret = InsertObjects(lines, NULL);
    
    WriteLog("Inserted "+ToStr(count_inserted)+" objects");
    
    return ret;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::InsertObjects(const vector<string>& argv,
			       vector<size_t> *idxs) {
    string msg = "Analysis::InsertObjects() : ";
    
    Tic("InsertObjects(vec)");

    // InitializeXmlResult(true); // now called already in Insert().
    XmlDom xml_root_or_nil = recursive ? XmlDom() : xml_result.Root();

    DataBase *db = query->GetDataBase();

    bool showerrors = true, ret = true;

    string page, url, errtxt;
    bool nofile = false;

    insert_objects_textline.clear();

    db->SqlBeginTransaction();
    
    for (size_t i=0; i<argv.size(); i++) {
      //WriteLog("A "+string(ret?"ret==true":"ret==false"));

      if (insertcount>=0 && count_inserted>=insertcount) {
	WriteLog("Maximum insert count "+ToStr(insertcount)+" reached");
	break;
      }

      const string &filect = argv[i];

      WriteLog("Starting to process entry <", filect, ">");
      if (filect[0]=='#') {
	WriteLog("    looks like a comment, skipping");
	continue;
      }

      if (filect.substr(0, 6)=="label=" && filect.size()>6) {
	if (db->UseSql() && db->SqlMode()!=2)
	  return ShowError(msg+"database should be opened for writing, "
			   "-rw=...sql...");

	if (!db->NextFreeLabel(filect.substr(6)))
	  ShowError("Analysis::InsertObjects() : <", filect, "> failed");
	else
	  WriteLog("Processed entry <", filect, ">");
	continue;
      }

      if (filect.substr(0, 6)=="class=" && filect.size()>6) {
	classname = filect.substr(6);
	WriteLog("Processed entry <", filect, ">");
	continue;
      }

      if (filect.substr(0, 5)=="page=" && filect.size()>5) {
	page = filect.substr(5);
	WriteLog("Processed entry <", filect, ">");
	continue;
      }

      if (filect.substr(0, 4)=="url=" && filect.size()>4) {
	url = filect.substr(4);
	WriteLog("Processed entry <", filect, ">");
	continue;
      }

      if (filect.substr(0, 7)=="nofile=" && filect.size()>7) {
	nofile = IsAffirmative(filect.substr(7));
	WriteLog("Processed entry <", filect, ">");
	continue;
      }

      if (filect.substr(0, 11)=="insertmode=" && filect.size()>11) {
	db->Interpret("insertmode", filect.substr(11));
	WriteLog("Processed entry <", filect, ">");
	continue;
      }

      string filecte = filect;

      size_t p = filecte.find("<path>");
      if (p!=string::npos) {
	filecte.replace(p, 6, db->Path());
	WriteLog("    expanded <path> : "+filecte);
      }

      if (filecte.find("**")==0) {
	string op = filecte, tmp = op;
	op.erase(0, 2);
	size_t p = op.find("**");
	if (p==string::npos)
	  return ShowError("Operation "+filecte+" failed A");
	op.erase(p);
	tmp.erase(0, p+4);
	while (tmp.size() && (tmp[0]==' ' || tmp[0]=='\t'))
	  tmp.erase(0, 1);
	vector<string> argvtmp = SplitInSpacesObeyQuotes(tmp);
	if (!InsertObjectsOperation(op, argvtmp))
	  return ShowError("Operation "+filecte+" failed B");
	continue;
      }
    
      if (db->UseSql() && db->SqlMode()!=2)
	return ShowError(msg+"database should be opened for writing, -rw=sql");

      if (Simple::DirectoryExists(filecte)) {
	InsertDirectory(filecte, xml_root_or_nil);
	continue;
      }

      if (filecte.substr(0,20) == "http://image-net.org" || 
	  filecte.substr(0,24) == "http://www.image-net.org") {
	size_t pos = filecte.rfind("wnid=");
	if (pos == string::npos) {
	  return ShowError("Bad image-net.org url. Should include wnid.");
	} else {
	  string wnid = filecte.substr(pos+5);
	  size_t stop = wnid.find_first_of('&');
	  wnid = wnid.substr(0, stop);
	  InsertImageNetSynset(wnid, xml_root_or_nil);
	}
	continue;
      }

      string file = filecte;
      size_t ss = file.find("//");
      if (ss!=string::npos)
	file.erase(ss);

      if (FileSize(file)==0) {
	WriteLog("    file exists but is empty, skipping, was it an error ???");
	continue;
      }

      if (FileExists(file) || filecte.substr(0, 7) == "http://" ||
	  filecte.substr(0, 8) == "https://") {
	if (!InsertOneFile(filecte, xml_root_or_nil, idxs, url, page, nofile))
	  ret = false;

	page = url = "";
	nofile = false;

	continue;
      }
    
      if (showerrors)
	ShowError("<"+filecte+"> is not a file or URL");
      else
	WriteLog("    not a file or URL, skipping, was this an error ???");

      errtxt += (errtxt==""?"":" ")+filecte;

      ret = false;
    }

    db->SqlEndTransaction();

    WriteOutTextLineData();

    //WriteLog("B "+string(ret?"ret==true":"ret==false"));

    if (!ret)
      SetXmlResultError("Analysis::InsertObjects() : <"+errtxt+">");
    else
      SetXmlResultOK();

    // this used to be a reference to a dummy variable
    InsertOneFileSynchronize(idxs);

    Tac("InsertObjects(vec)");

    return ret;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::InsertObjectsOperation(const string& op,
					const vector<string>& argv) {
    string msg = "Analysis::InsertObjectsOperation("+op+") : ";

    DataBase *db = CheckDB();

    if (op=="object") { // **object**
      if (db->UseSql() && db->SqlMode()!=2)
	return ShowError(msg+"database should be opened for writing, -rw=sql");
      
      if (argv.size()!=11)
	return ShowError(msg+"argument count "+ToStr(argv.size())+"!=11\n"
			 "EXAMPLE: **object** 0000 image 0000.png"
			 " foo.tar[1] page image/png >256 640x480 - md5sum -");
      // obs? anybody knows what argv[8] and argv[10] are for???

      target_type tt = SolveTargetTypes(argv[1], true);
      if (!db->AddLabelAndParents(argv[0], tt, false))
	return ShowError(msg+"AddLabelAndParents() failed");

      size_t idx = db->LabelIndex(argv[0]);
      map<string,string> oi;
      oi["colors"] = argv[6]; 
      oi["dimensions"] = argv[7];
      oi["checksum"] = argv[9];
      int nframes = 0;
      float framerate = 0.0;
      XmlDom xml;
      if (!db->InsertOriginsInfo(idx, false,
				 "", argv[2], argv[5], argv[3], argv[4],
				 "", oi, "-", tt, nframes, framerate, xml))
	return ShowError(msg+"InsertOriginsInfo() failed");

      return true;
    }

    if (op=="link") { // **link**
      if (argv.size()!=2)
	return ShowError(msg+ToStr(argv.size())+"!=2");

      string lab, d;
      size_t p = argv[1].find_first_of("0123456789");
      if (p!=string::npos)
	lab = argv[1].substr(p, db->LabelLength());
      if (db->LabelIndexGentle(lab)>=0) {
	d = db->SolveObjectDirectory(lab);
	p = argv[1].find("//");
	if (p==string::npos)
	  d += "/"+argv[1];
	else
	  d += argv[1].substr(p+1);

      } else if (argv[1].find("///")==0) {
	d = db->Path()+argv[1].substr(2);
      }

      if (d=="")
	return ShowError(msg+"label or file not solved from <"+argv[1]+">");

      if (d.substr(d.size()-1)=="/") {
	string f = argv[0];
	p = f.rfind("/");
	if (p!=string::npos)
	  f.erase(0, p+1);
	d += f;
      }
	
      if (FileExists(d))
	return ShowError(msg+"file <"+d+"> already exists");

      string dir = d;
      p = dir.rfind('/');
      if (p!=string::npos) {
	dir.erase(p);
	if (!Picsom()->MkDirHier(dir, 02775))
	  return ShowError(msg+"directory \""+dir+"\" for link <"+d+
			   "> could not be created");
      }

      if (!Symlink(argv[0], d))
	return ShowError(msg+"link <"+d+"> could not be created");

      return true;
    }

    if (op=="segmentfile") { // **segmentfile**
      if (argv.size()!=1)
	return ShowError(msg+ToStr(argv.size())+"!=1");

      size_t p = argv[0].rfind(':'), q = argv[0].rfind('/');
      if (p==string::npos)
	return ShowError(msg+"':' not found");

      string lab = argv[0].substr(p+1, db->LabelLength());
      if (db->LabelIndexGentle(lab)==-1)
	return ShowError(msg+"label <"+lab+"> not found");
      
      string d = db->SolveObjectDirectory(lab);
      d += "/segments";
      if (!DirectoryExists(d))
	Picsom()->MkDir(d, 02775);

      if (q!=string::npos)
	q++;
      else
	q = 0;

      d += "/"+argv[0].substr(q);
      if (FileExists(d))
	return ShowError(msg+"file <"+d+"> already exists");

      if (!CopyFile(argv[0], d))
	return ShowError(msg+"file copy <"+argv[0]+"> <"+d+"> failed");

      return true;
    }

    if (op=="textindex") { // **textindex**
      string line = JoinWithString(argv, " ");
      list<string> linelist { line };
      return db->TextIndexInput(linelist);
    }

    if (op=="textentry") { // **textentry**
      vector<string> a = argv;
      a.erase(a.begin());
      a.erase(a.begin());
      string str = JoinWithString(a, " ");
      AddTextLineData(argv[1], db->LabelIndex(argv[0]), str);
      return true;
    }

    if (false && op=="textentry") { // **textentry**
      // obs! this _should_ call DataBase::StoreSentences() 

      bool use_subdir = true;
      if (argv.size()<2)
	return ShowError(msg+ToStr(argv.size())+"<2");
      size_t oidx = db->LabelIndex(argv[0]);
      const string& label = db->Label(oidx);
      string type = argv[1];
      vector<string> argvx = argv;
      argvx.erase(argvx.begin());
      argvx.erase(argvx.begin());
      string line = JoinWithString(argvx, " ")+"\n";
      // obs! DataBase::LabelSubDir() is not what is needed here...
      string subd = use_subdir ? db->LabelSubDir(label) : "";
      // dunno why this is needed... (see the comment above...)
      if (use_subdir && subd=="")
	subd = label+".d";
      string fn = db->SolveObjectPath(label, subd, "", true)+"-"+type+".txt";
      if (!Picsom()->MakeDirectory(fn, true))
	return ShowError(msg+"Failed to create directory for <"+fn+">");

      string act = "Stored";
      if (FileExists(fn)) {
	string tmp = FileToString(fn);
	if (tmp.size()&&tmp[tmp.size()-1]=='\n')
	  tmp.erase(tmp.size()-1);
	line = tmp+" # "+line;
	act = "Appended";
      }
      if (!StringToFile(line, fn))
	return ShowError(msg+"Failed to write in <"+fn+">");

      WriteLog(act+" <"+type+"> type sentence in <"+
	       db->ShortFileName(fn)+">");

      return true;
    }

    if (op=="subobjects") { // **subobjects**
      if (db->UseSql() && db->SqlMode()!=2)
	return ShowError(msg+"database should be opened for writing, -rw=sql");
      
      if (argv.size()<3)
	return ShowError(msg+ToStr(argv.size())+"<3");
      if (argv[1]!="+")
	return ShowError(msg+"argv[1]!=\"+\"");

      size_t idx = db->LabelIndex(argv[0]);
      vector<size_t> s;
      if (argv.size()==5 && argv[3]=="..") {
	int a = db->LabelIndex(argv[2]);
	int b = db->LabelIndexGentle(argv[4]);
	const object_info& par = *db->FindObject(db->ParentObject(a));
	set<int> chset(par.children.begin(), par.children.end());
	for (int i=a; b==-1 || i<=b; i++) {
	  if (chset.find(i)==chset.end())
	    break;
	  s.push_back(i);
	}

      } else
	for (size_t i=2; i<argv.size(); i++)
	  s.push_back(db->LabelIndex(argv[i]));
      
      return db->AppendSubobjectsFile(idx, s);
    }

    if (op=="class" || op=="class ordered") { // **class**
      bool ordered = op=="class ordered", hasval = false, ishashindex = false;
      ground_truth gt(db->Size(), -1);
      list<pair<size_t,double> > ord;
      string equation;

      if (argv.size()>1) {
	int idx = -1;
	if (argv[1][0]=='#' && argv[1].length()>1 &&
	    argv[1].find_first_not_of("0123456789", 1)==string::npos) {
	  ishashindex = true;
	  idx = atoi(argv[1].substr(1).c_str());
	} else
	  idx = db->LabelIndexGentle(argv[1], true);

	if (idx<0 && argv[1].substr(0, 2)=="//") { // $auxid(...)
	  ground_truth t = db->GroundTruthExpression(argv[1]);
	  vector<size_t> gto = t.indices(1);
	  if (gto.size()!=1) {
	    return ShowError(msg+"\""+argv[1]+"\" expands to "+
			     ToStr(gto.size())+" objects");
	  }
	  idx = gto[0];
	}
	
	if (idx>=0) {
	  if (!ordered)
	    gt[idx] = 1;
	  else {
	    double val = 0.0;
	    if (argv.size()>2) {
	      val = atof(argv[2].c_str());
	      hasval = true;
	    }
	    ord.push_back(make_pair(idx, val));
	  }
	}

	if (idx==-1 && argv[1]=="=" && argv.size()>2)
	  for (size_t e=1; e<argv.size(); e++)
	    equation += string(e>1?" ":"")+argv[e];

	bool ismeta = false, ismetaline = false;
	if (argv.size()>2 && argv[1]=="#" && argv[2]=="METACLASSFILE")
	  ismeta = ismetaline = true;
	
	vector<string> mset;
	if (!ismeta && db->IsMetaClassFile(argv[0]) && argv[1][0]!='#') {
	  ismeta = true;
	  mset.push_back(argv[1]);
	}

	string comm;
	if (!ishashindex && !ismetaline && argv.size()>1 && argv[1][0]=='#')
	  for (size_t i=1; i<argv.size(); i++)
	    comm += (i>1?" ":"")+argv[i];

	string file = db->ExpandPath("classes", argv[0]);
	bool exists = FileExists(file);

	if (exists && argv.size()>2 && argv[1]=="#!") {
	  WriteLog(msg+"class file <"+file+"> already exists");
	  return true;
	}

	bool ok = ordered ?
	  db->WriteOrderedClassFile(ord, file, comm, hasval, true) :
	  db->WriteClassFile(file, mset, equation, gt, comm, true, ismeta);

	if (ok && argv.size()>2 && argv[1]=="#!") {
	  if (filename!="")
	    return ShowError(msg+"filename shout NOT be set here");
	  filename = file;

	  vector<string> aargv = argv;
	  aargv.erase(aargv.begin());
	  aargv.erase(aargv.begin());
	  string aas = JoinWithString(aargv, " ");
	  aargv.clear();
	  aargv.push_back(aas);
	  // only google_image_search has been implemented
	  // google_image_search is ordered, but others might not
	  // what should be done here with this?
	  bool oktmp = !AnalyseCreateClassFile(aargv).errored();
	  if (!oktmp)
	    ShowError(msg+aas+" failed, but let it be");
	  filename = "";
	}

	return ok;
      }

      return true;
    }

    return false;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AddTextLineData(const string& name, size_t idx,
				 const string& txtin) {
    string msg = "Analysis::AddTextLineData() : ";

    DataBase *db = CheckDB();

    string txt = txtin;
    float  val  = 0;

    map<size_t,textline_t>& m = insert_objects_textline[name];
    textline_t& t = m[idx];

    if (!t.db) {
      t.db    = db;
      t.idx   = idx;
      t.index = name;
      t.field = "text"; // obs!
    }
    t.txt_val.push_back({txt, val});

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::WriteOutTextLineData() {
    string msg = "Analysis::WriteOutTextLineData() : ";

    for (auto& i : insert_objects_textline)
      for (auto& j : i.second)
	if (!WriteOutTextLineData(j.second))
	  return ShowError(msg+"failed");
    
    insert_objects_textline.clear();

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::WriteOutTextLineData(const textline_t& tl) {
    string msg = "Analysis::WriteOutTextLineData(one entry) : ";

    bool force_store_sentences = false;

    DataBase *db = CheckDB();

    if (db->HasTextIndex(tl.index) && !force_store_sentences) {
      list<string> f = db->TextIndexFields(tl.index);
      if (f.size()!=1)
	return ShowError(msg+"TextIndexFields() returned != 1");
      string ff = f.front();
      
      // string s1 = tl.index+" add-attribute "+ff+" ";
      // string s2 = tl.index+" add-document ";

      list<string> tilines {
	// tl.index+" add-attribute "+ff+" "+tl.str(false, false),
	tl.index+" add-attribute "+ff+" "+tl.txt_encode(),
	tl.index+" add-document "+db->Label(tl.idx)
	  };

      if (!db->TextIndexInput(tilines))
	return ShowError(msg+"TextIndexInput() failed");
	
    } else {
      // vector<size_t> idxs { tl.idx } ;
      // string sspec = tl.index, type, odir;
      // db->StoreSentences(sspec, type, idxs, i->second, odir);
      return ShowError(msg+"force_store_sentences deprecated");
    }

    return true;
  }

///////////////////////////////////////////////////////////////////////////////

bool Analysis::FetchImageNet(const string& method, const string& wnid, 
    vector<string>& lines) {
  string url = "http://www.image-net.org/api/text/"+method+"?wnid="+wnid;
  string imgstr, ctype;
  list<pair<string,string> > hdrs;
  if (!Connection::DownloadString(Picsom(), "GET", url, hdrs, "", imgstr, ctype))
    return false;

  istringstream sstr(imgstr);
  string line;
  while (getline(sstr, line)) {
    size_t l = line.length();
    if (line[l-1] == '\r')
      line.erase(l-1);
    lines.push_back(line);
//     cout << "FetchImageNet(" << method << ", " << wnid <<  "): \"" 
//          << line << "\"" << endl;
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::InsertImageNetSynset(const string& wnid, XmlDom& xml) {
  DataBase* db = CheckDB();
  string cfname = db->ExpandPath("classes", wnid);

  WriteLog("Processing image-net synset <", wnid, ">");

  bool ready = false;
 
  // get child-classes of current synset class
  vector<string> children;
  if (recursive) 
    FetchImageNet("wordnet.structure.hyponym", wnid, children);

  // fixme: skipexisting might be expanded into a list of classes
  if ((skipexisting == wnid || skipexisting == "*") && FileExists(cfname))
    WriteLog("Image-net synset <", wnid, "> already exists, skipping...");

  else {
    vector<string> images;
    FetchImageNet("imagenet.synset.geturls", wnid, images);
    WriteLog("image-net synset <", wnid, "> contains "+ToStr(images.size())
	     +" images");

    vector<size_t> idxs;
    for (size_t i=0; i<images.size() && !ready; i++)
      if (insertcount<0 || count_inserted<insertcount)
	InsertOneFile(images[i], xml, &idxs, "", "", false);
      else
	ready = true;

    InsertOneFileSynchronize(&idxs);

    vector<string> words;
    FetchImageNet("wordnet.synset.getwords", wnid, words);

    string comment;
    for (size_t i=0; i<words.size(); i++)
      comment += (comment.empty()?"":",")+words[i];

    ground_truth set(db->Size());
    for (size_t i=0; i<idxs.size(); i++) 
      set.Set(idxs[i], 1);

    db->WriteClassFile(cfname, children, "", set, comment, false, true); 
  }

  // even if we are skipping this class we should go through child synsets
  if (!ready)
    for (size_t i=0; i<children.size(); i++) {
      const string& ch = children[i];
      if (ch[0] == '-')
        InsertImageNetSynset(ch.substr(1), xml);
    }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::InsertDirectory(const string& dir, XmlDom& xml) {
  WriteLog("Descending in directory <", dir, ">");

  list<string> fl = Simple::SortedDir(dir, "", true, false);
  for (list<string>::const_iterator i = fl.begin(); i!=fl.end(); i++)
    if ((*i)[0]!='.' && FileExtensionToMIMEtype(*i)!="") {
      if (insertcount>=0 && count_inserted>=insertcount)
	break;

      string f = dir;
      if (*f.rbegin()!='/')
        f += "/";
      f += *i;
      InsertOneFile(f, xml, NULL, "", "", false);
    }

  bool recurse = recursive && (insertcount<0 || count_inserted<insertcount);

  if (recurse) {
    //
    // obs! there is nothing here that could prevent infinite recursion !
    //
    list<string> dl = Simple::SortedDir(dir, "", false, true);
    for (list<string>::const_iterator i = dl.begin(); i!=dl.end(); i++)
      if ((*i)[0]!='.') {
        string f = dir;
        if (*f.rbegin()!='/')
          f += "/";
        f += *i;
        InsertDirectory(f, xml);
      }
  }

  Picsom()->PossiblyShowDebugInformation("After InsertDirectory");

  return true;
}

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::InsertOneFile(const string& filect, XmlDom& xml, 
			       vector<size_t> *idxs, const string& url,
			       const string& pp, bool nofile) {
    string segmentout = ""; // filect+".seg";

    bool ret = UsePthreadsInsert()
      ? InsertOneFileParallel(filect, xml, idxs, segmentout, url, pp, nofile)
      : InsertOneFileSerial(filect, xml, idxs, segmentout, url, pp, nofile);

    count_inserted += ret; // this is wrong with InsertOneFileParallel()...

    return ret;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::InsertOneFileSerial(const string& filect, XmlDom& xml, 
				     vector<size_t> *idxs,
				     const string& segout, const string& urlin,
				     const string& pp, bool nofile) {
    string msg = "Analysis::InsertOneFileSerial("+filect+") : ";

    string file = filect, ct, ctype, url;
    bool delete_original = false;
    bool insert_zipped_images = true;
    
    if (filect.substr(0, 7) == "http://" ||
	filect.substr(0, 8) == "https://") {
      url = filect;
      DataBase *db = CheckDB();

      if (db->URLIsBlacklisted(url)) {
	WriteLog("    skipping blacklisted URL "+url);
	return true;
      }

      int idx = db->ReverseURL(url);
      if (idx != -1) {
	WriteLog("    object <"+db->Label(idx)+"> exists, skipping URL "+url);
	if (idxs)
	  idxs->push_back(idx);
	return true;
      }

      WriteLog("Starting to download \""+filect+"\"");
      list<pair<string,string> > hdrs;
      file = Connection::DownloadFileWithTricks(Picsom(), filect, hdrs, ctype);
      delete_original = true;
      if (file.empty()) 
	return ShowError(msg+"could not download file ", filect);
    }
  
    size_t ss = file.find("//");
    if (ss!=string::npos) {
      ct = file.substr(ss+2);
      file.erase(ss);
    }
    if (url=="")
      url = urlin!="" ? urlin : file;

    struct stat st;
    if (::stat(file.c_str(), &st) || !st.st_size) {
      WriteLog("Skipping empty file <", file, ">");
      if (delete_original)
	Unlink(file);
      return false;
    }

    Tic("InsertOneFileSerial");

    string stats;
    if (insertcount>=0)
      stats = " insertcount="+ToStr(insertcount)+" count_inserted="+
	ToStr(count_inserted);

    WriteLog("Inserting object file <", file, ">"+stats);

    DataBase *db = query->GetDataBase();

    list<upload_object_data> imagelist;
    imagelist.push_back(upload_object_data());
    upload_object_data& uid = imagelist.front();
    
    string filebase = file;
    size_t ldot = filebase.rfind(".");
    string lext = ldot!=string::npos ? filebase.substr(ldot) : "";
    if (lext==".bz2" || lext==".gz") {
      filebase.erase(ldot);
      uid.comprext = lext;
    }

    if (ct=="")
      ct = FileExtensionToMIMEtype(filebase);
    if (ct=="")
      ct = libmagic_mime_type(file).first;
    if (ct=="") {
      ct = "image/unknown";
      ShowError(msg+"setting MIME content type of <", file, "> to ", ct);
    }
    // uid.data  = DataBase::FileToString(file);
    uid.path     = file;
    uid.use      = "regular";
    uid.ctype    = ct;
    uid.url      = url;
    uid.page     = pp!=""? pp : "-";
    uid.date     = PicSOM::OriginsDateStringNow(true);
    uid.nofile   = nofile;
    uid.keywords = SplitInCommas(classname);

    if ((ct=="application/zip" || ct=="application/x-tar") &&
	insert_zipped_images) {
      if (!db->ContainsImages(file)) {
	WriteLog("   Container file <", file, 
		 "> doesn't contained images, skipping.");
	return false;
      }
      uid.use    = "container-regular";
    }
    
    list<string> featlist, detectlist, segmentlist;
    if (extractfeatures)
      featlist = query->IndexFullNames();

    if (dodetections)
      detectlist.insert(detectlist.begin(),
			detections.begin(), detections.end()); 
    if (dosegments)
      segmentlist.insert(segmentlist.begin(),
			 segmentations.begin(), segmentations.end()); 

    bool ok = db->InsertObjects(imagelist, featlist,
				detectlist, segmentlist,
				updatediv, zipped, odlist, xml, segout);

    if (!ok)
      ShowError(msg+"InsertObjects() returned false");

    if (delete_original)
      Unlink(file);

    if (ok && idxs) 
      for (auto i=imagelist.begin(); i!=imagelist.end(); i++) 
	idxs->insert(idxs->end(), i->indices.begin(), i->indices.end()); 

    Tac("InsertOneFileSerial");

    Picsom()->PossiblyShowDebugInformation("After InsertOneFileSerial");

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::InsertOneFileParallel(const string& filect, XmlDom& /*xml*/, 
				       vector<size_t>* /*indices*/,
				       const string& /*segout*/,
				       const string& /*url*/,
				       const string& /*pp*/,
				       bool /*nofile*/) {
    string msg = "InsertOneFileParallel() : ";
    WriteLog(msg+"Starting insertion pthread");

    script_list_e sa;
    sa.first = filect;

 #ifdef ANALYSIS_USE_PTHREADS
    analyse_pthread_data_t d; // duplicated in AnalysePthread()
    d.thread_set = false;
    d.tid        = 0;
    d.analysis   = this;
    d.param      = sa;
    d.running    = false;
    d.ready      = false;
    d.joined     = false;
    d.collected  = false;
    d.result     = analyse_result(false);
    d.parent_thread_id = pthread_self();
    d.parent_tid       = gettid();

    thread_data.push_back(d);
    thread_data_t::reverse_iterator di = thread_data.rbegin();
    analyse_pthread_data_t& datax = *di;
    volatile analyse_pthread_data_t& data = *di;

    int r = pthread_create(&datax.thread_id, NULL,
                           (CFP_pthread) InsertOneFilePthreadCall,
                           (void*)&datax);
    data.thread_set = true;

    if (r) {
      ShowError(msg+"pthread_create() failed");
      SimpleAbort();
      return false;
    }

    while (!data.tid) {
      struct timespec ts = { 0, 1000 }; // 1 microsecond
      nanosleep(&ts, NULL);
    }

    const string& thread_text = datax.param.first;
    RegisterThread(datax.thread_id, datax.tid, thread_text, &datax);

    list<analyse_result> results_are_lost;
    AnalysePthreadJoin(results_are_lost, false);

    Picsom()->SleepIfNoThreadsAvailable();

#endif // ANALYSIS_USE_PTHREADS
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////
  
  void *Analysis::InsertOneFilePthreadCall(void *p) {
 #ifdef ANALYSIS_USE_PTHREADS
    XmlDom dummyxml;

    analyse_pthread_data_t *d = (analyse_pthread_data_t*)p;
    const string& filect = (*d).param.first;
    d->tid = gettid();
    d->running = true;
    d->result = d->analysis->InsertOneFilePthreadCallInner(filect, dummyxml,
							   &d->indices);
    d->ready = true;
    
    d->analysis->WriteLog("InsertOneFilePthreadCall() finishing");

#endif // ANALYSIS_USE_PTHREADS
    return p;
  }

  /////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::InsertOneFilePthreadCallInner(const string& filect,
					       XmlDom& xml, 
					       vector<size_t> *idxs) {
  #ifdef ANALYSIS_USE_PTHREADS
   string file = filect, ct, ctype, url;
    bool delete_original = false;

    if (filect.substr(0,7) == "http://") {
      url = filect;
      DataBase *db = CheckDB();

      if (db->URLIsBlacklisted(url)) {
	WriteLog("    skipping blacklisted URL "+url);
	return true;
      }

      int idx = db->ReverseURL(url);
      if (idx != -1) {
	WriteLog("    object <"+db->Label(idx)+"> exists, skipping URL "+url);
	if (idxs)
	  idxs->push_back(idx);
	return true;
      }

      WriteLog("Starting to download \""+filect+"\"");
      list<pair<string,string> > hdrs;
      file = Connection::DownloadFile(Picsom(), filect, hdrs,ctype);
      delete_original = true;
      if (file.empty()) 
	return ShowError("Analysis:InsertOneFileParallel() : "
			 "could not download file ", filect);
    }
  
    size_t ss = file.find("//");
    if (ss!=string::npos) {
      ct = file.substr(ss+2);
      file.erase(ss);
    }
    if (url.empty())
      url = file;

    struct stat st;
    if (::stat(file.c_str(), &st) || !st.st_size) {
      WriteLog("Skipping empty file <", file, ">");
      if (delete_original)
	Unlink(file);
      return false;
    }

    Tic("InsertOneFileParallel");

    DataBase *db = query->GetDataBase();

    list<upload_object_data> imagelist;
    imagelist.push_back(upload_object_data());
    upload_object_data& uid = imagelist.front();
    
    string filebase = file;
    size_t ldot = filebase.rfind(".");
    string lext = ldot!=string::npos ? filebase.substr(ldot) : "";
    if (lext==".bz2" || lext==".gz") {
      filebase.erase(ldot);
      uid.comprext = lext;
    }

    if (ct=="")
      ct = FileExtensionToMIMEtype(filebase);
    if (ct=="")
      ct = libmagic_mime_type(file).first;
    if (ct=="") {
      ct = "image/unknown";
      ShowError("Analysis::InsertOneFileParallel() : "
		"setting MIME content type of <", file, "> to ", ct);
    }

    bool ok = true;

    string col, dim, csm;
    int nfr = 0;
    float frr = 0.0;
    if (ct.find("image/")==0 || ct.find("video/")==0) {
      target_type tt = ct.find("image/")==0 ? target_image : target_video;
      string mime;
      ok = db->SolveMissingOriginsInfo(file, tt, col, dim, csm, nfr, frr, mime);
    }

    if (!ok)
      WriteLog("Skipping file <", file, "> could not be read");

    else {
      // uid.data    = DataBase::FileToString(file);
      uid.path       = file;
      uid.use        = "regular";
      uid.ctype      = ct;
      uid.url        = url;
      uid.page       = "-";
      uid.date       = PicSOM::OriginsDateStringNow(true);
      uid.colors     = col;
      uid.dimensions = dim;
      uid.checksum   = csm;
      uid.keywords   = SplitInCommas(classname);
      uid.nframes    = nfr;
      uid.framerate  = frr;
  
      list<string> featlist, detectlist, segmentlist;
      if (extractfeatures)
	for (size_t f=0; f<Nfeatures(); f++)
	  featlist.push_back(query->IndexFullName(f));
      if (dodetections)
	detectlist.insert(detectlist.begin(),
			  detections.begin(), detections.end()); 
      if (dosegments)
	segmentlist.insert(segmentlist.begin(),
			   segmentations.begin(), segmentations.end()); 

      WriteLog("Inserting object file <", file, ">");
      ok = db->InsertObjects(imagelist, featlist, detectlist, segmentlist,
			     updatediv, zipped, odlist, xml, "");
    }

    if (delete_original)
      Unlink(file);

    if (ok && idxs) 
      for (auto i=imagelist.begin(); i!=imagelist.end(); i++) 
	idxs->insert(idxs->end(), i->indices.begin(), i->indices.end()); 

    Tac("InsertOneFileParallel");

    return ok;
#else
    return false;
#endif // ANALYSIS_USE_PTHREADS
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseInsertSubObjects(const vector<string>& args) {
    string msg = "AnalyseInsertSubObjects() : ";
    WriteLog(msg+"starting");

    // bool force = false;

    if (Target()!=target_videofile && Target()!=target_imageset)
      return ShowError("insertsubobjects currently works only with "
		       "target=video+full+file | target=imageset");

    DataBase *db = CheckDB();

    ground_truth gt(db->Size());

    for (auto a=args.begin(); a!=args.end(); a++) {
      ground_truth gtone = db->GroundTruthExpression(*a);
      gt = gt.TernaryOR(gtone);
    }

    vector<size_t> idxsr = gt.indices(1), idxs;
    for (size_t i=0; i<idxsr.size(); i++)
      if (db->ObjectsTargetType(idxsr[i])==Target()) {
	const vector<int>& ch = db->FindObject(idxsr[i])->children;
	bool doit = true;
	for (size_t j=0; doit && j<ch.size(); j++)
	  if (db->ObjectsTargetTypeContains(ch[j], target_image))
	    if (db->Label(ch[j]).find(":kf")==string::npos)  // obs!
	      doit = false;
	if (doit || force)
	  idxs.push_back(idxsr[i]);
      }

    if (Picsom()->HasSlaves() && idxs.size()>1) {
      script_list_t sl;

      list<string> s = script;
      for (auto i=s.begin(); i!=s.end();)
	if (i->find("args=")==0)
	  i = s.erase(i);
	else
	  i++;

      for (size_t i=0; i<idxs.size(); i++) {
	string a = "#"+ToStr(idxs[i]);
	list<string> sx = s;
	sx.push_back("args="+a);
	script_list_e ae = make_pair("insertsubobjects-"+a,
				     make_pair(sx, vector<string>()));
	sl.push_back(ae);
      }

      list<analyse_result> ar = Analyse(sl, true, false);

      WriteLog("Slaved subobject insertion resulted in "+
	       ToStr(slave_objectinfos_stored)+" subobjects of "+
	       ToStr(idxs.size())+" objects being inserted");

      return true;
    }
    
    InitializeXmlResult(true);
    XmlDom resoih = xml_result.Root().Element("objectinfohashlist");
    XmlDom resoci = xml_result.Root().Element("objectchildinfolist");

    bool do_pipe = Picsom()->IsSlave()&&
      Picsom()->SlavePipe().find("objectinfo")!=string::npos;
    bool use_transaction = !do_pipe;

    if (use_transaction && !db->SqlBeginTransaction())
      return ShowError(msg+"SqlBeginTransaction() failed");

    for (size_t i=0; i<idxs.size(); i++) {
      bool is_video    = db->ObjectsTargetTypeContains(idxs[i], target_video);
      bool is_imageset = db->ObjectsTargetTypeContains(idxs[i], target_imageset);
      if (!is_video && !is_imageset)
	continue;

      WriteLog("Starting with "+db->ObjectDump(idxs[i]));
	
      upload_object_data info;
      info.ctype = "video/xxx";
      info.url = db->ObjectPathEvenExtract(idxs[i]);

      int nframes = -1;
      float fps = 0;
      
      map<string,string> ohash = db->ReadOriginsInfo(idxs[i], false, true);
      string dim = ohash["dimensions"];
      size_t at = dim.find('@');
      if (at!=string::npos)
	fps = atof(dim.substr(at+1).c_str());

      if (!fps)
	fps = db->FpsCache(idxs[i]);

      if (!fps && is_video) {
	// imagefile imgf(info.url);
	// fps = imgf.video_fps();  // obs! not implemented yet...
	string tmpdir = db->TempDir("insertvideosubs", true);
	videofile fv(info.url, false, tmpdir);
	fps = fv.get_frame_rate(); // obs! this should be stored...
	db->FpsCache(idxs[i], fps);
      }      

      if (!fps && is_video) {
	ShowError(msg+"frame rate for <"+Label(idxs[i])+"> not solved");
	// return false;
	continue;
      }

      target_type tt = is_video ? target_video : target_imageset;
      bool upp = true; // update also parent....
      if (!db->InsertVideoSubObjects(idxs[i], tt, info, nframes, fps, upp, resoih))
	return ShowError(msg+"InsertVideoSubObjects() failed");

      if (do_pipe) {
	XmlDom oci = resoci.Element("objectchildinfo");
	oci.Prop("parent", "#"+ToStr(idxs[i]));
	oci.Prop("child", ToStr(info.labels));

	return true;

      } else if (!db->AppendSubobjectsFile(idxs[i], info.indices))
	return ShowError(msg+"AppendSubobjectsFile() failed");
    }

    if (use_transaction && !db->SqlEndTransaction())
      return ShowError(msg+"SqlEndTransaction() failed");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCreateTars(const vector<string>&) {
    string msg = "AnalyseCreateTars() : ";
    WriteLog(msg+"starting with featextbatchsize="+ToStr(featextbatchsize));

    DataBase *db = CheckDB();

    if (featextbatchsize<1)
      return ShowError(msg+"featextbatchsize<1");

    if ((size_t)featextbatchsize>db->LabelLength())
      return ShowError(msg+"featextbatchsize>labellength");

    size_t tl = db->LabelLength()-featextbatchsize;
    size_t tlim = (size_t)pow(10.0, tl);

    string op = db->ExpandPath("objects"), opx = op;
    string oploc = db->ConvertGlobalToLocalDiskName(op);
    string tard = db->ExpandPath("tars");
    if (!Picsom()->MkDirHier(tard, 02775))
      return ShowError(msg+"MkDirHier("+tard+") failed");

    for (size_t t=0; t<tlim; t++) {
      char tmp[100];
      sprintf(tmp,"/^%0*d/", (int)tl, (int)t);
      string ts = tl ? tmp : "/.*/";
      ground_truth gt = db->GroundTruthExpression(ts);
      gt = gt.TernaryAND(QueryRestrictionGT());
      for (size_t i=0; i<gt.size(); i++) // obs! hard-coded target=image
	if (gt[i]==1 && !db->ObjectsTargetTypeContains(i, target_image))
	  gt[i] = -1;
      vector<size_t> idxs = gt.indices(1);
      cout << t << "/" << tlim << " " << ts << " " << idxs.size() << endl;
      if (idxs.size()==0)
	continue;

      sprintf(tmp,"%0*d", (int)tl, (int)t);
      string tx = tmp;
      while (tx.size()<db->LabelLength())
	tx += "x";
      string txx = db->Name();
      if (tl)
	txx += string("-")+tx;

      string tarn = tard+"/"+txx+".tar";
      string flistn = db->TempFile("tar-list/"+ToStr(t)+".txt");
      cout << "t=" << t << "/" << tlim
	   << " ts=" << ts << " : " << idxs.size()
	   << " " << flistn << " " << tarn << endl;
      
      if (FileExists(tarn)) {
	cout << tarn << " exists, skipping..." << endl;
	continue;
      }	

      ofstream flist(flistn);
      for (size_t i=0; i<idxs.size(); i++) {
	size_t idx = idxs[i];
	string p = db->ObjectPathEvenExtract(idx);
	if (p=="") {
	  // return ShowError(msg+"path of #"+ToStr(idx)+" unsolved");
	  cout << "path of #"+ToStr(idx)+" unsolved" << endl;
	  continue;
	}

	if (p.substr(0, op.size())!=op && p.substr(0, oploc.size())!=oploc)
	  return ShowError(msg+"path of #"+ToStr(idx)+" <"+p+
			   "> doesn't start with <"+op+"> nor <"+
			   oploc+">");
	if (p.substr(0, op.size())==op)
	  flist << p.substr(op.size()+1) << endl;
	else {
	  flist << p.substr(oploc.size()+1) << endl;
	  opx = oploc;
	}
      }
      flist.close();

      vector<string> cmd {
	"cd", opx, "&&", "tar", "-cf", tarn+".tmp", "-T", flistn
	  };
      if (Picsom()->ExecuteSystem(cmd, true, true, true))
	return ShowError(msg+"tar creation failed");
      if (!Rename(tarn+".tmp", tarn))
	return ShowError(msg+"rename of tar.tmp failed");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseDefineClass(const vector<string>&
							args) {
    WriteLog("AnalyseDefineClass() starting, class=", classname);

    DataBase *db = CheckDB();
    bool ok = true;
    for (size_t i=0; i<args.size(); i++) 
      if (ok) {
	WriteLog("AnalyseDefineClass() processing i=", 
		 ToStr(i), ", ",  args[i]);
	ok = db->AppendToMetaClassFile(classname, args[i], true);
      }

    if (!ok)
      SetXmlResultError("Analysis::AnalyseDefineClass()");
    else
      SetXmlResultOK();
    
    WriteLog("AnalyseDefineClass() ending");
    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseSegmentDetectCommon(const vector<string>& args,
				       bool do_seg, bool do_det) {
    string msg = "Analysis::AnalyseSegmentDetectCommon() : ";
    
    if (!do_seg && !do_det)
      return ShowError(msg+"operation not specified");

    WriteLog(msg+"starting");

    DataBase *db = CheckDB();

    size_t n = Nindices();
    if (!n && detections.size()==1 && detections[0].find("f::")==0)
      n = 1;
    n *= detections.size();
    if (classname!="")
      n *= db->SplitClassNames(classname).size();
    else
      n = 0;

    if (Picsom()->HasSlaves() && do_det && n) {
      if (true || n>1)
        return AnalyseSegmentDetectCommonSlaves(args, do_seg, do_det);
    }

    if (false && db->SqlMode()!=2)
      return ShowError(msg+"should be in SQL write mode");

    ground_truth gt = QueryRestrictionGT();
    ground_truth_list gtl;
    AddGroundTruthInfo(gtl, "queryrestriction", gt);
    list<string> extra;
    string mstr;
    query->WriteAnalyseVariablesNew("SegmentDetectCommon",
				    mstr, gtl, extra);

    vector<size_t> idxs = gt.indices(1);

    Analysis ana(Picsom(), NULL, NULL, vector<string>());
    AddDescription *ad = NULL;
    segmentfile *image = NULL;
    bool do_ad = false;
    // bool do_ad = CanDoDetections() && detect.size() &&
    //   storedetections.find("seg")!=string::npos;
    if (do_ad && !ana.OpenAddDescription(ad, image, "outseg"))
      return ShowError(msg+"OpenAddDescription() failed");
     
    if (verbose>1) {
      if (do_seg)
	cout << "segmentations";
      if (do_seg && do_det)
	cout << " and ";
      if (do_det)
	cout << "detections";
      cout << " to be done to this set:" << endl;
      db->GroundTruthSummary(gt);
    }

    if (do_seg) {
      // bool force = false;
      db->DoAllSegmentations(force, idxs, segmentations);
    }

    if (verbose>2) {
      db->GroundTruthSummary(QueryRestrictionGT());
      cout << endl;
    }

    QueryRestrictionGT(true);

    if (verbose>2) {
      db->GroundTruthSummary(QueryRestrictionGT());
      cout << endl;
      // cout << db->ObjectDump(0) << endl;
    }

    if (extractfeatures && !ExtractFeatures(*query))
      return ShowError(msg+"ExtractFeatures() failed");

    bool ret = true;
    if (do_det) {
      if (args.size()) {
	idxs.clear();
	for (auto i=args.begin(); i!=args.end(); i++) {
	  int idx = db->LabelIndex(*i);
	  if (idx<0)
	    return ShowError(msg+"LabelIndex("+*i+") failed");
	  idxs.push_back(idx);
	}
      }

      if (idxs.size()==0)
	return ShowError(msg+"index set for detections is empty");

      list<string> feats = query->IndexFullNamesNew();
      // bool force = false;

      string idxstxt = idxs.size()<5 ? ToStr(idxs) :
	ToStr(idxs.front())+" ... "+ToStr(idxs.back())+" (total "+
	ToStr(idxs.size())+")";

      WriteLog("Doing detections=["+ToStr(detections)+"] with features=["
	       +ToStr(feats)+"] and class=["+ToStr(classname)
	       +"] on indices=["+idxstxt+"] gpupolicy="+
	       ToStr(Picsom()->GpuPolicy())+" gpudevice="+
	       ToStr(Picsom()->GpuDeviceId()));

      if (!HasXmlResult())
	InitializeXmlResult(true);
      XmlDom resdet = xml_result.Root().Element("detectionvectorlist");

      PicSOM::detection_stat_t& dstat = detection_stat;
      ret = db->DoAllDetections(force, idxs, detections, classname,
				instance, feats, featureaugmentation, 
				tolerate_missing_features, ad, resdet, dstat);

      XmlDom detsum = xml_result.Root().Element("detectionsummary");
      detsum.Prop("status", ret?"ok":"failed");

      detsum.Prop("total_objects",    idxs.size());
      detsum.Prop("total_detections", detections.size());
      detsum.Prop("total_features",   feats.size());
      detsum.Prop("total_classes",    db->SplitClassNames(classname
							  ).size());
      detsum.Prop("sum_jobs",      dstat.njobs);
      detsum.Prop("sum_processed", dstat.ntot);
      detsum.Prop("sum_skipped",   dstat.nskip);
      detsum.Prop("sum_found",     dstat.nfound);
      detsum.Prop("sum_nodata",    dstat.nnodata);
      detsum.Prop("sum_done",      dstat.ndone);
    }  

    if (ad) {
      ana.CloseSegmentation(ad, image);
      // plus something more in DataBase::InsertObjectsProcessing()
    }

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result 
  Analysis::AnalyseSegmentDetectCommonSlaves(const vector<string>& /*args*/,
					     bool do_seg, bool do_det) {
    string msg = "Analysis::AnalyseSegmentDetectCommonSlaves() : ";
    
    if (!do_seg && !do_det)
      return ShowError(msg+"operation not specified");

    WriteLog(msg+"starting");

    DataBase *db = CheckDB();

    script_exp_t plist = ScriptExpand(script, false);
    ScriptReplace(plist, "detections", "", false, false);
    ScriptReplace(plist, "features",   "", false, false);
    ScriptReplace(plist, "class",      "", false, false);
    list<string> newscript = ScriptUnExpand(plist);
    newscript.push_back("*LIST*");

    size_t ntot = 0;
    for (auto d=detections.begin(); d!=detections.end(); d++) {
      map<string,string> m = db->DescribedDetection(*d);
      vector<string> detfea = SplitInCommas(m["features"]);
      
      if (query->NindicesNew()) {
	detfea.clear();
	for (size_t fi=0; fi<query->NindicesNew(); fi++) {
	  const string& f = query->vectorIndex(fi).IndexName();
	  detfea.push_back(f);
	}
      }

      bool has_fea = detfea.size();
      if (detfea.size()==0) {
	detfea.push_back("");
	// return ShowError(msg+"features not specified");
      }

      vector<string> detcls = SplitInCommas(m["class"]);
      if (classname!="") {
	list<string> cnl = db->SplitClassNames(classname);
	detcls = vector<string>(cnl.begin(), cnl.end());
      }

      if (detcls.size()==0)
	return ShowError(msg+"class not specified");

      for (auto ff=detfea.begin(); ff!=detfea.end(); ff++)
	for (auto cc=detcls.begin(); cc!=detcls.end(); cc++) {
	  string ss = "* detections="+*d+" ; class="+*cc;
	  if (has_fea)
	    ss += " ; features="+*ff;
	  cout << ss << endl;
	  newscript.push_back(ss);
	  ntot++;
	}
      WriteLog("detections="+*d+" : "+ToStr(detfea.size())+" features x "+
	       ToStr(detcls.size())+" classes, total "+ToStr(detfea.size()*
							     detcls.size()));
    }
    WriteLog("Total "+ToStr(ntot)+" tasks");

    vector<string> argv = DashedExtraArguments();
    Analysis a(Picsom(), this, NULL, argv);
    a.Script(newscript); 
    a.Analyse();

    const PicSOM::detection_stat_t& dstat = a.DetectionStat();
    WriteLog(msg+"Total summary:"
	     +"\n  tasks  = "+ToStr(ntot)
	     +"\n  jobs   = "+ToStr(dstat.njobs)
	     +"\n  ok     = "+ToStr(dstat.nok)
	     +"\n  failed = "+ToStr(dstat.nfailed)
	     +"\n  tot    = "+ToStr(dstat.ntot)
	     +"\n  skip   = "+ToStr(dstat.nskip)
	     +"\n  found  = "+ToStr(dstat.nfound)
	     +"\n  nodata = "+ToStr(dstat.nnodata)
	     +"\n  done   = "+ToStr(dstat.ndone));

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalysePDF(const vector<string>&) {
    string msg = "Analysis::AnalysePDF() : ";
    WriteLog(msg+"starting");

    DataBase *db = CheckDB();

    string l = "svm";
    string f = "ColorSIFTds-soft90-1x1-2x2";
    string e = ""; // "-hkm-int"
    string c = "lscom003";
    string a = SVMparams();
    string inst;

    list<pair<string,string> > kv;
    kv.push_back(make_pair("${svmlibrary}", l));
    kv.push_back(make_pair("${feat}",       f));
    kv.push_back(make_pair("${cname}",      c));
    kv.push_back(make_pair("${restr}",      ""));
    kv.push_back(make_pair("${svmparams}",  "kernel_type=CHISQUARED"));

    db->SvmCommon(kv);

    string svmopts = ""; // obs!
    SVM *svm = db->GetSVM(l, f, svmopts, e, c, inst, a);
    svm->AnalysePDF(100);

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseSentenceCandidates(const vector<string>& /*args*/) {
    string msg = "Analysis::AnalyseSentenceCandidates() : ";

    size_t max_n_per_image = 5;

    if (filename=="")
      return ShowError(msg+"filename should be specified");

    if (detections.size()==0)
      return ShowError(msg+"detections should be specified");

    WriteLog(msg+"starting");

    DataBase *db = CheckDB();

    ofstream out(filename);

    ground_truth qr = QueryRestrictionGT();
    vector<size_t> idxs = qr.indices(1);
    WriteLog("  queryrestriction=\""+qr.label()+"\" expands to "
	     +ToStr(idxs.size())+" image objects");

    for (size_t i=0; i<idxs.size(); i++) {
      size_t idx = idxs[i];

      set<string> candidates;
      for (auto dd=detections.begin(); dd!=detections.end(); dd++) {
	string spec = "gene-"+*dd;
	bool angry = false;
	textline_t tl = db->ObjectTextLineRetrieve(idx, "", spec, angry);
	// cout << "#" << idx << " <" << *dd << "> " << tl.str() << endl;

	for (size_t j=0; j<tl.txt_val.size() && j<max_n_per_image; j++)
	  candidates.insert(tl.txt_val[j].first);
      }

      for (auto j=candidates.begin(); j!=candidates.end(); j++)
	out << db->Label(idx) << "," << *j << "," << idx << endl;
    }

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  list<Analysis::analyse_result>
  Analysis::SplitSlavesAndAnalyse(const vector<size_t>& idxs,
				  const list<string>& scr,
				  const string& suff) {
    size_t per_job = 1;
    for (int i=0; i<featextbatchsize; i++)
      per_job *= 10;

    script_list_t sl;

    list<string> s = scr;
    for (auto i=s.begin(); i!=s.end();)
      if (i->find("args=")==0)
	i = s.erase(i);
      else
	i++;

    size_t njobs = (idxs.size()+per_job-1)/per_job, i = 0;
    for (size_t j=0; j<njobs; j++) {
      string a;
      size_t k = 0;
      while (i<idxs.size() && k<per_job)
	a += string(k++?" ":"")+"#"+ToStr(idxs[i++]);

      list<string> sx = s;
      sx.push_back("args="+a);
      script_list_e ae = make_pair(suff+"-"+a,
				   make_pair(sx, vector<string>()));
      sl.push_back(ae);
    }

    return Analyse(sl, true, false);
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCaptioning(const vector<string>& args) {
    string msg = "Analysis::AnalyseCaptioning() : ";

    WriteLog(msg+"starting");

    if (captionings.empty())
      return ShowError(msg+"captionings should be specified");

    DataBase *db = CheckDB();

    vector<size_t> idxs;
    for (size_t i=0; i<args.size(); i++)
      if (args[i][0]!='#')
	break;
      else
	idxs.push_back(db->LabelIndex(args[i]));

    if (idxs.empty())
      idxs = QueryRestrictionGT().indices(1);
    if (idxs.empty())
      return ShowError(msg+"no objects found by target and queryrestriction");

    if (Picsom()->HasSlaves() && idxs.size()>1) {
      list<analyse_result> ar = SplitSlavesAndAnalyse(idxs, script, 
						      "captioning");

      WriteLog("Slaved captioning resulted in "+
	       ToStr(slave_captions_stored)+" captions for "+
	       ToStr(idxs.size())+" objects being sored");

      return true;
    }

    if (!HasXmlResult())
      InitializeXmlResult(true);
    XmlDom rescap = xml_result.Root().Element("captionlist");

    if (!db->DoAllCaptionings(force, idxs, captionings, use_textindex, rescap))
      return ShowError(msg+"failed");

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseInsertSentences(const vector<string>& args) {
    string msg = "Analysis::AnalyseInsertSentences() : ";

    WriteLog(msg+"starting");

    if (segmentspec=="")
      return ShowError(msg+"segmentspec should be specified");

    DataBase *db  = CheckDB();

    if (args.size()<2)
      return ShowError(msg+"at least two arguments are needed");

    string type = args[0];
    if (type!="gene" && type!="eval")
      return ShowError(msg+"first argument should be 'gene' or 'eval'");

    string meth = args[1];
    if (meth!="neuraltalk" && meth!="COCOsubmission" && meth.find("NN")!=0)
      return ShowError(msg+"second argument should be 'neuraltalk' or 'NN'"
		       " or 'COCOsubmission'");

    auto ai = args.begin();
    ai++; ai++;
    list<string> alist(ai, args.end());

    ground_truth qr = QueryRestrictionGT();
    vector<size_t> idxs = qr.indices(1);
    WriteLog("  queryrestriction=\""+qr.label()+"\" expands to "
	     +ToStr(idxs.size())+" image objects");

    map<size_t,textline_t> ss;

    if (meth=="neuraltalk")
      ss = db->ReadSentencesNeuralTalk(alist);

    if (meth=="COCOsubmission")
      ss = db->ReadSentencesCOCOsubmission(alist);

    if (meth.find("NN")==0) {
      size_t k = meth.size()>2 ? atoi(meth.substr(2).c_str()) : 1;

      string fea = segmentspec;
      size_t p = fea.rfind('+');
      if (p!=string::npos)
	fea.erase(p);
      vector<string> feal { fea };
      query->SelectIndices(NULL, feal, true, false);

      Index *idata = db->FindIndex(fea, "", true);
      VectorIndex *vi = dynamic_cast<VectorIndex*>(idata);
      vi->ReadDataFile(false, false);
      vi->SetDataSetNumbers(false, true);
      FloatVectorSet& data = vi->Data();

      FloatVectorSet trainset;
      ground_truth train = db->GroundTruthExpression("train");
      for (size_t i=0; i<train.size(); i++)
	if (train[i]==1) {
	  FloatVector *v = (FloatVector*)data.GetByNumber(i);
	  if (!v)
	    return ShowError(msg+"data vector for #"+ToStr(i)+
			     " <"+fea+"> not available");

	  trainset.Append((FloatVector*)data.GetByNumber(i), false);
	}

      cout << data.Nitems() << " " << trainset.Nitems()
	   << " " << idxs.size() << endl;

      for (auto i=idxs.begin(); i!=idxs.end(); i++) {
	size_t idx = *i;

	const FloatVector& v = *data.GetByNumber(idx);
	IntVector res(k);
	FloatVector dist;
	if (!trainset.NearestNeighbors(v, res, dist))
	  return ShowError(msg+"NN() failed");

	//  obs! should this use DataBase::TextIndexLine()?
	auto d = db->TextIndexRetrieve(res[k-1], "sentences");
	map<string,string> m(d.begin(), d.end());
	string concat = m["text"];
	cout << "  #" << idx << " " << res[k-1] << " " << concat << endl;

	vector<string> pp = SplitOnWord(" # ", concat);
	for (auto pi=pp.begin(); pi!=pp.end(); pi++) {
	  if (ss.find(idx)==ss.end())
	    ss[idx] = textline_t(db, idx);
	  textline_t& tl = ss.at(idx);
	  tl.add(*pi, 0);
	}
      }
    }

    string odir = outdir=="" ? "" : OutDirEvenDot();
    bool ok = db->StoreSentences(segmentspec, type, idxs, ss, odir);
     
    WriteLog(msg+"ending");
    
    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseEvaluateSentences(const vector<string>& args) {
    string msg = "Analysis::AnalyseEvaluateSentences() : ";

    bool show_words = false;
    size_t cand_max   = 1;
    float bleu_rat = 0;

    if (segmentspec!="")
      return ShowError(msg+"segmentspec should NOT be set, use detections");

    DataBase *db  = CheckDB();

    ground_truth gt(db->Size());
    for (auto a=args.begin(); a!=args.end(); a++) {
      if (a->find("max=")==0) {
	cand_max = atoi(a->substr(4).c_str());
	continue;
      }
      if (a->find("rat=")==0) {
	bleu_rat = atof(a->substr(4).c_str());
	continue;
      }

      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }
    vector<size_t> vidx = gt.indices(1);

    WriteLog(msg+"starting, max="+ToStr(cand_max)+" rat="+ToStr(bleu_rat));

    map<string,double> res;
    for (auto i=detections.begin(); i!=detections.end(); i++)
      res[*i] = 1;
    res["oracle"] = 1;	
    map<string,size_t> hits;

    string reftmp = "sentences/reference";
    if (keeptmp)
      Picsom()->MkDir("sentences", 02775);
    else
      reftmp = db->TempFile(reftmp);
    vector<ofstream*> reffile;
    for (size_t ri=0; ri<5; ri++) {
      string reftmp_n = reftmp+ToStr(ri);
      reffile.push_back(new ofstream(reftmp_n));
    }
    
    map<string,string> candidates;

    for (size_t i=0; i<vidx.size(); i++) {
      size_t idx = vidx[i];
      //  obs! should this use DataBase::TextIndexLine()?
      auto d = db->TextIndexRetrieve(idx, "captions");
      map<string,string> m(d.begin(), d.end());
      string concat = m["text"];
      vector<string> pp = SplitOnWord(" # ", concat);
      cout << "#" << idx << " <" << db->Label(idx) << "> : " << endl;
      vector<vector<string> > ref;
      for (size_t j=0; j<pp.size(); j++) {
	vector<string> w = SplitInSpaces(pp[j]);
	ref.push_back(w);
	cout << "  \"" << pp[j] << "\"";
	if (show_words)
	  cout << " ["+JoinWithString(w, "][")+"]";
	cout << endl;
	if (j<5) // obs! COCO-5 specific, how about COCO-40 et al?
	  *reffile[j] << pp[j] << endl;
      }
      cout << endl;

      float max_bleuval = -1;
      string oracle_bleuval;
      multimap<float,string> line_by_lp;
      map<string,string> line;
      vector<pair<string,vector<string> > > split_line;
      for (auto qq=detections.begin(); qq!=detections.end(); qq++) {
	string spec = *qq; // no "gene-"+ here
	textline_t tl = db->ObjectTextLineRetrieve(idx, "", spec, true);
	for (size_t m=0; m<tl.txt_val.size() && m<cand_max; m++) {
	  string q = *qq+"@"+ToStr(m), txt = tl.txt_val[m].first;
	  double val = tl.txt_val[m].second;

	  vector<string> s = SplitInSpaces(txt);
	  split_line.push_back(make_pair(q, s));
	  vector<float> bleu = BLEUvalue(s, ref);
	  float bleuval = 0, bleumul = 1;
	  for (size_t bc=0; bc<bleu.size(); bc++, bleumul*=bleu_rat)
	    bleuval += bleumul*bleu[bc];
	  if (bleuval>max_bleuval) {
	    max_bleuval = bleuval;
	    oracle_bleuval = q;
	  }

	  cout << "<" << db->Label(idx) << "> \"" << q << "\"";
	  if (show_words)
	    cout <<" ["+JoinWithString(s, "][")+"]";
	  else
	    cout <<" "+JoinWithString(s, " ");
	  cout << " (" << val << ") BLEU=" << bleu[0] << "/" << bleu[1] << "/"
	       << bleu[2] << "/" << bleu[3] << endl;

	  line[q] = txt;
	  candidates[q] += txt+"\n";
	  line_by_lp.insert(make_pair(val, txt));
	}
      }

      candidates["oracle_bleu"] += line[oracle_bleuval]+"\n";
      size_t lpi = 0;
      for (auto c=line_by_lp.rbegin(); c!=line_by_lp.rend(); c++, lpi++)
	candidates["lp_"+ToStr(lpi)] += c->second+"\n";

      multimap<float,string> line_by_bleuval;
      for (size_t c=0; c<split_line.size(); c++) {
	// size_t rank = 0, p = split_line[c].first.find('@');
	// if (p!=string::npos)
	//   rank = atoi(split_line[c].first.substr(p+1).c_str());

	vector<vector<string> > cref;
	for (size_t d=0; d<split_line.size(); d++)
	  if (d!=c)
	    cref.push_back(split_line[d].second);
	vector<float> bleu = BLEUvalue(split_line[c].second, cref);
	float bleuval = 0, bleumul = 1;
	for (size_t bc=0; bc<bleu.size(); bc++, bleumul*=bleu_rat)
	  bleuval += bleumul*bleu[bc];
	vector<string> parts = split_line[c].second;
	parts.erase(parts.begin()+parts.size()-1); // obs! check ()'s
	string lll = JoinWithString(parts, " ");
	line_by_bleuval.insert(make_pair(bleuval, lll));
      }
      lpi = 0;
      for (auto c=line_by_bleuval.rbegin(); c!=line_by_bleuval.rend();
	   c++, lpi++)
	candidates["bleu_"+ToStr(lpi)] += c->second+"\n";
    }

    for (size_t ri=0; ri<5; ri++)
      delete reffile[ri];

    cout << endl;
    for (auto q=candidates.begin(); q!=candidates.end(); q++) {
      string candtmp = "sentences/"+q->first;
      if (!keeptmp)
	candtmp = db->TempFile(candtmp);
      if (!StringToFile(q->second, candtmp))
	return ShowError(msg+"failed to write in <"+candtmp+">");
      string multibleu = Picsom()->Path()+"/databases/COCO/neuraltalk/"
	"neuraltalkTheanoRepo/eval/multi-bleu.perl"; 
      vector<string> cmd { multibleu, reftmp, "<", candtmp};
      auto r = Picsom()->ShellExecute(cmd, true, false);
      if (!r.first || r.second.size()<2)
	return ShowError(msg+"ShellExecute() failed");

      cout << q->first << " : " << r.second[0] << endl;
    }
    cout << endl;

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseBLEUdeprecated(const vector<string>& args) {
    string msg = "Analysis::AnalyseBLEU() : ";

    bool show_words = false;
    size_t cand_max   = 1;
    size_t cand_among = 1;
    float bleu_rat = 0;

    if (segmentspec=="")
      return ShowError(msg+"segmentspec should be set");

    DataBase *db  = CheckDB();

    ground_truth gt(db->Size());
    for (auto a=args.begin(); a!=args.end(); a++) {
      if (a->find("max=")==0) {
	cand_max = atoi(a->substr(4).c_str());
	continue;
      }
      if (a->find("among=")==0) {
	cand_among = atoi(a->substr(6).c_str());
	continue;
      }
      if (a->find("rat=")==0) {
	bleu_rat = atof(a->substr(4).c_str());
	continue;
      }

      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }
    vector<size_t> vidx = gt.indices(1);

    WriteLog(msg+"starting, cand_max="+ToStr(cand_max)
	     +" cand_among="+ToStr(cand_among));

    vector<string> segms = SplitInSomething(",", false, segmentspec);
    map<string,double> res;
    for (auto i=segms.begin(); i!=segms.end(); i++)
      res[*i] = 1;
    res["oracle"] = 1;	
    map<string,size_t> hits;

    string reftmp = "sentences/reference";
    if (keeptmp)
      Picsom()->MkDir("sentences", 02775);
    else
      reftmp = db->TempFile(reftmp);
    vector<ofstream*> reffile;
    for (size_t ri=0; ri<5; ri++) {
      string reftmp_n = reftmp+ToStr(ri);
      reffile.push_back(new ofstream(reftmp_n));
    }
    
    map<string,string> candidates;

    for (size_t i=0; i<vidx.size(); i++) {
      size_t idx = vidx[i];
      //  obs! should this use DataBase::TextIndexLine()?
      auto d = db->TextIndexRetrieve(idx, "sentences");
      map<string,string> m(d.begin(), d.end());
      string concat = m["text"];
      vector<string> pp = SplitOnWord(" # ", concat);
      cout << "#" << idx << " <" << db->Label(idx) << "> : " << endl;
      vector<vector<string> > ref;
      for (size_t j=0; j<pp.size(); j++) {
	vector<string> w = SplitInSpaces(pp[j]);
	ref.push_back(w);
	cout << "  \"" << pp[j] << "\"";
	if (show_words)
	  cout << " ["+JoinWithString(w, "][")+"]";
	cout << endl;
	if (j<5)
	  *reffile[j] << pp[j] << endl;
      }
      cout << endl;

      float max_bleuval = -1;
      string oracle_bleuval;
      multimap<float,string> line_by_lp;
      map<string,float> comb_by_cand;
      map<string,string> line;
      vector<pair<string,vector<string> > > split_line;
      float lp_div = 1000;
      for (auto qq=segms.begin(); qq!=segms.end(); qq++) {
	string sfile = db->ObjectTextFileSubdirPath(idx, "", *qq);
	string ssss = FileToString(sfile);
	if (ssss=="")
	  return ShowError(msg+"<"+sfile+"> is empty/inexistent");
	size_t p = ssss.find('\n');
	if (p!=ssss.size()-1)
	  return ShowError(msg+"<"+sfile+"> only \\n not the last character");
	ssss.erase(p);
	
	vector<string> multsent = SplitOnWord(" # ", ssss);
	for (size_t m=0; m<multsent.size() && m<cand_max; m++) {
	  string q = *qq+"@"+ToStr(m);

	  vector<string> s = SplitInSpaces(multsent[m]);
	  split_line.push_back(make_pair(q, s));

	  string inpar;
	  if (s.size()>1) {
	    const string& x = s[s.size()-1];
	    if (x[0]=='(' && x[x.size()-1]==')') {
	      inpar = x;
	      s.erase(s.begin()+s.size()-1);
	    }
	  }
	  string cl = JoinWithString(s, " ");

	  float lp = 1;
	  if (inpar!="") {
	    lp = atof(inpar.substr(1).c_str());
	    line_by_lp.insert(make_pair(lp, cl));
	    comb_by_cand[q] = lp/lp_div;;
	  }
	  vector<float> bleu = BLEUvalue(s, ref);
	  float bleuval = 0, bleumul = 1;
	  for (size_t bc=0; bc<bleu.size(); bc++, bleumul*=bleu_rat)
	    bleuval += bleumul*bleu[bc];
	  if (bleuval>max_bleuval) {
	    max_bleuval = bleuval;
	    oracle_bleuval = q;
	  }

	  cout << "<" << db->Label(idx) << "> \"" << q << "\"";
	  if (show_words)
	    cout <<" ["+JoinWithString(s, "][")+"]";
	  else
	    cout <<" "+JoinWithString(s, " ");
	  cout << " (" << lp << ") BLEU="
	       << bleu[0] << "/" << bleu[1] << "/"
	       << bleu[2] << "/" << bleu[3] << endl;

	  line[q] = cl;
	  candidates[q] += cl+"\n";
	}
      }

      candidates["oracle_bleu"] += line[oracle_bleuval]+"\n";
      size_t lpi = 0;
      for (auto c=line_by_lp.rbegin(); c!=line_by_lp.rend(); c++, lpi++)
	candidates["lp_"+ToStr(lpi)] += c->second+"\n";

      multimap<float,string> line_by_bleuval;
      for (size_t c=0; c<split_line.size(); c++) {
	size_t rank = 0, p = split_line[c].first.find('@');
	if (p!=string::npos)
	  rank = atoi(split_line[c].first.substr(p+1).c_str());
	if (rank>=cand_among)
	  continue;

	vector<vector<string> > cref;
	for (size_t d=0; d<split_line.size(); d++)
	  if (d!=c)
	    cref.push_back(split_line[d].second);
	vector<float> bleu = BLEUvalue(split_line[c].second, cref);
	float bleuval = 0, bleumul = 1;
	for (size_t bc=0; bc<bleu.size(); bc++, bleumul*=bleu_rat)
	  bleuval += bleumul*bleu[bc];
	vector<string> parts = split_line[c].second;
	parts.erase(parts.begin()+parts.size()-1); // obs! check ()'s
	string lll = JoinWithString(parts, " ");
	line_by_bleuval.insert(make_pair(bleuval, lll));
	comb_by_cand[split_line[c].first] += bleuval;
      }
      lpi = 0;
      for (auto c=line_by_bleuval.rbegin(); c!=line_by_bleuval.rend();
	   c++, lpi++)
	candidates["bleu_"+ToStr(lpi)] += c->second+"\n";

      multimap<float,string> line_by_comb;
      for (auto c=comb_by_cand.begin(); c!=comb_by_cand.end(); c++)
	line_by_comb.insert(make_pair(c->second, c->first));
      lpi = 0;
      for (auto c=line_by_comb.rbegin(); c!=line_by_comb.rend(); c++, lpi++)
	candidates["comb_"+ToStr(lpi)] += line[c->second]+"\n";
    }

    for (size_t ri=0; ri<5; ri++)
      delete reffile[ri];

    cout << endl;
    for (auto q=candidates.begin(); q!=candidates.end(); q++) {
      string candtmp = "sentences/"+q->first;
      if (!keeptmp)
	candtmp = db->TempFile(candtmp);
      if (!StringToFile(q->second, candtmp))
	return ShowError(msg+"failed to write in <"+candtmp+">");
      string multibleu = Picsom()->Path()+"/databases/COCO/neuraltalk/"
	"neuraltalkTheanoRepo/eval/multi-bleu.perl"; 
      vector<string> cmd { multibleu, reftmp, "<", candtmp};
      auto r = Picsom()->ShellExecute(cmd, true, false);
      if (!r.first || r.second.size()<2)
	return ShowError(msg+"ShellExecute() failed");

      cout << q->first << " : " << r.second[0] << endl;
    }
    cout << endl;

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  vector<float> Analysis::BLEUvalue(const vector<string>& w, 
				    const vector<vector<string> >& r) {
    string msg = "Analysis::BLEUvalue() : ";

    vector<float> v, ret;
    for (size_t i=0; i<4; i++) {
      v.push_back(BLEUvalue(w, r, i));
      double prod = 1;
      for (auto j=v.begin(); j!=v.end(); j++)
	prod *= *j;
      ret.push_back(pow(prod, 1.0/v.size()));
    }

    return ret;
  }

  /////////////////////////////////////////////////////////////////////////////

  float Analysis::BLEUvalue(const vector<string>& w, 
			    const vector<vector<string> >& r, size_t n) {
    string msg = "Analysis::BLEUvalue() : ";

    bool debug = false; // verbose>1;

    vector<string> ww;
    for (size_t i=0; i<w.size()-n; i++) {
      string a = w[i];
      for (size_t j=i+1; j<=i+n; j++)
	a += " "+w[j];
      ww.push_back(a);
    }

    vector<vector<string> > rr;
    for (size_t k=0; k<r.size(); k++) {
      vector<string> zz;
      for (size_t i=0; i<r[k].size()-n; i++) {
	string a = r[k][i];
	for (size_t j=i+1; j<=i+n; j++)
	  a += " "+r[k][j];
	zz.push_back(a);
      }
      rr.push_back(zz);
    }

    map<string,size_t> max;
    for (size_t i=0; i<ww.size(); i++) {
      for (size_t k=0; k<rr.size(); k++) {
	size_t n = 0;
	for (size_t l=0; l<rr[k].size(); l++)
	  if (rr[k][l]==ww[i])
	    n++;
	if (n>max[ww[i]])
	  max[ww[i]] = n;
      }
      if (debug)
	cout << ww[i] << "=" << max[ww[i]] << endl;
    }

    map<string,size_t> used;
    size_t nfound = 0;
    for (size_t i=0; i<ww.size(); i++) {
      bool found = false;
      for (size_t k=0; !found && k<rr.size(); k++)
	for (size_t l=0; !found && l<rr[k].size(); l++)
	  found = rr[k][l]==ww[i];

      bool exceed = found && used[ww[i]]>=max[ww[i]];
      used[ww[i]]++;

      nfound += found && !exceed;

      if (debug)
	cout << ww[i] << " " << (found?"FOUND":"NOTFOUND")
	     << " " << (exceed?"EXCEEDS":"NOTEXCEEDS") << " ";
    }

    float p = float(nfound)/ww.size();
    if (debug)
      cout << " p=" << nfound << "/" << ww.size() << "=" << p << endl;

    return p;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTextWash(const vector<string>& args) {
    string msg = "Analysis::AnalyseTextWash() : ";

    WriteLog(msg+"starting");

    if (args.size()!=1)
      return ShowError(msg+"one argument <*textindex> or <string> needed"); 

    string spec = "";
    
    bool is_textindex = false;
    string out = args[0];
    if (out[0]=='*') {
      is_textindex = true;
      out.erase(0, 1);
    }

    DataBase *db  = CheckDB();

    if (is_textindex && !db->HasTextIndex(out))
      return ShowError(msg+"textindex <"+out+"> unknown");

    string ti = GetQuery()->TextIndex();
    if (ti=="")
      return ShowError(msg+"textindex should be specified");
    
    const ground_truth& qgt = QueryRestrictionGT();
    vector<size_t> idxs = qgt.indices(1);
    for (auto i : idxs) {
      auto rt = db->TextIndexAllLines(ti, i);
      if (rt.size()==0)
	continue;
      
      auto wt = rt;
      textline_t text;
      bool done = false;
      for (auto& j : wt) {
	j.index = out;
	cout   << "   " << j.str_common(true, true, true) << endl;
	if (j.field=="text" && !done) {
	  for (auto& l : j.txt_val)
	    l.first = WashString(l.first, spec);

	  cout << "=> " << j.str_common(true, true, true) << endl;
	  text = j;
	  done = true;
	}
      }

      if (!done)
	return ShowError(msg+"done=false");

      if (is_textindex) {
	if (!WriteOutTextLineData(text))
	  return ShowError(msg+"WriteOutTextLineData() failed");
	
      } else
	cout << "**textentry** " << db->Label(i) << " " << out << " " 
	     << text.txt_encode() << endl;
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTextQuery(const vector<string>& args) {
    string msg = "Analysis::AnalyseTextQuery() : ";

    textsearchspec_t tsp = query->TextSearchParams();

    string queryfield = query->QueryField();

    WriteLog(msg+"starting");

    DataBase *db  = CheckDB();
    string q = query->TextQuery();

    analyse_result result;

    size_t hit_rank = 0;

    bool has_q = q!="";
    for (size_t j=0; j<args.size()+has_q; j++) {
      string s = has_q ? j ? args[j-1] : q : args[j];

      bool done = false;
      size_t p = s.find(' ');
      if (p==string::npos) {
	string cfn = db->ExpandPath("classes", s);
	if (FileExists(cfn) || db->LabelIndexGentle(s)>=0) {
	  ground_truth gt = db->GroundTruthExpression(s);
	  const size_t max_rank = 100;
	  size_t nres = 0, nall = 0, nused = 0;
	  double res = 0.0;

	  for (size_t i=0; i<gt.size(); i++)
	    if (gt[i]==1) {
	      //  obs! should this use DataBase::TextIndexLine()?
	      list<pair<string,string>> doc =
		db->TextIndexRetrieve(i, tsp.textindex);
	      string qs;
	      for (auto k=doc.begin(); k!=doc.end(); k++)
		if (k->first==tsp.queryfield)
		  qs = k->second;

	      size_t nq = 0, qp = 0;
	      for (;;) {
		size_t qp2 = qs.find_first_of("\"'", qp);
		if (qp2==string::npos)
		  break;
		nq++;
		qp = qp2+1;
	      }
	      if (nq%2) 
		for (;;) {
		  size_t qp2 = qs.find_first_of("\"'");
		  if (qp2==string::npos)
		    break;
		  qs.erase(qp2, 1);
	      }

	      string fntmp = filename;
	      size_t l = filename.find("%l");
	      if (l!=string::npos)
		filename.replace(l, 2, db->Label(i));
	      l = filename.find("%4l");
	      if (l!=string::npos) {
		size_t ll = 4;
		string lab = db->Label(i);
		if (lab.size()>ll)
		  lab.erase(0, lab.size()-ll);
		filename.replace(l, 3, lab);
	      }

	      string classtmp = classname;
	      l = classname.find("%l");
	      if (l!=string::npos)
		classname.replace(l, 2, db->Label(i));

	      AnalyseTextQueryInner(i, qs, tsp, hit_rank);
			      
	      classname = classtmp;
	      filename = fntmp;
	      done = true;

	      if (hit_rank>0) {
		nall++;
		if (hit_rank<=max_rank) {
		  nused++;
		  res += 1.0/hit_rank;
		}
	      }
	      nres++;
	    }

	  if (nres) {
	    result.rescount = 1;
	    result.mean_inv_rank = res/nres;
	    stringstream ss;
	    ss << "mean_inv_rank=" << (res/nres) << " res=" << nres
	       << " all=" << nall << " used=" << nused << " alpha=" << alpha;
	    WriteLog(ss.str());
	  }
	}
      }

      if (!done)
	AnalyseTextQueryInner(-1, s, tsp, hit_rank);
    }

    WriteLog(msg+"ending");

    return result;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTextQueryInner(int idx, const string& sin,
				  const textsearchspec_t& tsp,
				  size_t& hit_rank) {
    string msg = "Analysis::AnalyseTextQueryInner() : ";

    bool debug = false;
    bool cleaning = false;

    string txtf = tsp.textfield, idxf = tsp.queryfield, luci = tsp.textindex;

    DataBase *db  = CheckDB();

    WriteLog(msg+(cleaning?"":"NO CLEANING ")+"starting text query \""+sin+
	     "\" with <"+txtf+"> <"+idxf+"> <"+luci+"> in "+db->Name());

    string s = cleaning ? CleanTextQuery(sin) : sin;

    string ti = luci;
    if (ti=="")
      ti = db->DefaultTextIndex();
    
    ground_truth hit = GTExpr(classname);
    bool has_hit = hit.positives()==1;
    string hitlabel;
    if (has_hit)
      hitlabel = db->Label(hit.indices(1).front());

    const ground_truth& gt = QueryRestrictionGT();

    ofstream pref, *pre = NULL;
    if (filename!="") {
      WriteLog(msg+"  writing to <"+filename+">");
      pref.open(filename);
      pre = &pref;
      pref << "# PRECALCULATEDFILE results for \"" << s << "\"" << endl;
      pref << "#" << endl;
      pref << "# database         = " << db->Name()            << endl;
      pref << "# textindex        = " << ti                    << endl;
      pref << "# textfield        = " << txtf                  << endl;
      pref << "# queryfield       = " << idxf                  << endl;
      pref << "# dbrestriction    = " << db->RestrictionName() << endl;
      pref << "# queryrestriction = " << gt.label()            << endl;
      pref << "# class            = " << classname             << endl;
      pref << "# hit              = " << hitlabel              << endl;
    }

    stringstream ss;
    
    vector<textsearchresult_t> out = db->TextIndexSearch(s, ti, txtf);

    if (idx>=0 && Nindices())
      RunAnalyseBestAndCombine(idx, out);

    hit_rank = 0;
    size_t rank = 1;
    bool needsnl = false;
    for (auto i=out.begin(); i!=out.end(); i++)
      if (gt[i->idx]==1) {
	if (pre)
	  ss << i->val << " " << db->Label(i->idx) << endl;
	else if (debug||verbose==2)
	  cout << i->str() << endl;
	else if (verbose>2) {
	  needsnl = true;
	  cout << endl << "*** " << i->idx << " : " << db->Label(i->idx)
	       << " " << i->val << endl;
	  //  obs! should this use DataBase::TextIndexLine()?
	  auto r = db->TextIndexRetrieve(i->idx, ti);
	  for (auto k=r.begin(); k!=r.end(); k++)
	    cout << "  " << k->first << " = " << k->second << endl;
	}

	if (has_hit && hit[i->idx]==1)
	  hit_rank = rank;

	rank++;
      }

    if (needsnl)
      cout << endl;

    if (debug)
      cout << "hit " << (hit_rank>0?"FOUND":"NOT found")
	   << " hit_rank=" << hit_rank << endl;

    if (pre) {
      stringstream msg;
      if (hit_rank>0)
	msg << hit_rank;
      else
	msg << "no hit among " << rank << " results"; 
       pref << "# hit_rank         = " << msg.str() << endl;
      pref << "#" << endl;
      pref << ss.str();
    }

    // WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  string Analysis::CleanTextQuery(const string& sin) {
    bool debug = false;

    list<string> set {
      "Find a ",
	"Find an ",
	"Find the ",
	"Find ",
	"old ",
	"black and white ",
	"funny ",
	"animated ",
	"narrated ",
	"promotional ",
	"video ",
	"about ",
	"depicting ",
	"featuring ",
	"filmed ",
	"through ",
	"from ",
	"giving ",
	"in which ",
	"of ",
	"showing ",
	"that ",
	"discusses ",
	"follows ",
	"shows ",
	"titled ",
	"where ",
	"with ",
	"in black and white ",
	"showing ",
	"no sound ",
	"a ",
	"an ",
	"the ",
	
    };

    string s = sin;

    for (;;) {
      size_t p = s.find('\t');
      if (p==string::npos)
	break;
      s[p] = ' ';
    }
    for (;;) {
      size_t p = s.find("  ");
      if (p==string::npos)
	break;
      s.erase(p, 1);
    }
    while (s.size()&&s[0]==' ')
      s.erase(0, 1);
    while (s.size()&&s[s.size()-1]==' ')
      s.erase(s.size()-1, 1);
      
    for (auto h=set.begin(); h!=set.end(); h++)
      if (s.find(*h)==0)
	s.erase(0, h->size());

    if (debug)
      cout << "TXTQ [" << sin << "]" << endl
	   << "TXTQ  -> [" << s << "]" << endl;

    return s;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseDumpTextIndex(const vector<string>&) {
    string msg = "Analysis::AnalyseDumpTextIndex() : ";
    // hello world

    bool show_logprob = false;
    size_t sl_len = 18, fl_len = 9;

    DataBase *db  = CheckDB();

    ground_truth qrgt = QueryRestrictionGT();
    ground_truth ssgt = qrgt;

    ostream *out = &cout;
    ofstream of;
    size_t nlines = 0;
    if (filename!="") {
      WriteLog("Dumping to <"+filename+">");
      of.open(filename);
      out = &of;
    }

    string ss = segmentspec;
    if (ss[0]=='*')
      ss.erase(0, 1);
    if (ss!="") {
      if (false && Target()!=target_videosegment)
	return ShowError(msg+"with segmentspec only target=videosegment"
			 " is supported");
      string re = "$re(^"+ss+":)";
      ssgt = db->GroundTruthFunction(re, target_videosegment);
    }

    string ti = GetQuery()->TextIndex();

    for (size_t i=0; i<db->Size(); i++)
      if (qrgt[i]==1) {
	if (verbose==1) {
	  if (db->DebugText())
	    WriteLog(msg+"TextIndexLine() called");
	  textline_t t = db->TextIndexLine(ti, "text", i);
	  if (db->DebugText())
	    WriteLog(msg+"TextIndexLine() finished");
	  *out << db->Label(i) << " " << t.str_common(false, false, true) 
	       << endl;
	}

	if (verbose==2) {
	  list<pair<string,string>> doc = db->TextIndexRetrieve(i, ti);
	  for (auto& j : doc)
	    *out << "#" << i << " " << j.first << " = " << j.second << endl;
	}

	if (verbose==3 && ssgt[i]==1) {
	  size_t pi = i;
	  if (segmentspec[0]=='*')
	    pi = db->VideoOrSegmentMiddleFrame(i).first;
	  
	  auto psd = db->ParentStartDuration(i, target_videofile);
	  //  obs! this should use db->TextIndexLine(ti, "text", pi)
	  list<pair<string,string>> doc = db->TextIndexRetrieve(pi, ti);
	  for (auto j=doc.begin(); j!=doc.end(); j++)
	    if (j->first=="text") {
	      string txt = j->second;
	      if (!show_logprob) {
		size_t p = txt.find("(");
		if (p!=string::npos) {
		  txt.erase(p);
		  if (p>0 && txt[p-1]==' ')
		    txt.erase(p-1);
		}
	      }
	      string t0 = SecToString(psd.second.first, true);
	      string t1 = SecToString(psd.second.first+psd.second.second, true);
	      string sl = db->Label(i);
	      string fl = db->Label(pi);
	      while (sl.length()<sl_len)
		sl += " ";
	      while (fl.length()<fl_len)
		fl += " ";
	      *out << t0 << " " << t1 << " " << sl << " " << fl
		   << " " << txt << endl;
	      nlines++;
	    }
	}
	
	if (verbose==4 && ssgt[i]==1) {
	  textline_t tl = db->TextIndexLine(ti, "text", i);
	  object_info *oi = db->FindObject(i);
	  int pi = oi->default_parent();
	  float t = 0;
	  if (pi>=0 && db->ObjectsTargetTypeContains(pi, target_video)) {
	    float fps = db->VideoFrameRate(pi);
	    if (fps)
	      t = oi->frame/fps;
	  }
	  string ts = SecToString(t, true);
	  string fl = db->Label(i);
	  while (fl.length()<fl_len)
	    fl += " ";
	  *out << ts << " " << fl << " " << tl.str_common(false, false, true) 
	       << endl;
	}
      }
      
    if (filename!="")
      WriteLog("Dumped to <"+filename+"> "+ToStr(nlines)+" lines");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::RunAnalyseBestAndCombine(int idx,
					  vector<textsearchresult_t>& txtres) {
    bool debug = false, have_gt = false;

    DataBase *db = CheckDB();

    string label = db->Label(idx);

    // obs! setting dbrestriction here (or anywhere) is not safe
    // but let's hope...
    // obs! "gis" is hardcoded here...
    list<string> script {
      "analyse=best",
	"database="+db->Name(),
	"target=image",
	"permapobjects="+ToStr(query->PerMapObjects()),
	"maxquestions="+ToStr(query->MaxQuestions()),
	"features="+query->BriefIndexList(),
	"convtype="+query->ConvType(-1),
	"dbrestriction="+query->TemporalRestrictionName()
    };

    if (beta)
      script.push_back("positive=$head(gis"+label+","+ToStr((int)beta)+")");
    else
      script.push_back("positive=$eye(gis"+label+")");

    if (have_gt)
      script.push_back("viewclass=$exp(kis-"+label+",2)");

    vector<string> args;
    Analysis abest(Picsom(), this, NULL, args);
    abest.Script(script);
    // abest.ScriptExecute();
    abest.ScriptExecuteAndShow();
    analyse_result bestres = abest.Analyse();

    Query *q = abest.CheckQuery();

    map<size_t,float> vidres;
    for (size_t i=0; i<q->NnewObjects(); i++) {
      const Object& o = q->NewObject(i);
      if (!o.Retained())
	continue;
      if (debug) cout << o.Label() << " = " << o.Value();
      int oidx = o.Index(), pidx = oidx;
      for (;;) {
	const object_info *oi = db->FindObject(pidx);
	if (oi->parents.empty())
	  break;
	pidx = oi->default_parent();
      }
      if (debug)
	cout << " " << oidx << " -> " << pidx << " " << db->Label(pidx);
      if (vidres.find(pidx)==vidres.end()) {
	if (debug) cout << " NEW " << o.Value();
	vidres[pidx] = o.Value();
      } else {
	if (vidres[pidx]>=o.Value()) {
	  if (debug) cout << " max " << vidres[pidx];
	} else {
	  if (debug) cout << " NEW MAX " << o.Value();
	  vidres[pidx] = o.Value();
	}
      }
      if (debug) cout << endl;
    }

    for (auto i=txtres.begin(); i!=txtres.end(); i++) {
      for (auto j=vidres.begin(); j!=vidres.end(); j++)
	if (j->first==i->idx) {
	  float newval = i->val+alpha*j->second;
	  if (debug)
	    cout << db->Label(j->first) << " : "
		 << i->val << " + " << alpha << "*" << j->second
		 << " = " << newval << endl;
	  i->val = newval;
	  vidres.erase(j);
	  break;
	}
    }

    for (auto j=vidres.begin(); j!=vidres.end(); j++) {
      float newval = alpha*j->second;
      if (debug)
	cout << db->Label(j->first) << " : "
	     << alpha << "*" << j->second
	     << " = " << newval << endl;
      txtres.push_back(textsearchresult_t(j->first, newval, ""));
    }

    multimap<float,textsearchresult_t> sort;
    for (auto i=txtres.begin(); i!=txtres.end(); i++)
      sort.insert(make_pair(i->val, *i));

    txtres.clear();
    for (auto i=sort.rbegin(); i!=sort.rend(); i++)
      txtres.push_back(i->second);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTextRetrieve(const vector<string>& args) {
    string msg = "Analysis::AnalyseTextRetrieve() : ";

    WriteLog(msg+"starting");

    DataBase *db  = CheckDB();
    string ti = query->TextIndex();

    if (ti=="")
      ti = db->DefaultTextIndex();

    string v = db->LuceneVersion(ti);
    WriteLog("version="+v);

    for (size_t j=0; j<args.size(); j++) {
      ground_truth gt = db->GroundTruthExpression(args[j]);
      for (size_t i=0; i<gt.size(); i++)
	if (gt[i]==1) {
	  //  obs! should this use DataBase::TextIndexLine()?
	  auto r = db->TextIndexRetrieve(i, ti);
	  if (verbose==2) // this is the original style...
	    for (auto k=r.begin(); k!=r.end(); k++)
	      cout << k->first << " = " << k->second << endl;
	  if (verbose==1) {
	    map<string,string> rr(r.begin(), r.end());
	    cout << rr["label"] << " " << rr["text"] << endl;
	  }
	}
    }

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTextAddField(const vector<string>& args) {
    string msg = "Analysis::AnalyseTextAddField() : ";

    /// obs! This should be made more generic...

    if (args.size()!=1 || args[0]!="osrs")
      return ShowError(msg+"osrs is only implemented method");

    WriteLog(msg+"starting");

    DataBase *db  = CheckDB();
    string ti = query->TextIndex();

    if (ti=="")
      ti = db->DefaultTextIndex(); // obs! this is not really used...

    ground_truth gt = QueryRestrictionGT();
    for (size_t j=0; j<gt.size(); j++)
      if (gt[j]==1 && db->ObjectsTargetTypeContains(j, target_video)) {
	string f = db->SolveObjectPath(db->Label(j)), osrsf;
	list<textline_t> l = db->OSRScooked(f, osrsf);
	string str;
	cout << db->Label(j) << " :";
	for (auto i=l.begin(); i!=l.end(); i++) {
	  cout << " [" << i->get_text() << "]";
	  str += (str==""?"":" ")+i->get_text();
	}
	cout << endl;

	for (;;) {
	  size_t p = str.find("\\n");
	  if (p==string::npos)
	    break;
	  str.replace(p, 2, " ");
	}

	cout << "<" << str << ">" << endl;
	list<pair<string,string> > lkv;
	lkv.push_back(make_pair("asr", str));
	db->TextIndexUpdate(j, "", lkv);
      }

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTextIndexUpdateLabels(const vector<string>& /*args*/) {
    string msg = "Analysis::AnalyseTextIndexUpdateLabels() : ";

    // obs! This should be made more generic...

    WriteLog(msg+"starting");

    DataBase *db  = CheckDB();
    string ti = query->TextIndex();

    if (ti=="") 
      return ShowError(msg+"textindex should be given explicitly");

    ground_truth gt = QueryRestrictionGT();
    size_t n = 0, m = 0;
    for (size_t j=0; j<gt.size(); j++)
      if (gt[j]==1) {
	string newlabel = db->Label(j);
	string oldlabel = newlabel.substr(1);
	stringstream ss;
	ss << "#" << j << " [" << oldlabel << "] => [" << newlabel << "]";
	
	auto doc = db->TextIndexRetrieve(oldlabel, ti);
	if (doc.size()) {
	  cout << ss.str() << " updating..." << endl;
	  list<pair<string,string> > lkv { { "label", newlabel } };
	  db->TextIndexUpdate(oldlabel, ti, lkv);
	  n++;
	} else {
	  cout << ss.str() << " DOES NOT EXIST" << endl;
	  m++;
	}
      }
    
    WriteLog(msg+"updated "+ToStr(n)+" object labels, "+ToStr(m)+
	     " did not exist");
    
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseGoogleCustomSearch(const vector<string>& args) {
    string msg = "Analysis::AnalyseGoogleCustomSearch() : ";

    if (args.empty())
      return ShowError(msg+"search string argument missing");

    string line = JoinWithString(args, " ");
    WriteLog(msg+"starting search with\""+line+"\"");
    list<string> res = query->GoogleCustomSearch(line, "image", 100);
    size_t j = 0;
    for (auto i=res.begin(); i!=res.end(); i++) {
      cout << j << " " << *i << endl;
      j++;
    }
    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseTrangeOverlaps(const vector<string>& args) {
    string msg = "Analysis::AnalyseTrangeOverlaps() : ";

    if (args.size()<3)
      return ShowError(msg+"argument missing, expected "
		       "<gt-segspec> <segspec> <object> ...");

    WriteLog(msg+"starting");

    float total_tot = 0;
    float true_pos_tot = 0, true_neg_tot = 0,
      false_pos_tot = 0, false_neg_tot = 0;
    map<string,vector<float> > pername;

    for (size_t i=2; i<args.size(); i++) {
      ground_truth gt = GetDataBase()->GroundTruthExpression(args[i]);
      vector<size_t> idxs = gt.indices(1);
      for (size_t j=0; j<idxs.size(); j++) {
	size_t idx = idxs[j];
	target_type tt = target_video;
	string vlab  = GetDataBase()->Label(idx);
	string vfile = GetDataBase()->ObjectTypeAndPath(vlab, tt);
	float  total = GetDataBase()->SolveVideoLength(idx);

	string gt_sfile =
	  GetDataBase()->SolveSegmentFilePath(idx, args[0], true);
	if (gt_sfile=="")
	  return ShowError(msg+"segmentfile ["+args[0]+"] for <"+
			   vlab+"> not found");
	
	WriteLog("Opening ground truth segmentfile <"+
		 ShortFileName(gt_sfile)+">");

	segmentfile gt_segm(vfile, gt_sfile, NULL, NULL, NULL,
			    true, true, false);

	video_frange_list_t gt_tranges =
	  ReadRangeSegments(gt_segm, "trangetext");
	WriteLog("  "+ToStr(gt_tranges.size())+" "+args[0]+
		 " trangetext results found");

	string ds_sfile =
	  GetDataBase()->SolveSegmentFilePath(idx, args[1], true);
	if (ds_sfile=="")
	  return ShowError(msg+"segmentfile ["+args[1]+"] for <"+
			   vlab+"> not found");
	
	WriteLog("Opening evaluated segmentfile <"+ShortFileName(ds_sfile)+">");

	segmentfile ds_segm(vfile, ds_sfile, NULL, NULL, NULL,
			    true, true, false);

	video_frange_list_t ds_tranges =
	  ReadRangeSegments(ds_segm, "trangetext");
	WriteLog("  "+ToStr(ds_tranges.size())+" "+args[1]+
		 " trangetext results found");

	set<string> names;
	for (auto n=gt_tranges.begin(); n!=gt_tranges.end(); n++) {
	  string nn = n->name;
	  if (nn.find(args[0]+":")==0) {
	    nn.erase(0, args[0].size()+1);
	    names.insert(nn);
	    if (pername.find(nn)==pername.end())
	      pername[nn] = vector<float>(5);
	  }
	}
	for (auto n=ds_tranges.begin(); n!=ds_tranges.end(); n++) {
	  string nn = n->name;
	  if (nn.find(args[1]+":")==0) {
	    nn.erase(0, args[1].size()+1);

	    if (nn.find("gaze")!=string::npos)  // obs!
	      continue;

	    names.insert(nn);
	    if (pername.find(nn)==pername.end())
	      pername[nn] = vector<float>(5);
	  }
	}
	
	float total_sum = 0;
	float true_pos_sum = 0, true_neg_sum = 0,
	  false_pos_sum = 0, false_neg_sum = 0;

	for (auto nn=names.begin(); nn!=names.end(); nn++) {
	  float gt_total = 0, ds_total = 0, true_pos = 0;
	  cout << *nn << endl;	
	  video_frange_list_t gt, ds;
	  for (auto n=gt_tranges.begin(); n!=gt_tranges.end(); n++)
	    if (n->name==args[0]+":"+*nn) {
	      gt.push_back(*n);
	      cout << "  gt " << n->str() << endl;
	      gt_total += n->end_t-n->begin_t;
	    }

	  for (auto n=ds_tranges.begin(); n!=ds_tranges.end(); n++)
	    if (n->name==args[1]+":"+*nn) {
	      ds.push_back(*n);
	      cout << "  ds " << n->str() << endl;
	      ds_total += n->end_t-n->begin_t;
	    }
	  cout << "  totals: " << total << " " << gt_total << " "
	       << ds_total << endl;

	  for (auto gi=gt.begin(); gi!=gt.end(); gi++)
	    for (auto di=ds.begin(); di!=ds.end(); di++) {
	      if (gi->begin_t==-1 || di->begin_t==-1)
		continue;

	      cout << "     " << gi->str() << " "
		   << di->str() << " ";

	      if (gi->end_t<di->begin_t || di->end_t<gi->begin_t) {
		cout << "NO" << endl;
		continue;
	      }
	      cout << "yes ";

	      if (gi->begin_t>di->begin_t && gi->end_t<di->end_t) {
		cout << "g inside d";
		true_pos += gi->end_t-gi->begin_t;
		video_frange new_d = *di;
		new_d.begin_t = gi->end_t;
		ds.push_back(new_d);
		di->end_t = gi->begin_t;
		gi->begin_t = gi->end_t = -1;
		cout << endl;
		continue;
	      }

	      if (di->begin_t>gi->begin_t && di->end_t<gi->end_t) {
		cout << "d inside g";
		true_pos += di->end_t-di->begin_t;
		video_frange new_g = *gi;
		new_g.begin_t = di->end_t;
		gt.push_back(new_g);
		gi->end_t = di->begin_t;
		di->begin_t = di->end_t = -1;
		cout << endl;
		continue;
	      }

	      if (gi->begin_t<di->begin_t) {
		cout << "g..d";
		true_pos += gi->end_t-di->begin_t;
		float a = gi->end_t;
		gi->end_t = di->begin_t;
		di->begin_t = a;
		cout << endl;
		continue;
	      }

	      cout << "d..g";
	      true_pos += di->end_t-gi->begin_t;
	      float a = di->end_t;
	      di->end_t = gi->begin_t;
	      gi->begin_t = a;
	      cout << endl;
	    }
	  
	  float false_neg = 0, false_pos = 0;
	  for (auto gi=gt.begin(); gi!=gt.end(); gi++)
	    false_neg += gi->end_t-gi->begin_t;
	  for (auto di=ds.begin(); di!=ds.end(); di++)
	    false_pos += di->end_t-di->begin_t;

	  float true_neg = total-true_pos-false_neg-false_pos;
	  cout << vlab << " " << args[0] << " " << args[1]
	       << " " << *nn
	       << " total=" << ThreeDigits(total)
	       << " TP=" << ThreeDigits(true_pos)
	       << " FP=" << ThreeDigits(false_pos)
	       << " FN=" << ThreeDigits(false_neg)
	       << " TN=" << ThreeDigits(true_neg)
	       << endl;

	  total_sum     += total;
	  true_pos_sum  += true_pos;
	  true_neg_sum  += true_neg;
	  false_pos_sum += false_pos;
	  false_neg_sum += false_neg;

	  total_tot     += total;
	  true_pos_tot  += true_pos;
	  true_neg_tot  += true_neg;
	  false_pos_tot += false_pos;
	  false_neg_tot += false_neg;

	  pername[*nn][0] += total;
	  pername[*nn][1] += true_pos; 
	  pername[*nn][2] += false_pos; 
	  pername[*nn][3] += false_neg;
	  pername[*nn][4] += true_neg;

	  cout << endl;
	}

	cout << vlab << " " << args[0] << " " << args[1]
	     << " TOTAL"
	     << " total=" << ThreeDigits(total_sum)
	     << " TP=" << ThreeDigits(true_pos_sum)
	     << " FP=" << ThreeDigits(false_pos_sum)
	     << " FN=" << ThreeDigits(false_neg_sum)
	     << " TN=" << ThreeDigits(true_neg_sum)
	     << endl;
      }
    }

    for (auto nn=pername.begin(); nn!=pername.end(); nn++)
      cout << "ALL " << args[0] << " " << args[1]
	   << " " << nn->first
	   << " total=" << ThreeDigits(nn->second[0])
	   << " TP=" << ThreeDigits(nn->second[1])
	   << " FP=" << ThreeDigits(nn->second[2])
	   << " FN=" << ThreeDigits(nn->second[3])
	   << " TN=" << ThreeDigits(nn->second[4])
	   << endl;

    cout << "ALL " << args[0] << " " << args[1]
	 << " TOTAL"
	 << " total=" << ThreeDigits(total_tot)
	 << " TP=" << ThreeDigits(true_pos_tot)
	 << " FP=" << ThreeDigits(false_pos_tot)
	 << " FN=" << ThreeDigits(false_neg_tot)
	 << " TN=" << ThreeDigits(true_neg_tot)
	 << " SCORE1=" << true_pos_tot-false_pos_tot-false_neg_tot
	 << " SCORE2=" << true_pos_tot-false_pos_tot
	 << endl;

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseKMeans(const vector<string>& argsin) {
    string msg = "Analysis::AnalyseKMeans() : ";

    // size_t splitdim = 256;
    size_t splitdim = 1;
    size_t step = 1000;
    // float minv = 0, maxv = 255;
    // float minv = -255, maxv = 255;
    float maxv = numeric_limits<float>::max(), minv = -maxv;
    size_t comp_f = 0, comp_l = -1;
    size_t samples = 0;

    vector<string> args;
    for (auto i=argsin.begin(); i!=argsin.end(); i++)
      if (i->find("comp=")==0) {
	comp_f = atoi(i->substr(5).c_str());
	size_t p = i->find('-');
	if (p==string::npos)
	  return ShowError(msg+"comp=12-34 : - not found");
	comp_l = atoi(i->substr(p+1).c_str());

      } else if (i->find("samples=")==0) 
	samples = atoi(i->substr(8).c_str());
      else
	args.push_back(*i);

    if (args.size()!=3 ||
	(args[0].find("file=")!=0 && args[0].find("feature=")!=0))
      return ShowError(msg+"3 arguments expected: "
		       "file=file.dat|feature=name k maxloops");

    size_t k = atoi(args[1].c_str()), maxloops = atoi(args[2].c_str());

    WriteLog(msg+"starting with "+args[0]+" k="+ToStr(k)+
	     " maxloops="+ToStr(maxloops)+
	     " minv="+ToStr(minv)+" maxv="+ToStr(maxv)+
	     " samples="+ToStr(samples)+" comp="+ToStr(comp_f)+
	     "-"+ToStr(comp_l));

    string fname;

    // ReadFiles(false);
    FloatVectorSet orig;
    if (args[0].find("file=")==0) {
      fname = args[0].substr(5);
      if (fname.find(".bin")==fname.size()-4) {
	try {
	  bin_data bin(fname);
	  for (size_t i=0, n=bin.nobjects(); i<n; i++) {
	    if (i%step==0)
	      cout << "... reading " << i << "/" << n << "\r" << flush;
	    vector<float> dv = bin.get_float(i);
	    FloatVector sv(dv.size(), &dv[0]);
	    orig.AppendCopy(sv);
	  }
	  cout << "Read " << orig.Nitems() << " vectors form <"
	       << fname << "> with dimensionality "
	       << orig.VectorLength() << endl;
	} catch (const string& emsg) {
	  return ShowError(msg+"failed to read <"+fname
			   +"> as a bin file: "+emsg);
	}

      } else
	orig = FloatVectorSet(fname.c_str());
    }

    if (args[0].find("feature=")==0) {
      fname = args[0].substr(8);
      if (!CheckDB())
	return ShowError(msg+"database should be specified");
      VectorIndex *vecidx =
	dynamic_cast<VectorIndex*>(CheckDB()->FindIndex(fname, "", true,
							false));
      if (!vecidx)
	return ShowError(msg+"vectorindex <"+fname+"> not found");

      vecidx->ReadDataFile(false, false);
      vecidx->SetDataSetNumbers(false, true);
      orig = vecidx->Data();
    }

    set<size_t> sel;
    RandVar r;
    if (samples>=(size_t)orig.Nitems())
      samples = 0;
    // while (samples && sel.size()<samples)
    //   sel.insert(r.RandomInt(orig.Nitems()));
    vector<size_t> isel(orig.Nitems());
    for (size_t i=0; i<isel.size(); i++)
      isel[i] = i;
    while (samples && sel.size()<samples) {
      size_t i = r.RandomInt(isel.size());
      sel.insert(isel[i]);
      isel[i] = isel[isel.size()-1];
      isel.erase(isel.begin()+isel.size()-1);
    }

    FloatVectorSet draw;
    for (auto i=sel.begin(); i!=sel.end(); i++) {
      FloatVector v = orig[*i];
      if (comp_l!=(size_t)-1) {
	FloatVector t = v;
	t.Lengthen(comp_l-comp_f+1);
	for (size_t j=0; j<(size_t)t.Length(); j++)
	  t[j] = v[comp_f+j];
	v = t;
      }
      draw.AppendCopy(v);
    }

    FloatVectorSet d;
    size_t rej = 0, vl = draw.VectorLength();
    for (int i=0; i<draw.Nitems(); i++) {
      const FloatVector& vv = *draw.Get(i);
      bool drop = false;
      for (size_t j=0; j<vl && !drop; j++)
	if (vv[j]<minv || vv[j]>maxv)
	  drop = true;
      if (drop) {
	rej++;
	continue;
      }
      d.AppendCopy(*draw.Get(i));
    }
    d.SetNumbers();

    size_t dl = d.VectorLength(), dn = d.Nitems();

    if (splitdim>1) {
      if (d.VectorLength()%splitdim)
	return ShowError(msg+"vectorlength not divisible by splitdim");

      FloatVectorSet tmp;

      size_t n = d.VectorLength()/splitdim;
      for (size_t i=0; i<(size_t)d.Nitems(); i++) {
	const FloatVector& vv = *d.Get(i);
	const float *vp = vv;
	for (size_t j=0; j<n; j++) {
	  FloatVector a(splitdim, vp+j*splitdim);
	  tmp.AppendCopy(a);
	}
      }
      
      d = tmp;
    }

    WriteLog("Original vectors "+ToStr(orig.Nitems())+" of which "
	     +ToStr(dn)+" chosen, dimensionality "+ToStr(dl)
	     +" leads to "+ToStr(d.Nitems())+" x "+ToStr(d.VectorLength())
	     +"-dimensional vectors");

    IntVector iv;
    FloatVectorSet km = d.KMeans(k, maxloops, &iv);

    map<size_t,size_t> c;
    for (size_t i=0; i<(size_t)iv.Length(); i++)
      c[iv[i]]++;

    WriteLog("  "+ToStr(c.size())+" units used");
    multimap<size_t,size_t> h;
    for (auto i=c.begin(); i!=c.end(); i++)
      h.insert(make_pair(i->second, i->first));
    for (auto i=h.rbegin(); i!=h.rend(); i++)
      cout << " " << i->first;
    cout << endl;      

    string outf = fname;
    size_t p = outf.rfind('/');
    if (p!=string::npos)
      outf.erase(0, p+1);
    p = outf.rfind('.');
    if (p!=string::npos) {
      string ss;
      if (comp_l!=(size_t)-1)
	ss = "-"+ToStr(comp_f)+"-"+ToStr(comp_l);
      ss += "-kmeans"+ToStr(k);
      outf.insert(p, ss);
    } else
      outf = "dummy-out-file.dat";

    bool write_ok = false;
    if (outf.find(".bin")==outf.size()-4) {
      try {
	bin_data bin(outf, true, bin_data::header::format_float, 32*dl, dl);
	for (size_t i=0; i<(size_t)km.Nitems(); i++) {
	  const FloatVector& sv = *km.Get(i);
	  vector<float> dv((float*)sv, (float*)sv+sv.Length());
	  bin.resize(i+1);
	  bin.set_float(i, dv);
	}
	write_ok = true;
	WriteLog("Stored "+ToStr(bin.nobjects())+" "+ToStr(bin.vdim())
		 +"-dimensional vectors in <"+outf+"> in PSBD format");

      } catch (const string& emsg) {
	  return ShowError(msg+"failed to write <"+outf
			   +"> as a bin file: "+emsg);
      }

    } else {
      write_ok = km.Write(outf);
      if (write_ok)
	WriteLog("Stored "+ToStr(k)+" vectors in <"+outf+"> as .dat");
    }

    if (!write_ok)
      return ShowError(msg+"Failed to store vectors in <"+outf+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseVectorQuantize(const vector<string>& args) {
    string msg = "Analysis::AnalyseVectorQuantize() : ";

    if (args.size()!=2)
      return ShowError(msg+"2 arguments expected: codebook.dat file.dat");

    string cbf = args[0], datf = args[1];

    FloatVectorSet cb(cbf.c_str());

    WriteLog(msg+"starting with codebook <"+cbf+"> of "+ToStr(cb.Nitems())
	     +"x"+ToStr(cb.VectorLength())+"-dim vectors");

    string outf = datf;
    size_t p = outf.rfind('/');
    if (p!=string::npos)
      outf.erase(0, p+1);
    p = outf.rfind('.');
    if (p!=string::npos)
      outf.insert(p, "-vq"+ToStr(cb.Nitems()));
    else
      outf = "dummy-out-file.dat";
    
    DataSet dat(datf.c_str());
    ofstream out(outf);
    out << "1" << endl;

    size_t n = 0;
    for (;; n++) {
      const FloatVector *v = dat.Next();
      if (!v)
	break;
      const FloatVector& nn = cb.NearestTo(*v);
      out << nn.Number() << " " << v->Label() << endl;
    }

    if (out)
      WriteLog("Stored "+ToStr(n)+" vectors in <"+outf+">");
    else
      return ShowError(msg+"Failed to store vectors in <"+outf+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCreateHistograms(const vector<string>& args) {
    string msg = "Analysis::AnalyseCreateHistograms() : ";

    if (args.size()!=2)
      return ShowError(msg+"2 arguments expected: dim vqfile.dat");

    size_t dim = atoi(args[0].c_str());
    if (!dim)
      return ShowError(msg+"dim==0");

    string datf = args[1];

    string outf = datf;
    size_t p = outf.rfind('/');
    if (p!=string::npos)
      outf.erase(0, p+1);
    p = outf.rfind('.');
    if (p!=string::npos)
      outf.insert(p, "-hist");
    else
      outf = "dummy-out-file.dat";

    WriteLog(msg+"starting to create "+ToStr(dim)+" dimensional "
	     "histogram vectors from <"+datf+"> to <"+outf+">");

    ofstream out(outf);
    out << dim << endl;

    DataSet dat(datf.c_str());
    string plab;

    size_t nv = 0, nh = 0;

    vector<size_t> empty(dim), hit(empty);
    
    for (;; nv++) {
      const FloatVector *v = dat.Next();

      string lab = v ? v->Label() : "";
      size_t p = lab.find('(');
      if (p!=string::npos)
	lab.erase(p);

      if ((plab!="" && lab!=plab) || !v) {
	if (plab!="") {
	  for (size_t i=0; i<hit.size(); i++)
	    out << hit[i] << " ";
	  out << plab << endl;
	  nh++;
	}

	if (!v)
	  break;

	hit = empty;
      }

      size_t b = (size_t)(*v)[0];
      if (b>=hit.size())
	return ShowError(msg+"index "+ToStr(b)+" out of range");

      hit[b]++;

      plab = lab;
    }

    if (out)
      WriteLog("Processed "+ToStr(nv)+" samples and stored "+
	       ToStr(nh)+" histograms in <"+outf+">");
    else
      return ShowError(msg+"Failed to store vectors in <"+outf+">");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseFindHistogramMatches(const vector<string>& args) {
    string msg = "Analysis::AnalyseFindHistogramMatches() : ";

    if (args.size()!=3)
      return ShowError(msg+"3 arguments expected: feat-hist.dat frame thr");

    float  thr  = atof(args[2].c_str());
    size_t fr   = atoi(args[1].c_str());  // e.g. 34125
    string datf = args[0];

    FloatVectorSet dat(datf.c_str());

    WriteLog(msg+"starting to match "+ToStr(dat.VectorLength())+
	     " dimensional histogram vectors from <"+datf+"> against frame "+
	     ToStr(fr)+" with threshold "+ToStr(thr));

    const FloatVector& fv = *dat.Get(fr);
    float r = 0;
    for (int j=0; j<fv.Length(); j++)
      r += fv[j];

    for (int i=0; i<dat.Nitems(); i++) {
      const FloatVector& vv = *dat.Get(i);
      float s = 0, t = 0;
      for (int j=0; j<fv.Length(); j++)
	t += vv[j];

      for (int j=0; j<fv.Length(); j++)
	s += vv[j]/t<fv[j]/r ? vv[j]/t : fv[j]/r;

      // float a = s/r, b = s/t;

      if (s>=thr) {
	string ts = ToStr(i/25.0);
	int hours = i/(3600*25), res = i-3600*25*hours;
	int mins = res/(60*25);
	res -= mins*60*25;
	int secs = res/25;
	res -= secs*25;
	int mils = res*40;
	char tmp[100];
	sprintf(tmp, "%02d:%02d:%02d.%03d", hours, mins, secs, mils);
	string tt(tmp);
	cout << i << " " << ts << " " << tt << " : "
	     << s /*<< " / " << r << " = " << a << " "
		    << s << " / " << t << " = " << b*/
	     << endl;
      }
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseKMeansHistograms(const vector<string>& args) {
    string msg = "Analysis::AnalyseKMeansHistograms() : ";

    float minv = -1, maxv = 1;  // affective
    // float minv = 0, maxv = 9800; // accede

    if (args.size()!=2)
      return ShowError(msg+"2 arguments expected: k maxn");

    int k = atoi(args[0].c_str()), maxn = atoi(args[1].c_str());

    WriteLog(msg+"starting with k="+ToStr(k)+" maxn="+ToStr(maxn)+
	     " minv="+ToStr(minv)+" maxv="+ToStr(maxv));

    ReadFiles(false);
    const FloatVectorSet& draw = CheckQuery()->vectorIndex(0).Data();
    FloatVectorSet d;
    size_t rej = 0;
    for (int i=0; i<draw.Nitems(); i++) {
      bool drop = false;
      for (int j=0; j<draw.VectorLength() && !drop; j++)
	if ((*draw.Get(i))[j]<minv || (*draw.Get(i))[j]>maxv)
	  drop = true;
      if (drop) {
	rej++;
	continue;
      }
      d.AppendCopy(*draw.Get(i));
    }
    d.SetNumbers();

    IntVector iv;
    FloatVectorSet km = d.KMeans(k, maxn, &iv);

    map<string,map<int,size_t> > h;
    for (int i=0; i<iv.Length(); i++) {
      string l = d[i].Label();
      size_t p = l.find_first_not_of("0123456789");
      if (p!=string::npos)
	l.erase(p);
      if (verbose>1)
	cout << i << " " << d[i].Label() << " " << l << " " << iv[i] << endl;
      h[l][iv[i]]++;
    }

    ostream *osp = &cout;
    ofstream os;
    if (filename!="") {
      os.open(filename);
      osp = &os;
      *osp << "# " << k << " bin histogram of "
	   << CheckQuery()->vectorIndex(0).FeatureFileName() << endl;
      *osp << k << endl;
    }

    for (auto i=h.begin(); i!=h.end(); i++) {
      vector<float> v(k);
      float d = 0;
      for (auto j=i->second.begin(); j!=i->second.end(); j++) {
	v[j->first] = j->second;
	d += j->second;
      }
      for (int ii=0; ii<k; ii++) {
	if (d)
	  v[ii] /= d;
	*osp << v[ii] << " ";
      }
      *osp << i->first << endl;
    }
    
    if (filename!="")
      WriteLog("Stored "+ToStr(h.size())+" histograms vectors of "+
	       ToStr(k)+" bins extracted from "+ToStr(d.Nitems())+" \""+
	       CheckQuery()->vectorIndex(0).FeatureFileName()+
	       "\" vectors in <"+
	       filename+">, "+ToStr(rej)+" vectors were rejected");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalysePairDistances(const vector<string>& args) {
    string msg = "Analysis::AnalysePairDistances() : ";

    bool de_order = false, dx2_order = false;
    if (args.size()>0) {
      de_order  = args[0]=="de";
      dx2_order = args[0]=="dx2";
    }

    ReadFiles(false);
    const FloatVectorSet& dat = CheckQuery()->vectorIndex(0).Data();

    multimap<double,string> de_map, dx2_map;
    for (int i=0; i<dat.Nitems(); i++)
      for (int j=0; j<i; j++) {
	double de  = sqrt(dat.Get(i)->DistanceSquaredEuclidean(*dat.Get(j)));
	double dx2 = dat.Get(i)->DistanceChiSquare(*dat.Get(j));
	stringstream ss;
	ss << dat.Get(i)->Label() << " " << dat.Get(j)->Label()
	   << " " << de << " " << dx2;
	if (!de_order && !dx2_order)
	  cout << ss.str() << endl;
	
	de_map.insert( make_pair(de,  ss.str()));
	dx2_map.insert(make_pair(dx2, ss.str()));
      }

    if (de_order)
      for (auto i=de_map.begin(); i!=de_map.end(); i++)
	cout << i->second << endl;

    if (dx2_order)
      for (auto i=dx2_map.begin(); i!=dx2_map.end(); i++)
	cout << i->second << endl;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseCluster(const vector<string>& /*args*/) {
    string msg = "Analysis::AnalyseCluster() : ";

    WriteLog(msg+"starting");

    ReadFiles(false);
    const FloatVectorSet& d = CheckQuery()->vectorIndex(0).Data();
    cout << d.Nitems() << "x " << d.VectorLength() << "-dim" << endl;

    // size_t lmin = 10, lmax = 40;
    // size_t lmin = 15, lmax = 15;
    size_t min_n = 10, min_s = 10;

    size_t n = d.Nitems();
    simple::FloatMatrix m(n, n);

    for (size_t i=0; i<n; i++) {
      cout << i << "\r" << flush;
      for (size_t j=i+1; j<n; j++) {
	float dd = d[i].DistanceSquaredXX(d[j]);
	m.Set(i, j, dd);
	m.Set(j, i, dd);
      }
    }

    float  maxfloat = numeric_limits<float>::max();
    size_t maxsizet = numeric_limits<size_t>::max();

    list<set<size_t>> clu;
    for (size_t i=0; i<n; i++) {
      set<size_t> s { i };
      clu.push_back(s);
    }

    for (size_t r=0; r<n-1; r++) {
      if (clu.size()!=n-r)
	return ShowError(msg+ToStr(__LINE__));

      float min = maxfloat;
      size_t xi = maxsizet, xj = maxsizet;
      for (size_t i=0; i<n; i++)
	for (size_t j=i+1; j<n; j++)
	  if (m(i, j)<min) {
	    auto si = clu.begin(), sj = si;
	    while (si!=clu.end())
	      if (si->find(i)!=si->end())
		break;
	      else
		si++;

	    while (sj!=clu.end())
	      if (sj->find(j)!=sj->end())
		break;
	      else
		sj++;

	    if (si==clu.end() || sj==clu.end())
	      return ShowError(msg+ToStr(__LINE__));

	    if (si!=sj) {
	      min = m(i, j);
	      xi = i;
	      xj = j;
	    }
	  }
    
      // cout << r << " xi=" << xi << " xj=" << xj << " min=" << min << endl;
      auto si = clu.begin(), sj = si;
      while (si!=clu.end())
	if (si->find(xi)!=si->end())
	  break;
	else
	  si++;
      while (sj!=clu.end())
	if (sj->find(xj)!=sj->end())
	  break;
	else
	  sj++;
      if (si==clu.end() || sj==clu.end())
	return ShowError(msg+ToStr(__LINE__));

      si->insert(sj->begin(), sj->end());
      clu.erase(sj);

      size_t l = 0, ll = 0;
      map<size_t,size_t> hist;
      for (auto i=clu.begin(); i!=clu.end(); i++) {
	hist[i->size()]++;
	if (i->size()>1)
	  l++;
	if (i->size()>=min_s)
	  ll++;
      }

      //bool hit = l>=lmin && l<=lmax;
      bool hit = ll>=min_n;

      cout << r << " " << clu.size() << " " << l << " " << ll;
      for (auto i=hist.begin(); i!=hist.end(); i++)
	cout << "   " << i->second << "x" << i->first;
      cout << (hit?"   HIT":"") << endl;      

      if (hit) {
	size_t a = 0;
	for (auto i=clu.begin(); i!=clu.end(); i++) {
	  if (i->size()==1)
	    continue;

	  string cname = string(filename=="" ? "clu" : filename)
	    +"-"+ToStr(clu.size())+"-"+ToStr(a);
	  ofstream of(cname);
	  of << "# cluster # " << a << " / " << clu.size() << endl;
	  for (auto j=i->begin(); j!=i->end(); j++)
	    of << d[*j].Label() << endl;

	  a++;
	}
      }
    }

    WriteLog(msg+"ending");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::InsertOneFileSynchronize(vector<size_t> *idxs) {
  #ifdef ANALYSIS_USE_PTHREADS
   string msg = "Analysis::InsertOneFileSynchronize() : ";

    if (Picsom()->DebugThreads())
      cout << msg+"starting with thread_data.size()=" << thread_data.size()
	   << endl;

    list<analyse_result> result;
    bool ret = AnalysePthreadJoin(result, true);
    if (idxs)
      for (list<analyse_pthread_data_t>::iterator i=thread_data.begin();
	   i!=thread_data.end(); i++)
	idxs->insert(idxs->end(), i->indices.begin(), i->indices.end());

    thread_data.clear();

    if (Picsom()->DebugThreads())
      cout << msg+"ending with thread_data.size()=" << thread_data.size()
	   << endl;

    Picsom()->PossiblyShowDebugInformation("After InsertOneFileSynchronize");

    return ret;
#else
    return false;
#endif // ANALYSIS_USE_PTHREADS
  }

///////////////////////////////////////////////////////////////////////////////

  bool Analysis::Create(const vector<string>& args) {
  string msg = "Analysis::Create() : ";

  if (!query)
    return ShowError(msg+"query==NULL");

  if (libsvmdump)
    return LibsvmDump();

  if (svm!="")
    return CreateSVM(*query);

  if (elm!="")
    return CreateELM(*query);

  if (!query->GetDataBase() && classname=="" && trecvid=="")
    return ShowError(msg+"missing database specification");

  if (classname!="" || trecvid!="")
    return CreateGroundTruth();

  if (fillorigins) {
    ground_truth gt = QueryRestrictionGT();
    return query->GetDataBase()->FillOrigins(&gt);
  }

  if (!query->NindicesNew() && args.size()==0)
    return ShowError(msg+"missing indices specification and no arguments");

  if (extractfeatures || combineorphans) 
    query->GetDataBase()->RemoveBrokenDataFiles(true);

  //if (randproj==0 && segmenthistogram.empty() && !query->ReadFiles())

  // Commented 9.2.2010 by Mats. 
//   if (randproj==0 && !query->ReadFiles(true, true))
//     return ShowError(msg+"file reading failed");

  if (stripvectors)
    return StripVectors(*query);

  if (extractfeatures && !ExtractFeatures(*query, false, args))
    return false;

  if (combineorphans && !CombineOrphans(*query))
    return false;
   
  if (removecreated && !RemoveCreated(*query))
    return false;

  if (updatediv && !UpdateDiv(*query))
    return false;

  if (dodetections && !DoDetections())
    return false;
  
  if (dosegments && !DoSegments())
    return false;
  
  if (extractmedia && ExtractMedia())
    return false;

  if (extractfeatures || combineorphans || updatediv || removecreated ||
      dodetections || extractmedia)
    return true;

  if (randproj!=0) 
    return RandProj(*query);

  if (concatfeat!="")
    return ConcatFeat(*query);

  if (meandist)
    return CreateMeanDist(*query);

  if (ord)
    return CreateOrd(*query);

  if (alien_data!="" || alien_map!="")
    return HandleAlienDataBase(*query);

  if (traincount.Length()<1)
    return ShowError(msg+"missing traincount specification");

  if (lbg)
    return CreateLBG(*query);

  return CreateSOM(*query);
}

  //////////////////////////////////////////////////////////////////////////////

  FloatVector* Analysis::ParseSparse(const string& str, size_t len) {
    const string msg = "ParseSparse("+str+", "+ToStr(len)+"): ";
    const string delims = " \t";

    FloatVector* v = new FloatVector(len);
    size_t pos = 0, next;

    v->Zero();
    
    while (pos != string::npos) {
      next = str.find_first_of(delims, pos);
      string val = str.substr(pos, next==string::npos?string::npos:next-pos);

      size_t cpos = val.find(':');
      if (cpos == string::npos) {
        ShowError(msg, "Invalid sparse format: \"", val, "\"");
        delete v;
        return NULL;
      }

      string idx_str = val.substr(0, cpos);
      string val_str = val.substr(cpos+1);

      float f = atof(val_str.c_str());
      
      size_t dpos = idx_str.find('-');
      if (dpos == string::npos) {
        size_t idx = atoi(idx_str.c_str());
        if (idx >= len) {
          ShowError(msg, "Bad index in \"", val, "\"");
          delete v;
          return NULL;
        }
        
        v->Set(idx, f);
      } else {
        size_t from = atoi(idx_str.substr(0,dpos).c_str());
        size_t to = atoi(idx_str.substr(dpos+1).c_str());
        if (from >= to || to >= len) {
          ShowError(msg, "Bad interval in \"", val, "\"");
          delete v;
          return NULL;
        }
        for (size_t i=from; i<=to; i++)
          v->Set(i, f);
      }
      pos = str.find_first_not_of(delims, next);

    }

    // cout << endl << endl << msg <<  "v =";
    // for (int i=0; i<v->Length(); i++) {
    //   cout << " " << v->Get(i);
    // }
    // cout << endl << endl << endl;

    return v;
  }

  /////////////////////////////////////////////////////////////////////////////

bool Analysis::CreateSOM(Query& /*my_query*/) {
  using simple::Planar;

  string msg = "Analysis::CreateSOM() : ";

  if (treesomstruct=="")
    return ShowError(msg+"missing treesomstruct specification");

  bool ok = true;

  // Tic("CreateSOM()");
  ReadFiles(false);
  Picsom()->PossiblyShowDebugInformation("After ReadFiles() in CreateSOM()");

  vector<string> skiplabelvec;
  if (skiplabels!="") {
    ground_truth g = GroundTruthExpression(skiplabels, Target(), -1, expand);
    //gt IntVector s = g.EqualsXXYY(1).NonZeroIndices();
    vector<size_t> s = g.indices(1);
    if (!s.size())
      ShowError(msg+"skiplabels=[", skiplabels, "] is empty set");
    skiplabelvec = GetDataBase()->Labels(s);

    char tmp[1000];
    sprintf(tmp, " contains %d objects of which %d are skipped",
            (int)DataBaseSize(), (int)skiplabelvec.size());
    WriteLog("Database ", DataBaseName(), tmp);
  }

  string lastmsg;

  for (size_t m = 0; ok && m<Nindices(); m++) {
    TSSOM& tssom = TsSom(m);

    // lots of this should be reimplemented as TSSOM::CreateSOM()    

    const string& fname = tssom.Name();

    target_type tt = Target();
    if (tt==target_no_target)
      tt = tssom.FeatureTarget();

    if (tt==target_no_target) {
      ok = ShowError(msg+"["+fname+"] missing target specification");
      continue;
    }

    tssom.FeatureTarget(tt);
    tssom.ApplyRestriction(GetDataBase()->RestrictionName(), tt);
    if (!tssom.SetDataSetNumbers(false, addlabels)) {
      ok = ShowError(msg+"Setting data set numbers in <",fname,"> failed");
      continue;
    }

    DataSet rawset;
    TSSOM::raw_data_spec_t rd_spec;
    if (rawdata!="") {
      if (labelsonly) {
        ok = ShowError(msg+"Simultaneous rawdata=xxx and labelsonly=true "
                       "is senseless");
        continue;
      }

      if (!PrepareRawData(tssom, rd_spec, rawset))
        continue;
    }

    bool userawset = rawset.VectorLength(), do_div = !userawset;

    FloatVectorSet& dataset = tssom.Data();
    if (!userawset && dataset.Nitems()==0)
      return ShowError(msg+"empty dataset");

    if (!userawset) {
      if (!tssom.CheckDataSetTargetTypes()) {
        ok = ShowError(msg+"Target types in data set <", fname, "> failed");
        continue;
      }

      if (RndSeed()) {
        int rs = RndSeed();
        dataset.RandomlyReorder(rs);
        WriteLog("Randomly reordered data with seed ", ToStr(rs));
      }
    }

    simple::FloatVectorSource *train_set = userawset ? 
      (simple::FloatVectorSource*)&rawset
      : (simple::FloatVectorSource*)&dataset;
    
    string outname = fname;

    xmlDocPtr xml = dataset.XMLDescription();
    if (!userawset && !DataPreProcessing(dataset, outname, xml))
      return ShowError(msg+"DataPreProcessing() failed");

    //if ((tssom.MetaDataFileName()!="" || preprocess!="") && writedata) {}

    if (preprocess!="" && writedata) {
      string dn = OutDirEvenDot()+outname+".dat"+(zipped?".gz":"");
      dataset.Zipped(zipped);
      dataset.FileName(dn);
      if (!dataset.Write(dn))
        return ShowError(msg+"could not write data to <", dn, ">");
      WriteLog("Wrote data in <", dn, ">");
    }

    TreeSOM *ts = NULL;

    for (const char *str = treesomstruct.c_str(); str && *str; str++) {
      Planar::TopologyType topo = Planar::Rectangular;
      if (*str=='T') {
        topo = Planar::Torus;
        str++;
      }

      int w = 0, h = 0, n = 0;
      if (sscanf(str, "%dx%d%n", &w, &h, &n)!=2) {
        ok = ShowError(msg+"failed (1) with treesomstruct <", str, ">");
        break;
      }

      TreeSOM *ns = new TreeSOM(w, h, train_set->VectorLength());
      
      if (!ts) {
        ts = ns;
        ts->TicTacSet(Picsom()->GetTicTac());
        ts->TrainingSet(train_set);
        ts->Silent(Picsom()->Quiet() ? 4 : 1);
        ts->Voting(SOM::NearestVoting);
        ts->Topology(topo);
        ts->NKernel(SOM::NeighbourhoodKernel(neighkernel));
        ts->RadiusBase(radiusbase);

        if (!SetMetric(*ts, outname)) {
          delete ts;
          return ShowError(msg+"failed with metric <", metric, ">");
        }

        ts->DistanceComparisonInterval(distcomp);

        if (preprocess.length())
          ts->Normalization(preprocess.c_str());

        if (!skiplabelvec.empty())
          ts->SkipInTraining(skiplabelvec);

        ts->DivideByNumbers(true);

        if (namesuffix!="")
          outname += string("-")+namesuffix;

        string rawsuffix = "-raw";
        if (userawset && outname.find(rawsuffix)==string::npos)
          outname += rawsuffix;

        if (multirescorrect)
          outname += "-mrc";

        if (filename!="") // if override is forced
          outname = filename;

        ts->FileName(OutDirEvenDot()+outname+".cod");

        ts->UseTimeStamp(Picsom()->UseTimeStamp());

      } else
        ts->AddLevel(ns);

      str += n;
      if (*str==',')
        continue;

      if (*str==0)
        break;

      ok = ShowError(msg+"failed (2) with treesomstruct <", str, ">");
    }
    if (!ok)
      break;

    Picsom()->PossiblyShowDebugInformation("After TSSOM creation in "
					   "CreateSOM()");

    IntVector btperiod;
    btperiod.ValueFromString(batchtrainperiod);
    ts->BatchTrainSettings(batchtrain, 0, picsom->Threads());
    ts->Zipped(zipped);
    ts->WriteLabelsOnly(labelsonly);
    ts->SaveUmatrix(saveumatrix);
    ts->TrainCount(traincount);
    ts->BmuDivDepthVector(bmudivdepth);
    ts->BatchTrainPeriod(btperiod);
    ts->MultiResolutionCorrection(multirescorrect);
    ts->ShowAQE(avgquanterror);
    ts->DoWriteDivXML(divxml);

    // these are inside <treesom> * </treesom>
    const TSSOM *t = dummy_tssom;
    const char *yes[] = { "no", "yes" };
    ts->AddDescriptionString("show_map_values",  yes[t->ShowMapValues()]);
    ts->AddDescriptionString("show_data_values", yes[t->ShowDataValues()]);

    ts->AddDescriptionString("cmdline",  Picsom()->CmdLine());
    ts->AddDescriptionString("commands", commands_str);
    ts->AddDescriptionString("version",
                             "PicSOM.C="+PicSOM::PicSOM_C_Version());

    // this is inside <treesom><feature> * </feature></treesom>
    ts->AddExtraVariable("featuretarget", TargetTypeString(tt));

    string divname = OutDirEvenDot()+outname+".div";
    string somstruct = ts->Structure();
    ostringstream ss;
    ss << "Creating SOM: " << fname
       << " -> " << ts->FileName() << (do_div ? " + "+divname : "")
       << " [" << TargetTypeString(tt) << "] : " << somstruct;
    WriteLog(ss);

    lastmsg += (lastmsg==""?"<":", <")+string(ts->FileName())+">";

    if (!ts->Train(-1, false, do_div))
      ok = ShowError(msg+"Train() failed");

    delete ts->Metric();
    delete ts;

    if (userawset)
      WriteLog("Consumed "+ToStr(rd_spec.number)+" "+fname+
               " raw vectors from "+ToStr(rd_spec.nfiles)+" files");
  }

  if (ok)
    WriteLog("Successfully created "+lastmsg);

  // Tac("CreateSOM()");

  return ok;
}

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ClassMax(ground_truth& gtx, int max, int rand_seed) {
    size_t ss = gtx.positives();

    if (max > 0 && (int)ss > max) {
      WriteLog("ClassMax cutting <"+gtx.label()+"> "+ToStr(ss)+" to "+
	       ToStr(max)+" with rndseed "+ToStr(rand_seed));
      gtx = CheckDB()->GTRandcut(gtx, max, rand_seed);
      return true;
    }

    return false;
  }

  /////////////////////////////////////////////////////////////////////////////

  void Analysis::SVMPosNegMax(ground_truth& pos, ground_truth& neg) {
    int rand_seed    = SVMgetParamInt("classcut_randseed", 42);
    int max_positive = SVMgetParamInt("max_positive",-1);
    int max_negative = SVMgetParamInt("max_negative",-1);
    float pn_ratio   = SVMgetParamFloat("posneg_ratio", -1);

    ClassMax(pos, max_positive, rand_seed);

    if (pn_ratio != -1) {
      size_t pos_n = pos.positives();
      int neg_n = (int)round((float)pos_n*pn_ratio);
      if (max_negative == -1 || max_negative > neg_n)
        max_negative = neg_n;
    }
    ClassMax(neg, max_negative, rand_seed);
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::SVMPredTrain(const string& svmprefix, const string& featname,
			      const string& svmopts,
                              const string& extra, const string& svmname,
			      const string& predict_str) {
    string msg = "SVMPredTrain() : ";
    bool ok = true;
    bool debug = true;
    DataBase* db = CheckDB();

    int fold = atoi(SVMgetParam("fold","6").c_str());

    for (int i=0; i<fold && ok; i++) {
      string ttstr = TargetTypeString(Target());
      string restr = db->RestrictionName()+"&$type("+ttstr+")";
      string gtstr =
        "$split("+restr+","+ttstr+","+ToStr(fold)+","+ToStr(i)+",";

      ground_truth pred_gt = GroundTruthExpression(gtstr+"V)");
      ground_truth train_gt = GroundTruthExpression(gtstr+"Vx)");
      string svmname_fold = svmname+"&"+train_gt.label();
      string inst;
      string params = SVMparams();

      string fn = "";
      if (!resultname.empty())
        fn = resultname+"-fold"+ToStr(i+1)+"of"+ToStr(fold);

      bool skip_train = false;
      if (FileExists(fn+".svm")) {
        WriteLog(msg, "Trained model <", fn, "> found, skipping training.");
        skip_train = true;
        
        if (!params.empty())
          params += ",";
        params += "library="+svmprefix;
	params += ",modelfile="+fn+".svm";
      }

      SVM *svmp = db->GetSVM(svmprefix, featname, svmopts, extra, svmname_fold,
			     inst, params);
      
      ground_truth pos_gt = PositiveGT()&train_gt;
      ground_truth neg_gt = NegativeGT()&train_gt;

      SVMPosNegMax(pos_gt, neg_gt);

      WriteLog(msg, "Training fold "+ToStr(i)+" of "+ToStr(fold));
      if (debug) {
        cout << "Training set:" << endl;
        db->GroundTruthSummary(train_gt);
        cout << endl << "from which positives:" << endl;
        db->GroundTruthSummary(pos_gt);
        cout << endl << "and negatives:" << endl;
        db->GroundTruthSummary(neg_gt);
        cout << endl << "Test/prediction set:" << endl;
        db->GroundTruthSummary(pred_gt);
        cout << endl;
      }

      ground_truth_set train_set;
      train_set.insert(pos_gt);
      train_set.insert(neg_gt);

      string svm_to_read = resultname+".svm";
      if (db->HasExtraFeaturesDir()) 
        svm_to_read = db->ExtraFeaturesDir() + "/" + svm_to_read;
       
      if (!skip_train)
        svmp->Create(svmname_fold, fn, svm, train_set, svm_to_read,
		     featureaugmentation);

      string fnpre_bare = resultname + (predict_str.substr(0,3)=="val" ?
                                        "-"+predict_str : "")+"-train";
      string fnpre = fnpre_bare + ".pre";


      SVM::DisableCache(true);

      bool do_cont = i>0;
      set<string> skip_set;

      if (IsAffirmative(SVMgetParam("predcont", "no")) && FileExists(fnpre)) {
        // Read pred file to skiplist
        string dir = OutDirEvenDot();

        PreCalculatedIndex pind(db, fnpre_bare, fnpre_bare, dir, "", NULL);
        pind.ReadPreCalculatedFile();

        map<string,double>::const_iterator it = pind.precalc.begin();
        for (; it != pind.precalc.end(); it++)
          skip_set.insert(it->first);
        
        do_cont = true;
        WriteLog(msg, "Continuing on <", fnpre, ">. Found "+
                 ToStr(skip_set.size())+" existing values.");
      }

      PredictSVM(svmp, pred_gt, 0, fnpre, predict_str, do_cont, skip_set);

      SVM::DisableCache(false);
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::CreateSVM(const Query&) {
    string msg = "CreateSVM() : ";

    // Tic("CreateSVM()");

    ground_truth_set gt_set_orig;
  
    if (Target()==target_no_target)
      return ShowError(msg+"target not set");

    string predict_str = SVMgetParam("predict", "no");

    if (hard_negative_mining && predict_str!="no")
      return ShowError(msg, "Hard negative mining and predict cannot"
		       " be set together");

    if (hard_negative_mining && SVMgetParamBool("use_cache", false))
      return ShowError(msg, "Dunno yet if hard negative mining and"
		       " use_cache can work together");

    /// obs! why? how about use_cache and hard_negative_mining?
    if (predict_str != "no" && SVMgetParamBool("use_cache", false))
      return ShowError(msg, "Don't use cacheing with predict!");

    if (hard_negative_mining && instance!="")
      return ShowError(msg, "hard_negative_mining and instance cannot"
		       " be set together");

    bool   pred_cont  = IsAffirmative(SVMgetParam("predcont", "no"));
    bool   trainmodel = IsAffirmative(SVMgetParam("trainmodel", "yes"));
    int    rand_seed  = SVMgetParamInt("classcut_randseed", 42);
    string multiclass = SVMgetParam("multiclass", "");
    string svmopts    = SVMgetParam("options", "");

    if (pred_cont)
      ShowError(msg+"predcont is not understood anymore");

    if (!resultname.empty())
      return ShowError(msg, "Using result=" + resultname + " is deprecated "
		       "for this purpose, please use filename=" + resultname +
		       " instead!");
    if (filename=="")
      return ShowError(msg+"filename should be set");

    ground_truth rst = DataBaseRestrictionGT()&TargetTypeGT();
      
    ground_truth_list gtl;
    if (trainmodel) {
      AddGroundTruthInfo(gtl, "positive",           PositiveGT());
      AddGroundTruthInfo(gtl, "negative",           NegativeGT());
    }
    AddGroundTruthInfo(  gtl, "queryrestriction",   QueryRestrictionGT());
    AddGroundTruthInfo(	 gtl, "dbrestriction",      DataBaseRestrictionGT());
    AddGroundTruthInfo(	 gtl, "targettypegt",       TargetTypeGT());
    AddGroundTruthInfo(	 gtl, "dbrestr&targettype", rst);
    if (trainmodel) {
      AddGroundTruthInfo(gtl, "positive&dbr&tt",    PositiveGT()&rst);
      AddGroundTruthInfo(gtl, "negative&dbr&tt",    NegativeGT()&rst);
    }

    list<string> extra;
    AddExtraVariableInfo(extra, "svmopts", svmopts);
    string mstr;
    query->WriteAnalyseVariablesNew("CreateSVM", mstr, gtl, extra);
    
    Query* q = CheckQuery();
    DataBase* db = CheckDB();

    string svmname = multiclass;

    if (SVMgetParam("readproblem").empty() && trainmodel) {
      if (!multiclass.empty()) {
	list<string> ll = db->SplitClassNames(multiclass);

	if (ll.size()>1) {
	  cout << msg << "<" << multiclass << "> was split in " << ll.size()
	       << " subsets: " << endl;

	  size_t max_per_class = SVMgetParamInt("max_per_class",1000);

	  for (list<string>::const_iterator it=ll.begin(); it!=ll.end(); it++) {
	    ground_truth gtx = GroundTruthExpression(*it) & rst;

	    size_t ss = gtx.positives();
            ClassMax(gtx, max_per_class, rand_seed);

	    // if (ss > max_per_class)
	    //   gtx = db->GTRandcut(gtx, max_per_class);

	    cout << msg << *it << ": size " << ss << " => "
		 << gtx.positives() << endl;
	    gt_set_orig.insert(gtx);
	  }
	} else {
	  return ShowError(msg+"svm_multiclass should be set to a class "
			   "containing many classes.");
	}
      } else {
	if (PositiveGT().size()==0)
	  return ShowError(msg+"positive not set");
      
	if (NegativeGT().size()==0)
	  return ShowError(msg+"negative not set");

	ground_truth pos = PositiveGT()&rst;
	ground_truth neg = NegativeGT()&rst;

        SVMPosNegMax(pos, neg);

	gt_set_orig.insert(pos);
	gt_set_orig.insert(neg);

	svmname = CheckQuery()->Positive();
      }
    }

    if (svmname=="")
      svmname = classname;

    string svmprefix = svm;

    bool ok = true;
    for (size_t m = 0; ok && m<Nfeatures(); m++) {
      string f = q->IndexShortName(m);
      string extra = SVMgetParam("extra", "");
      /*
	string hkm = SVMgetParam("homker", "foo");
	if (hkm=="intersection")
          e = "-hkm-int";
      */

      if (IsAffirmative(SVMgetParam("predtrain", "no")))
        return SVMPredTrain(svmprefix, f, svmopts, extra, svmname, predict_str);
        
      string params = SVMparams();

      if (!trainmodel) {
	if (params!="")
	  params += ",";
	params += "library="+svm;
	params += ",modelfile="+filename+".svm";
	bool load_pre = IsAffirmative(SVMgetParam("load_pre", "no"));

	if (load_pre) {
	  params += ",positive="+q->Positive();
	  params += ",negative="+q->Negative();
	  params += ",pdfmodels=100";
	}
      }

      ground_truth_set gt_set = gt_set_orig;

      for (size_t hnm_round=0;; hnm_round++) {
	string filename_w_instance = filename;
	
	if (hard_negative_mining) {
	  if (hnm_round) {
	    instance = "n"+ToStr(hnm_round);
	    filename_w_instance += "§"+instance;
	  }
	  WriteLog(msg+"HARD NEGATIVES starting training round "+
		   ToStr(hnm_round)+"/"+
		   ToStr(hard_negative_mining)+
		   " of hard negative mining, instance=\""+
		   instance+"\" filename=\""+filename_w_instance+"\"");
	}

	SVM *svmp = db->GetSVM(svmprefix, f, svmopts, extra,
			       svmname, instance, params);
	if (!svmp)
	  return ShowError(msg+"failed to construct SVM("+svmprefix+","
			   +svmopts+","+extra+","+svmname+","+instance
			   +params+")");

	SVM& svmx = *svmp;
      
	if (trainmodel)
	  svmx.Create(svmname, filename_w_instance, svm, gt_set, "",
		      featureaugmentation);
	/*
	  else {
	  // svmx.ReadDataFile();
	  // svmx.SetDataSetNumbers(false);
	  bool load_pre = IsAffirmative(SVMgetParam("load_pre", "no"));
	  ok = ok && svmx.LoadModel(fn+".svm", svm,
	  load_pre?q->Positive():"",
	  load_pre?q->Negative():"");
	  svmx.CreatePDFmodels(100, false, false);
	  }
	*/

	// Do SVM prediction with the current model.
	if (ok && (predict_str != "no" || hnm_round<hard_negative_mining)) {
	  list<string> ll;
	  if (!multiclass.empty()) {
	    ll = db->SplitClassNames(multiclass);
	    cout << msg << "<" << multiclass << "> was split in " << ll.size()
		 << " subsets. " << endl;
	  } else {
	    ll.push_back(filename_w_instance);
	  }

	  if (ll.size()!=1)
	    ShowError(msg+"unlikely to work with multiclass after Analyisis.C "
		      "version 2.929...");
	  int n = 0; // shoud be 0,1,2,... with multiclass

	  /// detection to .pre files was removed from here 2014-06-16
	  /// this is now used primarily with hard_negative_mining
	  /// for old behavior, see versions up to 2.929

	  size_t newnegcount = SVMgetParamInt("max_negative", 0);
	  const ground_truth& all_negative = NegativeGT()&rst;
	  vector<size_t> an = all_negative.indices(1);
	  WriteLog(msg+"HARD NEGATIVES "+ToStr(an.size())+
		   " negatives in total (with restriction)");
	  WriteLog(msg+"HARD NEGATIVES "+ToStr(newnegcount)+
		   " negatives will be used, "
		   "starting to predict...");

	  multimap<double,size_t> validx;
	  for (size_t ni=0; ni<an.size(); ni++) {
	    size_t nidx = an[ni];	  
	    FloatVector *v = db->FeatureData(f, nidx, true);
	    if (!v) {
	      WriteLog(msg+"     skipping inexistent negative feature vector #"
		       +ToStr(nidx));
	      continue;
	    }
	      
	    double p = svmx.PredictProb(*v, predict_str, n);
	    p = 2*(p-0.5);
	    delete v;

	    validx.insert(make_pair(-p, nidx));
	  }

	  if (gt_set.size()!=2)
	    return ShowError(msg+"gt_set.size()!=2");

	  ground_truth& neg = gt_set[1];
	  ground_truth newneg(neg.size(), -1);

	  stringstream ssw, ssb;
	  size_t vn = 0, vnmax = 5, npos = 0;
	  for (auto vi=validx.begin(); vi!=validx.end(); vi++, vn++) {
	    if (vn<vnmax)
	      ssw << " " << -vi->first << " (" << vi->second << ")";
	    if (vn>=validx.size()-vnmax)
	      ssb << " " << -vi->first << " (" << vi->second << ")";
	    if (vi->first<0)
	      npos++;

	    if (vn<newnegcount)
	      newneg[vi->second] = 1;
	  }
	  size_t nnewn = newneg.positives();

	  WriteLog(msg+"HARD NEGATIVES "+ToStr(npos)+"/"+ToStr(validx.size())+
		   " negatives have positive predicted value");
	  WriteLog(msg+"HARD NEGATIVES worst ones:"+ssw.str());
	  WriteLog(msg+"HARD NEGATIVES best  ones:"+ssb.str());
	  WriteLog(msg+"HARD NEGATIVES selected "+ToStr(nnewn)+
		   " new negatives");

	  neg = newneg;
	}
	
	if (hnm_round==hard_negative_mining)
	  break;
      } 
    }

    // Tac("CreateSVM()");

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::PredictSVMalt(SVM* svmp, const ground_truth& rst, int n,
			       const string& fnpre, const string& predict_str,
			       bool do_cont, set<string> skip_set) {
    string msg = "PredictSVMalt("+fnpre+") : ";

    Query* q = CheckQuery();
    DataBase* db = CheckDB();

    const string augm;
    if (!svmp->BinDataOpen(false, db->Size(), false, augm))
      return ShowError(msg+"BinDataOpen() failed");

    Picsom()->PossiblyShowDebugInformation("Before PredictSVM");

    ios_base::openmode mode = ios_base::out | ios_base::trunc;
    if (do_cont)
      mode = ios_base::out | ios_base::app;

    size_t npreds = 0;
    ofstream fp(fnpre.c_str(), mode);
    if (!do_cont)
      fp << "# PRECALCULATEDFILE" << endl;

    size_t max = q->DataBaseSize();
    ProgressBar pb(max/100, 60, "Generating pre: ");

    for (size_t i=0; i<max; i++) {
      if (i%100==0)
        if (!trecvid_noprogressbar)
          pb.Inc();

      if (rst[i]==1) {
        const string& lab = db->Label(i);
        if (do_cont && skip_set.find(lab) != skip_set.end())
          continue;
      } else
	continue;

      const string& lab = db->Label(i);
      FloatVector *v = svmp->BinDataFloatVector(i);
      if (v) {
	double p = svmp->PredictProb(*v, predict_str, n);
	fp << p << " " << lab << endl;
	npreds++;

      } else
	WriteLog(msg+" WARNING: idx="+ToStr(i)+" is NULL!");

      if (db->SqlFeatures() || db->UseBinFeaturesRead())
	delete v;

      // struct timespec ts = { 0, 10000000 }; // 10 millisecond
      // nanosleep(&ts, NULL);
    }
    fp.close();
    cout << endl;
    WriteLog(msg, "Wrote "+ToStr(npreds)+" predictions in <"+fnpre+">");

    Picsom()->PossiblyShowDebugInformation("At the end of PredictSVM");

    return npreds ? true : ShowError(msg+"npreds==0");
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::PredictSVM(SVM* svmp, const ground_truth& rst, int n,
			    const string& fnpre, const string& predict_str,
			    bool do_cont, set<string> skip_set) {
    string msg = "PredictSVM("+fnpre+") : ";

    Query* q = CheckQuery();
    DataBase* db = CheckDB();

    // svmp->UseBinCache(false);

    ios_base::openmode mode = ios_base::out | ios_base::trunc;
    if (do_cont)
      mode = ios_base::out | ios_base::app;

    size_t npreds = 0;
    size_t topred = 0;
    size_t skipped = 0;
    ofstream fp(fnpre.c_str(), mode);
    if (!do_cont)
      fp << "# PRECALCULATEDFILE" << endl;

    size_t max = q->DataBaseSize();
    ProgressBar pb(max/100, 60, "Generating pre: ");

    vector<size_t> idx;
    for (size_t i=0; i<max; i++) {
      if (i % 100==0)
        if (!trecvid_noprogressbar)
          pb.Inc();

      if (rst.Get(i)==1) {
        const string& lab = db->Label(i);
        topred++;
        if (do_cont && skip_set.find(lab) != skip_set.end()) {
          skipped++;
          continue;
        }

        idx.push_back(i);
      }

      if (idx.size() > 100 || i+1==max) {
        FloatVectorSet data = svmp->DataByIndices(idx,
						  tolerate_missing_features);

        for (size_t j=0; j<idx.size(); j++) {
          size_t ii = idx[j];

          const string& lab = db->Label(ii);

          const FloatVector *v = data.FindByNumber(ii);

          if (!v) {
            WriteLog(msg+" WARNING: idx="+ToStr(ii)+" is NULL!");
          } else {
            double p = svmp->PredictProb(*v, predict_str, n);
            fp << p << " " << lab << endl;
            npreds++;
          }
        }
        idx.clear();
      }
    }
    fp.close();
    cout << endl;
    WriteLog(msg, "Wrote "+ToStr(npreds)+" predictions in <"+fnpre+">");

    if (npreds==0 && (skipped==0 || skipped != topred))
      return ShowError(msg+"npreds==0");
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::CreateELM(const Query&) {
    string msg = "CreateELM() : ";

#ifdef USE_ELM
    WriteLog(msg+"starting");
    using namespace slmotion;

    vector<vector<float> > pos, neg;
    vector<float> sample(2);    
    
    vector<float> a(2), b(2);
    a[0] = +1;
    b[0] = -0.5;
    pos.push_back(a);
    neg.push_back(b);

    ELMClassifier elmclassifier;
    elmclassifier.train(pos, neg);
    float r1 = elmclassifier.predict(sample);
    float r2 = elmclassifier.predict_lean(sample);
    
    WriteLog(msg+"ending with r1="+ToStr(r1)+ " r2="+ToStr(r2));

    return true;
#else
    return ShowError(msg+"USE_ELM is undef");
#endif // USE_ELM
  }

///////////////////////////////////////////////////////////////////////////////

bool Analysis::PrepareRawData(TSSOM& tssom, TSSOM::raw_data_spec_t& rd_spec,
                              DataSet& rawset) {
  string msg = "Analysis::PrepareRawData() : ";

  vector<string> rawpars = SplitInCommas(rawdata);
  vector<int> rawpar;
  for (size_t p=0; p<rawpars.size(); p++)
    rawpar.push_back(atoi(rawpars[p].c_str()));
  if (rawpar.size()!=3 || rawpar[0]<1 || rawpar[0]<1 || rawpar[0]<1)
    return ShowError(msg+"rawpar not of format total,objects,samples");

  rd_spec.ntotal   = rawpar[0];
  rd_spec.nobjects = rawpar[1];
  rd_spec.nsamples = rawpar[2];
  rd_spec.tssom    = &tssom;
  rd_spec.randvar  = RandVar(RndSeed());

  if (!SetRawPreProcess(rd_spec, rawset))
    return ShowError(msg+"setting preprocess failed");

  WriteLog("Preparing to extract "+ToStr(rd_spec.ntotal)+" raw "+tssom.Name()+
           " features from at least "+ToStr(rd_spec.nobjects)+" files, "+
           ToStr(rd_spec.nsamples)+" samples from each preprocess=<"+
           preprocess+"> rndseed="+ToStr(RndSeed()));

  int vec_len = tssom.PrepareRawData(rd_spec, true);
  rawset.Lengthen(vec_len);
  rawset.SetNitems(rawpar[0]);
  rawset.SetCallback((CFP_pthread)&TSSOM::RawDataSourceCallBack,
                     (void*)&rd_spec);

  return vec_len;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::SetRawPreProcess(TSSOM::raw_data_spec_t& s, DataSet& rset) {
  string msg = "Analysis::SetRawPreProcess() : ";

  if (preprocess=="")
    return true;

  if (preprocess.find("z(")!=0 || preprocess.size()<4 ||
      preprocess[preprocess.size()-1]!=')')
    return ShowError(msg+"preprocess should be \"z(CODFILENAME)\"");

  string ofname = preprocess.substr(2, preprocess.size()-3), fname = ofname;
  if (!FileExists(fname)) {
    fname = s.tssom->FindFile(fname, "");
    if (!FileExists(fname))
      fname = s.tssom->FindFile(fname, ".cod");
    if (!FileExists(fname))
      fname = ofname;
  }

  DataSet dat(fname.c_str());
  if (!dat.VectorLength())
    return ShowError(msg+"failed to read <"+ofname+">");

  const vector<simple::VectorComponent>& c = dat.ComponentDescriptions();
  if (!c.size())
    return ShowError(msg+"<components> not present in <"+fname+">");

  rset.Lengthen(dat.VectorLength());
  xmlNodePtr ncomp = rset.FindOrAddFeatureComponents();

  s.mean .resize(c.size());
  s.stdev.resize(c.size());
  for (size_t i=0; i<c.size(); i++) {
    s.mean[i]  = c[i].mean;
    s.stdev[i] = c[i].stdev;
    ncomp = rset.SetFeatureComponentMeanStDev(ncomp, s.mean[i], s.stdev[i]);
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::HandleAlienDataBase(Query& my_query) {
  const string& aliendb = alien_data!="" ? alien_data : alien_map;
  DataBase *adb = picsom->FindDataBase(aliendb);
  if (!adb)
    return ShowError("HandleAlienDataBase() : aliendb ", aliendb,
                     " not found");

  TSSOM::tssom_type t
    = alien_data!="" ? TSSOM::tssom_alien_data : TSSOM::tssom_alien_map;

  bool ok = true;

  for (size_t m = 0; ok && m<my_query.Nindices(); m++) {
    TSSOM& tssom = my_query.TsSom(m);
    Index *ats = adb->FindIndex(tssom.Name());
    if (!ats)
      return ShowError("HandleAlienDataBase() : alien feature ",
                       tssom.Name(), " not found");

    TSSOM *atssom = (TSSOM*)ats; // obs!

    if (t==TSSOM::tssom_alien_data)
      atssom->ReadDataFile();
    else 
      atssom->ReadMapFile();

    if (atssom->VectorLength()!=tssom.VectorLength()) {
      char tmp[1000];
      sprintf(tmp, "%s/%s : %d whereas %s/%s : %d",
              my_query.DataBaseName().c_str(), tssom.Name().c_str(),
              (int)tssom.VectorLength(),
              adb->Name().c_str(), ats->Name().c_str(),
	      (int)atssom->VectorLength());
      return
        ShowError("HandleAlienDataBase() : vector length mismatch : ", tmp);
    }

    string fname = tssom.AlienFeatureName(*atssom, t);

    if (t==TSSOM::tssom_alien_data)
      ok = DivideAlienData(tssom, *atssom, true, fname);
    else
      ok = DivideAlienData(*atssom, tssom, true, fname);
  }

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::DivideAlienData(TSSOM& own, TSSOM& alien, bool do_cod,
                                       const string& fname) {
  own.ReadMapFile();
  if (!alien.SetDataSetNumbers(false, false))
    return ShowError("Analysis::DivideAlienData() : "
                     "SetDataSetNumbers() failed");

  TreeSOM &ts = own.Map();
  ts.TrainCount(IntVector(ts.Nlevels()));
  ts.TrainingSet(alien.Data());
  ts.FileName(OutDirEvenDot()+fname+".cod");
  ts.Zipped(zipped);
  ts.Sparse(labelsonly);  // we don't have special sparse flag yet!
  ts.WriteLabelsOnly(labelsonly);
  ts.DivideByNumbers(true);
  ts.Voting(SOM::NearestVoting);
  ts.TicTacSet(picsom->GetTicTac());
  ts.PropagateSome();

  if (!ts.Train(-1, do_cod, true))
    return ShowError("Analysis::DivideAlienData() : TreeSOM::Train() failed");

  stringstream msg;
  msg << alien.DataBaseName() << "/" << alien.Name()
      << " divided on " << own.DataBaseName() << "/" << own.Name()
      << " written in " << OutDirEvenDot()+fname
      << (do_cod?".{cod,div}":".div");
  WriteLog(msg.str());

  return true;
}


///////////////////////////////////////////////////////////////////////////////

  FloatVector::DistanceType* Analysis::MakeMetric(int vl) {
    bool debug = true;
    string msg = string("MakeMetric(")+ToStr(vl)+"): ";

    if (metric.empty())
      return NULL;

    FloatVector::DistanceType* dt = FloatVector::MakeDistance(metric);

    if (dt && !metric_weights.empty()) {
      FloatVector* mweights =
        ParseSparse(metric_weights, vl);
      if (!mweights) {
        ShowError(msg, "Cannot parse metric weights: "+metric_weights);
        return NULL;
      }
      dt->SetWeights(mweights);

      if (debug) {
        float p = -1.0;
        int count = 0;
        stringstream ss;
        int N = mweights->Length();
        for (int i=0; i<N; i++) {
          float v = mweights->Get(i);
          
          if (i==0) {
            p = v;
            count = 1;
            continue;
          }
          
          if (p!=v || i==N-1) {
            ss << p;

            if (count > 1) {
              ss << " x " << count;
            }

            if (i < N-1)
              ss << ", ";
            count = 1;
            p = v;
          } else {
            count++;
          }
        }
        WriteLog(msg, "Set metric weights to [" + ss.str() + "]");
      }
    }

    return dt;
  }


///////////////////////////////////////////////////////////////////////////////

bool Analysis::SetMetric(Classifier& tsr, string& str) {
  if (metric.length()) {
    tsr.Metric(MakeMetric(tsr.VectorLength()));
    if (tsr.Metric()) {
      str += string("-")+tsr.Metric()->String(false);
    } else
      return false;
    
    if (tsr.Metric()->GetType()==FloatVector::DistanceType::mahalanobis
        && !tsr.SetCovInvInMetric())
      return false;

    WriteLog("Metric <", metric.c_str(), "> set");
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::CreateLBG(Query& my_query) {
  if (units<1) {
    ShowError("CreateLBG() : missing units specification");
    return false;
  }

  if (traincount.Length()!=1)
    ShowError("CreateLBG() : traincount.Length()!=1");

  bool ok = true;

  for (size_t m = 0; m<my_query.Nindices(); m++) {
    TSSOM& tssom = my_query.TsSom(m);
    string fname = tssom.Name();
    int l = tssom.VectorLength();
    TreeSOM ts(units, 1, l);
    FloatVectorSet& data = tssom.Data();

    DataSet rawset;
    TSSOM::raw_data_spec_t rd_spec;
    if (rawdata!="") {
      if (labelsonly) {
        ok = ShowError("Simultaneous rawdata=xxx and labelsonly=true "
                       "is senseless");
        continue;
      }
      
      if (!PrepareRawData(tssom, rd_spec, rawset))
        continue;
    }
    
    bool userawset = rawset.VectorLength();
    FloatVectorSet rawdata;

    if(!userawset){

      if (data.Nitems())
        for (int i=0; i<units; i++) {
          *ts.Unit(i) = data[i%data.Nitems()];
          ts.Unit(i)->Label(NULL);
        }
    }
    else{

//       bool writerawdata=true;

//       if(writerawdata){
//         string outname=fname+"-raw.dat";
//         DataSet dst(outname.c_str(), true);
//         rawset.First();
//         for (const FloatVector *v; (v = rawset.Next());) {
//           FloatVector x(*v);
//           x.Label(
//           dst.Append(&v, false);
//           cnt++;
//         }

//         WriteLog("Done writing ", ToStr(cnt), " raw vectors");


//         }
//       }

      rawset.First();
      if (rawset.Nitems())
        for (int i=0; i<units; i++) {
          const FloatVector *vec=rawset.Next();
          if(!vec){
            rawset.First();
            vec=rawset.Next();
          }
          if(!vec) break;
          *ts.Unit(i) = *vec;
          ts.Unit(i)->Label(NULL);
        }
      
      rawset.First();
      for (const FloatVector *v=rawset.Next(); (v = rawset.Next());) {
        rawdata.Append(new FloatVector(*v));
      }

    }
   

    char divname[1024];

    if (namesuffix!="")
          fname += string("-")+namesuffix;

    string rawsuffix = "-raw";
    if (userawset && fname.find(rawsuffix)==string::npos)
      fname += rawsuffix;

        if (filename!="") // if override is forced
          fname = filename;

    ts.FileName(OutDirEvenDot()+fname+".cod");
    sprintf(divname, "./%s.div", my_query.TsSom(m).Name().c_str());
    cout << TimeStamp() << "LBG: " << my_query.IndexFullName(m) << " -> "
         << ts.FileName() << " + " << divname << endl;

    ts.TrainingSet(userawset ? (simple::FloatVectorSource*)&rawset
                        : (simple::FloatVectorSource*)&data);
    ts.Description("THIS ``TreeSOM'' was actually generateted "
                   "with Linde-Buzo-Gray method");

    for (int r=0; r<traincount[0]; r++) {
      // float mse = ts.VectorSetPart().MeanSquaredDistance(data);
      float mse, dif = ts.VectorSetPart().LindeBuzoGray(userawset? rawdata: data, &mse);
      cout << TimeStamp() << r << " " << mse << " " << dif << endl;

      if (!ts.Write()){
        ShowError("CreateLBG() : failed to write to <",
                  ts.FileName(), ">");

        cout << "updated file " << ts.FileName() << endl;
      }
      else if (!userawset && !ts.DivideXX(my_query.TsSom(m).Data(), divname))
        ShowError("CreateLBG() : failed to divide to <", divname, ">");

      if (!dif)
        break;
    }
  }

  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::CreateOrd(Query& my_query) {
  for (size_t m = 0; m<my_query.Nindices(); m++) {
    FloatVectorSet ord = my_query.TsSom(m).Data().OrderComponentValues();
    char fname[1024];  // OutDirEvenDot()
    sprintf(fname, "./%s.ord", my_query.TsSom(m).Name().c_str());
    if (!ord.Write(fname)) {
      ShowError("CreateOrd() : failed to write to <", fname, ">");
      break;
    }
    WriteLog("Created component ordered file ", fname);
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::CreateMeanDist(Query& my_query) {
  for (size_t m = 0; m<my_query.Nindices(); m++) {
    const FloatVectorSet& data = my_query.TsSom(m).Data();
    double meandistance = 0.0;
    for (int j=0; j<data.Nitems(); j++) {
      meandistance += data.MeanSquaredDistance(data[j]);
    }
    cout << TimeStamp() << "meandistance of [" << my_query.IndexFullName(m)
         << "]: " << meandistance / data.Nitems() << endl;
  }
  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::CreateGroundTruth() {
  string msg = "CreateGroundTruth() : ";

  if ((field=="" || value=="") && queryname=="")
    return ShowError(msg+"EITHER field and value OR queryname should be set");

  ground_truth gt = field!="" && value!="" ? CreateGroundTruthOrigins()
    : CreateGroundTruthQuery();

  if (classname=="")
    return true;

  DataBase *db = CheckDB();

  cout << endl;
  db->GroundTruthSummary(gt);
  cout << endl;

  string text = "\n"+TimeStamp()+" "+msg+"field=<"+field+"> value=<"+value
    +"> query=<"+queryname+">\n";

  bool cwd = true;
  return db->ConditionallyWriteClassFile(cwd, classname, gt, text, false);
}

///////////////////////////////////////////////////////////////////////////////

ground_truth Analysis::CreateGroundTruthQuery() {
  string msg = "CreateGroundTruthQuery() : ";

  if (queryname=="") {
    ShowError(msg+"queryname should be set");
    return ground_truth();
  }

  string qfile = queryname;
  if (!FileExists(qfile)) {
    qfile = Picsom()->SavePath(queryname, true);
    if (!FileExists(qfile)) {
      ShowError(msg+"query="+queryname+" could not be found in . "
                "nor as <"+qfile+">");
      return ground_truth();
    }
  } 

  Picsom()->DeleteQuery(query);
  query = new Query(Picsom(), qfile);
  Picsom()->AppendQuery(query, false);

  DataBase *db = GetDataBase();
  int val = unseenzero ? 0 : -1;
  ground_truth gt(db->Size(), val);
 
  typedef list<pair<int,float> > list_t;
  list_t l = query->DepthFirstSeenObjects();

  for (list_t::const_iterator j=l.begin(); j!=l.end(); j++) {
    // cout << j->first << " " << j->second << endl;
    gt[j->first] = (int)j->second;
  }

  if (trecvid!="") {
    Query *qlarge = query->FindLargestChild();
    int nq = qlarge->NnewObjectsRetainedNonShow();

    WriteLog("Extracting "+ToStr(nq)+" objects from <"+qlarge->Identity()+">");

    // SetElapsedTime(query, qlarge, false);
    SetElapsedTime(query, query, true);

    qlarge->MaxQuestions(1000); // maxquestion is not saved! why?

    objectlist_t bestidxval; // obs! this is for faking *ResultsTrecvid()
    AnalyseBestResultsTrecvid(qlarge, bestidxval);
  }

  return gt;
}

///////////////////////////////////////////////////////////////////////////////

ground_truth Analysis::CreateGroundTruthOrigins() {
  bool warn_empty = true;

  string msg = "CreateGroundTruthOrigins() : ";

  if (field=="" || value=="") {
    ShowError(msg+"field and value should be set");
    return ground_truth();
  }

  target_type tt = Target();
  if (tt==target_no_target) {
    ShowError(msg+"missing target specification");
    return ground_truth();
  }

  DataBase *db = CheckDB();
  WriteLog("Creating ground truth <"+classname+"> in "+db->Name());

  ground_truth gt(db->Size());
  gt.Label(classname);

  for (size_t i=0; i<db->Size(); i++)
    if (db->ObjectsTargetType(i)&tt) {
      map<string,string> info = db->ReadOriginsInfo(i, true, false);
      if (info.empty())
        ShowError(msg+"empty origins info hash for <", db->Label(i), ">");
      
      if (info.find(field)==info.end() && warn_empty)
        ShowError(msg+"no <"+field+"> field for <", db->Label(i), ">");

      // for now, only substring matching:

      bool hit = info[field].find(value)!=string::npos;
      gt[i] = hit ? 1 : -1;

      if (verbose>2)
        cout << i << " " << hit << endl;
    }

  return gt;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::RandProj(Query& my_query) {
  int k = randproj;
  bool znorm = preprocess=="z";
  int seed = my_query.RndSeed();

  for (size_t n = 0; n<my_query.Nindices(); n++) {
    string inname = my_query.TsSom(n).DataFileName(0);  // obs this (0)!

    WriteLog("Random projecting ", inname.c_str(), " to ", ToStr(k),
             " dimensions");

    DataSet src(inname.c_str());
    int d = src.VectorLength();

    WriteLog("Original dimensionality ", ToStr(d));

    char mtxsize[100];
    sprintf(mtxsize, "%dx%d", k, d);
    WriteLog("Starting to form projection matrix of size ", mtxsize,
             " with rndseed=", ToStr(seed));

    RandVar randvar(seed);
    
    simple::FloatMatrix m(k, d);
    const float sq3 = sqrt(3.0);
    // fill up the matrix
    for (int i=0; i<k; i++) {
      for (int j=0; j<d; j++) {
        float rnd = randvar, comp;
        if ( rnd < 1.0/6 )
          comp = sq3;
        else if ( rnd < 5.0/6 )
          comp = 0;
        else
          comp = -sq3;
        m.Set(i, j, comp);
      }
    }
    WriteLog("Projection matrix formed and will be transposed");
    m.Transpose(TRUE);
    WriteLog("Projection matrix transposed");


    //cout << "dumping projection matrix:" << endl;
    //for(int row=0; row<d;row++){
    //  for(int col=0; col<k;col++)
    //        cout << m.Get(row,col) << "  ";
    //  cout << endl;
    // }


    FloatVector stdev, mean;
    if (znorm) { 
      WriteLog("Starting to calculate variances");
      stdev = src.StandardDeviation(&mean); 
      string stdevfile = "variances.txt";
      stdev.Write(stdevfile.c_str());
      WriteLog("Variances calculated and saved in ", stdevfile.c_str());
    
      for (int i=0; i<stdev.Length(); i++)
        if (stdev[i]==0)
          stdev[i] = 1;
    }

    string outname = string(IndexFullName(n))+"-rp"+ToStr(k)
      +(znorm?"-z":"")+".dat";
    if (zipped)
      outname += ".gz";

    DataSet dst(outname.c_str(), true);
    dst.Zipped(zipped);

    WriteLog("Writing ", (zipped?"zipped ":""), "to ", outname.c_str());
 
    src.First();
    int cnt = 0;
    for (const FloatVector *v; (v = src.Next());) {
      FloatVector x = m.PreTransMultiply(znorm ? (*v-mean)/stdev : *v);
      dst.Append(&x, false);
      cnt++;
    }

    WriteLog("Done writing ", ToStr(cnt), " random projected vectors");
  }

  return true;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::ConcatFeat(Query& my_query) {

  // parse arguments from key concatfeat

  bool do_pca=false;
  int pcalen=-1;

  bool do_randproj=false;
  int randprojlen=-1;

  bool do_norm=false;
  bool equalisefeats=false;

  const string& str = concatfeat;
  size_t pos;
    
  if((pos=str.find("pca")) != string::npos){
    do_pca=true;
    sscanf(str.substr(pos+3).c_str(),"%d",&pcalen);
  }

  if((pos=str.find("randproj")) != string::npos){
    do_randproj=true;
    sscanf(str.substr(pos+8).c_str(),"%d",&randprojlen);
  }

  if(str.find("norm") != string::npos){
    do_norm=true;
  }

  if(str.find("equalisefeats") != string::npos){
    equalisefeats=true;
  }
  
  
  cout << "Parsed postprocessing: ";
  if(do_randproj) cout << "Random projection("<<randprojlen<<")";
  if(do_pca) cout << "PCA("<<pcalen<<") ";
  if(do_norm) cout << "norm ";
  if(equalisefeats) cout << "equalisefeats";
  if(!do_randproj && !do_pca && !do_norm && !equalisefeats)cout << "none";
  cout<<endl;

  if(do_randproj || do_pca) cout << "Dimension reduction not yet implemented." << endl;

  map<string,FloatVector> vectors; 

  int dim=0;
  int nvec=0;

  FloatVector eqVector;

  for (size_t n = 0; n<my_query.Nindices(); n++) {

    int ctr=0;

    const FloatVectorSet& d=my_query.TsSom(n).Data();
    char msg[200];

    float weight=my_query.Weight(n);
    if(weight != 1.0) 
      cout << "weighting feature "<<n<<" w/ weight "<<weight<<endl;



    if (n>0 && d.Nitems() != nvec){
      sprintf(msg,"%dth data set has %d items, should be %d",
              (int)n, d.Nitems(), nvec);

      return ShowError(msg);
    }

    for(int i=0;i<d.Nitems();i++){

      const FloatVector *v=d.FastGet(i);

      int startindex,stopindex;

      if(n>0){
	if(vectors.count(v->Label())==0){
	  sprintf(msg,"%dth data has novel label %s",(int)n,v->Label());
	  return ShowError(msg);
	}
	startindex=vectors[v->Label()].Length();
	stopindex = startindex + v->Length()-1;
	vectors[v->Label()].Append(*v);	
      }
      else{
	// cout << "First data file: label " << v->Label() << endl;
	vectors[v->Label()]=*v;
	startindex=0;
	stopindex = v->Length()-1;
	//	cout << "after: count="<<
      }

      if(weight!=1.0){
	for(int ii=startindex;ii<=stopindex;ii++)
	vectors[v->Label()][ii]*=weight;
      }
      
      ctr++;
    }

    if(n>0){
      if(ctr!=nvec){
        sprintf(msg,"%d labels missing from %dth data set",nvec-ctr,(int)n);
        return ShowError(msg);
      }
    }
    else
      nvec=ctr;

    dim += d.VectorLength();

    if(equalisefeats){
      float eq=sqrt((float)d.VectorLength());
      for(int i=0;i<d.VectorLength();i++)
        eqVector.Push(eq);
    }

  }

  cout << "Collected "<<vectors.size()<<" vectors, dim="<<dim<<endl;

  FloatVectorSet set;

  map<string,FloatVector>::iterator it;
  for (it=vectors.begin();it!=vectors.end();it++) {
      set.AppendCopy(it->second);
  }


  if(do_norm || equalisefeats){

    FloatVector stdev, mean,eq;
    if(do_norm){
      stdev = set.StandardDeviation(&mean); 
      for (int i=0; i<stdev.Length(); i++){
        if (stdev[i]==0)
          stdev[i] = 1;
        
      }

      if(equalisefeats)
        stdev *= eqVector;

      for(int i=0;i<set.Nitems();i++){
        *set.FastGet(i) -= mean;
        *set.FastGet(i) /= stdev;
      }
    }
    else
      for(int i=0;i<set.Nitems();i++)
        *set.FastGet(i) /= eqVector;
  }




  string outname;
  if(FileName()!="") outname=FileName();
  else{
    outname=my_query.IndexFullName(0);
    for (size_t j=1; j<my_query.Nindices(); j++)
      outname += string("+")+my_query.IndexFullName(j);
    if(do_norm)
      outname +="-z";

  }
  
  outname += ".dat";

  if (zipped)
    outname += ".gz";


  DataSet dst(outname.c_str(), true);
  dst.Zipped(zipped);

  WriteLog("Writing ", (zipped?"zipped ":""), "to ", outname.c_str());


  
  for(int i=0;i<set.Nitems();i++)
    dst.Append(set.FastGet(i),FALSE); // do not delete vector upon writing

  WriteLog("Done writing ", ToStr(set.Nitems()), " segment histogram vectors");

  return true;
}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result 
Analysis::ConcatMapCoord(const vector<string>&) {

  DataBase *db=query->GetDataBase();
  char msg[200];

  query->ReadFiles();

  int cnt=0;

  FloatVectorSet set;

  CreateIndexData(false);

  // loop over images
  for(size_t idx=0;idx<query->DataBaseSize();idx++){

    FloatVector imgvec;

    const char *lbl = db->Label(idx).c_str();

    bool on_one_map=false;

    // loop over maps

    for (size_t j=0; j<Nindices(); j++) {

      int bot = query->NlevelsEvenAlien(j)-1;

      const TreeSOM &ts = query->MapEvenAlien(j, bot);
      const IntVector& div = query->Division(j, bot);

      int mapidx = div.IndexOK(idx) ? div[idx] : -1;

      if(mapidx>=0){
        if(j>0 && on_one_map==false){
          sprintf(msg,"Label %s encountered only on %dth map",lbl,(int)j);
          return ShowError(msg);
        }

        on_one_map=true;
        IntPoint p = ts.ToPoint(mapidx);
        imgvec.Push(p.X());
        imgvec.Push(p.Y());

      } else if(on_one_map){
        sprintf(msg,"Label %s encountered earlier but not on %dth map",
                lbl,(int)j);
        return ShowError(msg);
      }
    } // loop over maps

    if(on_one_map){
      imgvec.Label(lbl);
      set.AppendCopy(imgvec); 
      if(cnt%50 == 0) WriteLog("Processed object #", ToStr(cnt),"(",lbl,")");
      cnt++;
    }
    //else WriteLog("Skipped object ",lbl);

  }

  string outname;
  if(FileName()!="") outname=FileName();
  else{
    outname=IndexFullName(0);
    for (size_t j=1; j<Nindices(); j++)
      outname += string("+")+IndexFullName(j);
  }
  
  outname += "-mapcoord.dat";

  if (zipped)
    outname += ".gz";

  DataSet dst(outname.c_str(), true);
  dst.Zipped(zipped);
  
  WriteLog("Writing ", (zipped?"zipped ":""), "to ", outname.c_str());
  
  for(int i=0;i<set.Nitems();i++)
    dst.Append(set.FastGet(i),FALSE); // do not delete vector upon writing

  WriteLog("Done writing ", ToStr(set.Nitems()), " mapcoord vectors");

  return true;

}
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result 
Analysis::CreateSegmentHistogram(const vector<string>&args) {

  // parse arguments from argument string

  bool do_pca=false;
  int pcalen=-1;

  bool do_randproj=false;
  int randprojlen=-1;

  bool do_norm=false;

  for (size_t i=0; i<args.size(); i++) {
    const string& str = args[i];
    size_t pos;
    
    if((pos=str.find("pca")) != string::npos){
      do_pca=true;
      sscanf(str.substr(pos+3).c_str(),"%d",&pcalen);
    }

    if((pos=str.find("randproj")) != string::npos){
      do_randproj=true;
      sscanf(str.substr(pos+8).c_str(),"%d",&randprojlen);
    }

    if(str.find("norm") != string::npos){
      do_norm=true;
    }
  }

  
    cout << "Parsed postprocessing: ";
  if(do_randproj) cout << "Random projection("<<randprojlen<<")";
  if(do_pca) cout << "PCA("<<pcalen<<") ";
  if(do_norm) cout << "norm";
  if(!do_randproj && !do_pca && !do_norm) cout << "none";
  cout<<endl;

  DataBase *db=query->GetDataBase();

  if ((Target()&target_image)==0)
    return ShowError("segmenthistogram supports only target type image");

  query->ReadFiles();

  // perform our own file reading as ReadFiles() deduces wrong what
  // files are needed in this case

  // bool force = false;
  //bool read_cod = true, read_div = true, read_cnv = false, read_ord = false, read_dat = false,read_nbr=false;
  
  //bool labonly = true;
 
  //for (int j=0; j<query->Nindices(); j++)
  //  if(!query->TsSom(j).ReadFiles(force, labonly, read_dat, read_cod, 
  //                                    read_div, read_cnv, read_ord,read_nbr))
  //    return ShowError("Analysis::CreateSegmentHistogram() : "
  //                       "Error reading map files");

  int cnt=0;

  if(do_pca && do_randproj && randprojlen < pcalen)
    return ShowError("random projection before pca, but pcalen>rand. proj. len)");

  FloatVectorSet set;

  simple::FloatMatrix *randomMatrix=NULL;


   //  cout << "IndexData "<<((query->IndexDataExists_xxx())?"exists.":"does not exist.")<<endl;

   CreateIndexData(false);

  // loop over images
  for(size_t idx=0;idx<query->DataBaseSize();idx++){

    //    if(gt_tt[idx]==0) continue;

    // hard coded

    if (db->ObjectsTargetType(idx)!=target_image &&
	db->ObjectsTargetType(idx)!=target_imagefile)
      continue;

    FloatVector imgvec;

    const char *lbl = db->Label(idx).c_str();
    const vector<int> sub= db->SubObjects(idx);

    // loop over maps

    if(cnt%50 == 0) WriteLog("Processing image #", ToStr(cnt),"(",lbl,")");
    
    for (size_t j=0; j<Nindices(); j++) {

      int lvl=level;
      if(lvl<0)
        lvl = query->NlevelsEvenAlien(j)-1;

      const TreeSOM &ts = query->MapEvenAlien(j, lvl);
      const IntVector& div = query->Division(j, lvl);

      simple::FloatMatrix&  hts = query->Hits(j, lvl, 0);

      query->SetSizeOrZero(hts, ts);

      const int r = query->Hits(j,lvl,0).Rows(), 
        c = query->Hits(j,lvl,0).Columns();

      if(r%4 || c%4)
        return ShowError("map size must be multiple of 4");

      // loop over subobjects;
      for (size_t subi=0; subi<sub.size(); subi++){
        int mapidx = div.IndexOK(sub[subi]) ? div[sub[subi]] : -1;
        if(mapidx>=0){
          IntPoint p = ts.ToPoint(mapidx);
          hts.Add(p.Y(), p.X(), 1.0);
        }
      }

      // convolve the histogram

      query->Convolve(j,lvl,0);

      // downsample the histogram with factor of 4

      for(int y=0;y<r/4;y++) for(int x=0;x<c/4;x++){

        double sum=0;
        for(int dy=0;dy<4;dy++) for(int dx=0;dx<4;dx++){
          sum+=query->Convolved(j, lvl, 0).Get(4*y+dy, 4*x+dx);
        }

        imgvec.Push(sum);
      }
    } // loop over maps

    imgvec.Label(lbl);
    
    if(do_randproj){

      int orgd=imgvec.Length();

      if(randomMatrix==NULL){

        //int orgd=imgvec.Length();
        randomMatrix=new simple::FloatMatrix(randprojlen,orgd);

        int seed = query->RndSeed();
        RandVar randvar(seed);

        char mtxsize[100];
        sprintf(mtxsize, "%dx%d", randprojlen, orgd);
        WriteLog("Forming projection matrix of size ", mtxsize,
                 " with rndseed=", ToStr(seed));

        const float sq3 = sqrt(3.0);
        // fill up the matrix
        for (int i=0; i<randprojlen; i++) {
          for (int j=0; j<orgd; j++) {
            float rnd = randvar, comp;
            if ( rnd < 1.0/6 )
              comp = sq3;
            else if ( rnd < 5.0/6 )
              comp = 0;
            else
              comp = -sq3;
            randomMatrix->Set(i, j, comp);
          }
        }
      

        // row vectors form now random basis 

      }

      FloatVector x(randprojlen);

      for(int i=0;i<randprojlen;i++){
        float s=0;
        for(int j=0;j<orgd;j++){
          s += imgvec.FastGet(j)*randomMatrix->FastGet(i,j);
        }
        x.FastSet(i,s);
      }
 
      x.Label(lbl);
      set.AppendCopy(x); 
    }
    else
      set.AppendCopy(imgvec); 

    cnt++;

  }

  bool pcaperformed = false;
  if (do_pca) {

    // OBS! results are nonsense with linux 64

    PerformPCA(set, pcalen);
    pcaperformed = true;
  } 
  if (do_pca && !pcaperformed)
    return ShowError("Analysis::CreateSegmentHistogram() : PCA code not included.");

  if (do_norm) {
    FloatVector stdev, mean;
    stdev = set.StandardDeviation(&mean); 
    for (int i=0; i<stdev.Length(); i++)
      if (stdev[i]==0)
        stdev[i] = 1;

    for(int i=0;i<set.Nitems();i++){
      *set.FastGet(i) -= mean;
      *set.FastGet(i) /= stdev;
    }

  }

  string outname;
  if(FileName()!="") outname=FileName();
  else{
    outname=IndexFullName(0);
    for (size_t j=1; j<Nindices(); j++)
      outname += string("+")+IndexFullName(j);
  }

  outname += "-segmhist.dat";

  if (zipped)
    outname += ".gz";

  DataSet dst(outname.c_str(), true);
  dst.Zipped(zipped);
  
  WriteLog("Writing ", (zipped?"zipped ":""), "to ", outname.c_str());
  
  for(int i=0;i<set.Nitems();i++)
    dst.Append(set.FastGet(i),FALSE); // do not delete vector upon writing

  WriteLog("Done writing ", ToStr(set.Nitems()), " segment histogram vectors");

  delete randomMatrix;
  
  return true;

}

///////////////////////////////////////////////////////////////////////////////

Analysis::analyse_result 
Analysis::DivStats(const vector<string>&) {
  query->ReadFiles();
  for (size_t j=0; j<Nindices(); j++) {
    
    int bot = query->NlevelsEvenAlien(j)-1;

    const TreeSOM &ts = query->MapEvenAlien(j, bot);
    const IntVector& div = query->Division(j, bot);

    cout << "map: "<<IndexFullName(j)<<" bottom level:"<<bot<<endl;

    int l=ts.Width()*ts.Height();

    vector<int> ctr(l,0); 

    for (int i=0; i<div.Length(); i++)
      if(div[i]>=0){
        if(div[i]>=l) throw string("Div index out of range");
        ctr[div[i]]++;
      }

    for(int i=0;i<l;i++)
      cout << "ctr["<<i<<"]: "<<ctr[i]<<endl;
  }

  return true;
}

  ////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::ExtractMedia() {
    string msg = "Analysis::ExtractMedia() : ";
    return ShowError(msg+"not implemented yet, dunno if ever will?");;
  }

  ////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::DoDetections() {
    string msg = "Analysis::DoDetections() : ";
    return ShowError(msg+"not implemented yet, dunno if ever will?");;
  }

  ////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::DoSegments() {
    string msg = "Analysis::DoSegments() : ";
    return ShowError(msg+"not implemented yet, dunno if ever will?");;
  }

  ////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::ExtractFeaturesListed(const vector<string>& args) {
    string msg = "Analysis::ExtractFeaturesListed() : ";

    bool never_fail = true;

    DataBase *db = CheckDB();

    map<string,vector<size_t>> perfeat;
    for (auto i=args.begin(); i!=args.end(); i++) {
      size_t p = i->find('/');
      if (p==string::npos)
	return ShowError(msg+"'/' not found in <"+*i+">");

      int idx = db->LabelIndex(i->substr(p+1));
      if (!db->IndexOK(idx))
	return ShowError(msg+"<"+i->substr(p+1)+"> is not a valid label");

      perfeat[i->substr(0, p)].push_back((size_t)idx);
    }

    InitializeXmlResult(true);
    XmlDom resfea = xml_result.Root().Element("featurevectorlist");

    for (auto i=perfeat.begin(); i!=perfeat.end(); i++) {
      Index *idx = db->FindIndexInternal(i->first, true);
      if (!idx)
	return ShowError(msg+"index <"+i->first+"> not found");
      if (idx->IsDummy())
	idx = db->FindIndex(i->first, "", true, false);
   
      list<incore_feature_t> incore;
      set<string> done_segm;
      if (!idx->CalculateFeatures(i->second, incore,
				  done_segm, resfea, NULL)) {
	ShowError(msg+"feature extraction \""+i->first+"\" failed"+
		  (never_fail?" continuing still...":""));
	if (!never_fail)
	  return false;
      }
    }

    db->RemoveCreated(".mp4,.jpeg");

    return true;
  }
    
  ////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::ExtractFeatures(Query&, bool do_callback,
				 const vector<string>& args) {
    if (args.size())
      return ExtractFeaturesListed(args);

    string msg = "Analysis::ExtractFeatures() : ";

    bool debug = false;
    // bool reextract_zero_vectors = false;
    size_t min_count_to_split = Picsom()->HasSlaves() ? 1 : 2;

    set<string> segments;
    DataBase *db = CheckDB();
    
    bool check_orphans = !db->SqlMode();

    bool ok = true, was_split = false, free_slaves = Picsom()->HasFreeSlaves();
    size_t n_missing_tot = 0, n_zero_tot = 0;
    bool stop_on_error = false;
    bool xml_result_initialized = false;
    bool slaves_by_lists = true; // obs!

    map<size_t,map<string,vector<int> > > perslaveandfeat;
    list<string> slavescript;

    const vector<size_t>& lf = db->LabelFormat();
    size_t dirw = 0, dirl = 0, objw = 1;
    if (featextbatchsize==-100) {
      size_t ll = lf.size()>1 ? lf.size()-2 : 0;
      dirw = db->ObjectDirectoryWidth(ll, true);
      for (size_t i=0; i+1<lf.size(); i++)
	dirl += lf[i];
    } else {
      dirl = db->LabelLength();
      if (featextbatchsize>=0)
	dirl -= featextbatchsize;

      dirw = 1;
      for (size_t i=0; i<dirl; i++)
	dirw *= 10;

      for (int i=0; i>featextbatchsize; i--)
	objw *= 10;
    }

    ground_truth restr = QueryRestrictionGT(); // obs!
    WriteLog(msg+"restriction: label="+restr.label()+
	     " positives="+ToStr(restr.positives())+
	     " free_slaves="+ToStr(free_slaves)+
	     " featextbatchsize="+ToStr(featextbatchsize)+
	     " dirl="+ToStr(dirl)+" dirw="+ToStr(dirw)+" objw="+ToStr(objw)+
	     " checking "+(check_first_feature_only?"only the first":"all")+
	     " features");

    for (size_t m=0; m<query->NindicesNew(); m++) {
      size_t n_missing = 0, n_zero = 0;

      string idxname = query->IndexData(m).StaticPart()->IndexName();
      Index *baseidx = db->FindIndexInternal(idxname, true);
      if (!baseidx)
	return ShowError(msg+"failed to find index <"+idxname+">");
      if (baseidx->IsDummy())
	baseidx = db->FindIndex(idxname, "", true, false);
      VectorIndex *vecidx = dynamic_cast<VectorIndex*>(baseidx);
      TSSOM *tssomp = dynamic_cast<TSSOM*>(baseidx);
      if (!tssomp)
	return ShowError(msg+"index <"+idxname+"> is not TSSOM but "
			 +baseidx->MethodName());

      TSSOM& ts = *tssomp; // TsSom(m);

      db->PossiblyDownloadFeatureData(idxname);

      vector<size_t> dat_missing, dat_orphan, dat_zero, div_missing;

      if (!free_slaves) {
	int tot =  ts.CheckDataSet(restr, verbose-1, true,
				   dat_missing, dat_orphan,
				   dat_zero, div_missing, check_orphans,
				   recalculatefeatures);
    
	WriteLog("  "+idxname+"   total: "+ToStr(tot)+
		 "   no data: "     + ToStr(dat_missing.size())+
		 "   orphans: "     + ToStr(dat_orphan.size())+
		 "   zero data: "   + ToStr(dat_zero.size())+
		 "   no div: "      + ToStr(div_missing.size())+
		 "   restriction: " + restr.label()+
		 "   positives: "   + ToStr(restr.positives()));
      }
      // db->FindAllIndices();

      if (reextract_zero_vectors && dat_zero.size()) {
	dat_missing.insert(dat_missing.end(), dat_zero.begin(), dat_zero.end());
	WriteLog("Added "+ToStr(dat_zero.size())+" zero vectors to missing"
		 " that now contains "+ToStr(dat_missing.size()));
      }

      if (free_slaves || !dat_missing.empty()) {
	// Check the number of directories that have missing data
	size_t count = 0, count_rest = 0;
	vector<bool> dirs_v, dirs_rest_v;
	bool use_vec = dirw<100*1024*1024;
	if (use_vec)
	  dirs_v = dirs_rest_v = vector<bool>(dirw);
	set<size_t> dirs_s, dirs_rest_s;

	script_exp_t plist = ScriptExpand(script, false);
	script_exp_t::iterator i = plist.end();

	ground_truth oldgt;

	if (free_slaves) {
	  i = ScriptFind(plist, "restriction");
	  if (i!=plist.end())
	    return ShowError(msg+"restriction should be replaced with "
			     "queryrestriction/dbrestriction");
	  i = ScriptFind(plist, "queryrestriction");
	  if (i==plist.end())
	    i = ScriptFind(plist,"dbrestriction");

	  if (i!=plist.end())
	    oldgt = GTExpr(i->second);

	  for (size_t idx=0; idx<db->Size(); idx++) {
	    if (!db->ObjectsTargetTypeContains(idx, query->Target()))
	      continue;
	    const string& label = db->Label(idx);
	    size_t diridx = atol(label.substr(0, dirl).c_str());
	    if (( use_vec&&!dirs_v[diridx]) ||
		(!use_vec&&dirs_s.find(diridx)==dirs_s.end())) {
	      count++;
	      if (use_vec)
		dirs_v[diridx] = true;
	      else
		dirs_s.insert(diridx);
	    }
	    if ((( use_vec&&!dirs_rest_v[diridx]) ||
		 (!use_vec&&dirs_rest_s.find(diridx)==dirs_rest_s.end()))
		&& (oldgt.empty() || oldgt[idx]==1)) {
	      count_rest++;
	      if (use_vec)
		dirs_rest_v[diridx] = true;
	      else
		dirs_rest_s.insert(diridx);
	    }
	  }

	} else
	  for (auto it=dat_missing.begin(); it!=dat_missing.end(); it++) {
	    const string& label = ts.Label(*it);
	    size_t idx = atol(label.substr(0, dirl).c_str());
	    if (use_vec && idx>=dirs_v.size())
	      return ShowError(msg+"idx error");

	    if (( use_vec&&!dirs_v[idx])||
		(!use_vec&&dirs_s.find(idx)==dirs_s.end())) {
	      count++;
	      if (use_vec)
		dirs_v[idx] = true;
	      else
		dirs_s.insert(idx);
	    }
	    if ((( use_vec&&!dirs_rest_v[idx])||
		 (!use_vec&&dirs_rest_s.find(idx)==dirs_rest_s.end()))
		&& (oldgt.empty() || oldgt[*it]==1)) {
	      count_rest++;
	      if (use_vec)
		dirs_rest_v[idx] = true;
	      else
		dirs_rest_s.insert(idx);
	    }

	    if (slaves_by_lists && (oldgt.empty() || oldgt[*it]==1)) {
	      size_t sidx = idx*objw+*it%objw;
	      perslaveandfeat[sidx][idxname].push_back(*it);
	      if (check_first_feature_only && m==0)  // obs! m==0 always here...
		for (size_t m1=1; m1<Nindices(); m1++) {
		  string idxname2 =
		    query->IndexData(NULL, m1).StaticPart()->IndexName();
		  perslaveandfeat[sidx][idxname2].push_back(*it);
		}
	    }
	  }
	
	WriteLog(msg+"  found "+ToStr(count)+" directories and "+
		 ToStr(count_rest)+" by restriction whose size is "+
		 ToStr(oldgt.positives())+"/"+ToStr(oldgt.size()));

	// Split the runs if there are more than one directory...
	if (!Picsom()->IsSlave()&&(free_slaves || count>=min_count_to_split)) {
	  // store old restriction, and then erase it from script
	  string oldrest;
	  if (i!=plist.end()) {
	    oldrest = i->second+"&";
	    plist.erase(i);
	  }

	  script_exp_t plistnew = plist;
	  if (!do_callback)
	    ScriptReplace(plistnew, "callback", "", false, false);

	  list<string> newscript = ScriptUnExpand(plistnew);
      
	  size_t tot_found = 0;
	  newscript.push_back("*LIST*");
	  slavescript = newscript;

	  vector<size_t> dirx;
	  if (use_vec)
	    for (size_t ii=0; ii<dirs_v.size(); ii++)
	      dirx.push_back(ii);
	  else
	    for (auto ii=dirs_s.begin(); ii!=dirs_s.end(); ii++)
	      dirx.push_back(*ii);

	  for (size_t iii=0; iii<dirx.size(); iii++) {
	    size_t ii = dirx[iii];

	    string labstr;
	    size_t npos = 0;

	    if (( use_vec && dirs_v[ii] && dirs_rest_v[ii])||
		(!use_vec && dirs_s.find(ii)!=dirs_s.end()
		 && dirs_rest_s.find(ii)!=dirs_rest_s.end())) {
	      char lab[100];
	      sprintf(lab,"%0*d", (int)dirl, (int)ii);
	      labstr = lab;
	      string restrtype(free_slaves ? "db" : "query");
	      restrtype += "restriction";

	      if (objw==1) {
		string restexp = oldrest+"$re(^"+labstr+")";
		string reststr = restrtype+"="+restexp;
		newscript.push_back("* "+reststr);
		tot_found++;

	      } else
		for (size_t oi=0; oi<objw; oi++) {
		  string restexp = oldrest+"$split($re(^"+labstr+"),image,"
		    +ToStr(objw)+","+ToStr(oi)+",H)";
		  string reststr = restrtype+"="+restexp;
		  newscript.push_back("* "+reststr);
		  tot_found++;
		  if (debug)
		    cout << "* "+reststr << endl;
		}
	    }

	    if (debug) {
	      bool dirs_b = (use_vec&&dirs_v[ii])||
		(!use_vec&&dirs_s.find(ii)!=dirs_s.end());
	      bool dirs_rest_b = (use_vec&&dirs_rest_v[ii])||
		(!use_vec&&dirs_rest_s.find(ii)!=dirs_rest_s.end());
	      cout << "  slavescript ii=" << ii
		   << " dirs[ii]=" << dirs_b
		   << " dirs_rest[ii]=" << dirs_rest_b
		   << " labstr=" << labstr << " npos=" << npos << endl;
	    }
	  }

	  WriteLog(msg+"  "+ToStr(tot_found)+" total slave tasks found");
      
	  if (!slaves_by_lists) {
	    vector<string> argv = DashedExtraArguments();
	    Analysis a(Picsom(), this, NULL, argv);
	    a.Script(newscript); 
	    a.Analyse();
	    was_split = true;
	  }
      
	} else {
	  // calculate missing
	  WriteLog("  Analysis::ExtractFeatures() : extracting "+
		   ToStr(dat_missing.size())+" missing "+idxname+
		   " feature vectors");

	  // NOTE: here we assume that all objects in dat_missing have
	  // the same directory. Do we really if we have featextbatchsize?
	  const string& lab = ts.Label(dat_missing.front());
	  vector<size_t> v = db->ObjectDirectoryComponents(lab);
	  string dir = db->LeafDirectory(v)+"/features";
	  string fn = ts.Name()+".dat";
	  string testname = db->FileIfOKgz(fn, dir);

	  //cout << "XXX " << dir << " xxx " << fn << " xxx "
	  //     << testname << " XXX" << endl;

	  if (!xml_result_initialized)
	    InitializeXmlResult(true);
	  xml_result_initialized = true;
	  XmlDom resfea = xml_result.Root().Element("featurevectorlist");

	  if (testname=="") {
	    bool r = ts.CalculateFeatures(dat_missing, segments, resfea, NULL);
	    n_missing += dat_missing.size();
	    ok = (r || !stop_on_error);

	  } else
	    for (vector<size_t>::iterator it=dat_missing.begin(); 
		 ok && it != dat_missing.end(); it++) {
	      vector<size_t> itvec(1, *it);
	      bool r = ts.CalculateFeatures(itvec, segments, resfea, NULL);
	      n_missing += r;
	      ok = (r || !stop_on_error);
	    }
	}
      }

      //     // calculate zeros
      //     if (!dat_zero.empty()) {
      //       WriteLog("Analysis::ExtractFeatures() : extracting zeroes.");
      //       for (vector<int>::iterator it=dat_zero.begin();
      //            ok && it!=dat_zero.end(); it++) {
      //         bool r = ts.ReadAndCalculateFeatures(*it, segments);
      //         n_zero += r;
      //         ok = (r || !stop_on_error);
      //       }
      //     }

      WriteLog("  " + idxname + "   fixed:   no data: "
	       + ToStr(n_missing) + "   zero data: " + ToStr(n_zero));

      n_missing_tot += n_missing;
      n_zero_tot    += n_zero;

      if ((n_missing || n_zero) && db->IsLocalDiskDb() &&
	  !Picsom()->IsSlave() && db->UseBinFeaturesWrite()) {
	vecidx->BinDataFlush();
	db->UploadBinFeatures(*vecidx);
      }

      if (was_split)
	break;

      if (check_first_feature_only)
	break;
    }
  
    WriteLog("  TOTAL   fixed:   no data: "
	       + ToStr(n_missing_tot) + "   zero data: " + ToStr(n_zero_tot));

    if (perslaveandfeat.size() && slavescript.size()) {
      size_t t = 0;

      for (auto i=perslaveandfeat.begin(); i!=perslaveandfeat.end(); i++) {
	string a;
	for (auto f=i->second.begin(); f!=i->second.end(); f++) {
	  const vector<int>& v = f->second;
	  for (auto j=v.begin(); j!=v.end(); j++)
	    a += (a==""?"":" ")+f->first+"/#"+ToStr(*j);

	  t += v.size();
	}

	slavescript.push_back("* args="+a);
      }

      slavescript.push_back("optimize_expand_line=false");

      WriteLog("Starting slaved feature extraction for "+ToStr(t)+
	       " feature vectors in "+ToStr(perslaveandfeat.size())+
	       " slave tasks");

      slave_features_missing += t;

      vector<string> argv = DashedExtraArguments();
      Analysis a(Picsom(), this, NULL, argv);
      a.Script(slavescript); 
      a.Analyse();

      slave_features_requested += a.slave_features_requested;
      slave_features_stored    += a.slave_features_stored;

      WriteLog("Slaved feature extraction for "+ToStr(slave_features_missing)
	       +" feature vectors requested "+ToStr(slave_features_requested)
	       +" and stored "+ToStr(slave_features_stored));
      if (slave_features_stored!=slave_features_missing)
	WriteLog("  "+ToStr(slave_features_missing-slave_features_requested)
		 +" were not requested, "
		 +ToStr(slave_features_requested-slave_features_stored)
		 +" requested were not stored, "
		 +ToStr(slave_features_missing-slave_features_stored)
		 +" were not stored in total");
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::CombineOrphans(Query&) {
    string msg = "Analysis::CombineOrphans() : ";
    bool debug = verbose>2;

    bool free_slaves = Picsom()->HasFreeSlaves();
    if (free_slaves) {
       WriteLog("Skipping combineorphans in slave master.");
       return true;
    }

    DataBase *db = CheckDB();
  
    ground_truth restr = QueryRestrictionGT(); // obs!

    for (size_t m=0; m<Nindices(); m++) {
      bool allow_empty = true;
      TSSOM& ts = TsSom(m);
      if (ts.FeatureTarget()==target_no_target)
	ts.FeatureTarget(query->Target());

      vector<size_t> dat_missing, dat_orphan, dat_zero, div_missing;
      int tot =  ts.CheckDataSet(restr, verbose-1, allow_empty, dat_missing,
				 dat_orphan, dat_zero, div_missing,
				 true, false);

      stringstream ssout;
      ssout << query->MapName(true, m) << "   total: " << tot
	    << "   no data: " << dat_missing.size() 
	    << "   orphans: " << dat_orphan.size() 
	    << "   zero data: " << dat_zero.size() 
	    << "   no div: " << div_missing.size();
      WriteLog(ssout.str());

      // db->FindAllIndices();

      // fix orphans
      if (!dat_orphan.empty()) {
	WriteLog(msg+"fixing orphans of "+query->MapName(true, m));

	set<string> least_auth_files;
	set<string> destination_is_new_file;

	for (vector<size_t>::iterator it=dat_orphan.begin(); 
	     it != dat_orphan.end(); it++) {
	  // get original data file
	  string datfile       = db->LeastAuthoritativeDataFile(*it, &ts);
	  string orphandatfile = db->MostAuthoritativeDataFile(*it, &ts);
	  if (datfile==orphandatfile) {
	    datfile = db->OrphanToLeafFileName(datfile);
	    destination_is_new_file.insert(datfile);
	  }

	  least_auth_files.insert(datfile);
	}
	WriteLog(msg+"  fixing orphans in "+ToStr(least_auth_files.size())+
		 " destination files");

	for (auto laf=least_auth_files.begin(); laf!=least_auth_files.end();
	     laf++) {
	  WriteLog(msg+"    now fixing orphans of "+query->MapName(true, m)
		   +" <"+db->ShortFileName(*laf)+">");

	  list<pair<string,size_t> > orphandatfiles;
	  FloatVectorSet orphandata_all;

	  for (vector<size_t>::iterator it=dat_orphan.begin(); 
	       it != dat_orphan.end(); it++) {

	    string datfilewas = db->LeastAuthoritativeDataFile(*it, &ts);
	    string datfile = datfilewas;
	    string orphandatfile = db->MostAuthoritativeDataFile(*it, &ts);
	    if (datfile==orphandatfile)
	      datfile = db->OrphanToLeafFileName(datfile);

	    bool laf_hit = datfile==*laf;

	    if (debug)
	      cout << " idx=" << *it << " label=" << db->Label(*it)
		   << " laf_hit=" << (laf_hit?1:0) << " *laf=" << *laf << endl
		   << "   orphandatfile=" << orphandatfile << endl
		   << "   datfilewas=" << datfilewas << endl
		   << "   datfile=" << datfile << endl;

	    if (!laf_hit)
	      continue;

	    FloatVectorSet orphandata;
	    orphandata.FileName(orphandatfile);

	    if (!orphandata.Read(orphandatfile) &&
		db->RemoveBrokenDataFiles()) {
	      WriteLog(msg+"reading <",orphandatfile, "> failed, moving away");
	      RenameToExt(orphandatfile,".broken");
	      db->AddCreatedFile(orphandatfile+".broken");
	      continue;
	    }
	    
	    WriteLog(msg+"      read "+ToStr(orphandata.Nitems())
		     +" vectors from <"+db->ShortFileName(orphandatfile)+">");

	    for (int odi=0; odi<orphandata.Nitems(); odi++)
	      for (int odj=0; odj<orphandata_all.Nitems(); odj++)
		if (orphandata[odi].LabelsMatch(orphandata_all[odj]))
		  return ShowError(msg+"duplicate labels <"+
				   orphandata[odi].Label()+">");

	    orphandatfiles.push_back(make_pair(orphandatfile,
					       orphandata.Nitems()));

	    orphandata_all.AppendCopy(orphandata);
	    if (debug)
	      cout << "  read " << orphandata.Nitems()
		   << " vectors, total now " << orphandata_all.Nitems()
		   << endl;
	  }

	  WriteLog(msg+"      read total of "+ToStr(orphandata_all.Nitems())
		   +" vectors from "+ToStr(orphandatfiles.size())
		   +" orphan files");

	  if (orphandatfiles.empty())
	    return ShowError(msg+"problem 0");

	  string first_orphandatfile = orphandatfiles.front().first;
	      
	  // get original data file
	  string datfile = *laf;
	  bool existed = false;
	  if (destination_is_new_file.count(datfile)) {
	    if (FileSize(datfile)>0)
	      return ShowError(msg+"problem 1: datfile="+datfile+
			       " first_orphandatfile="+first_orphandatfile+
			       " datfile.size()="+ToStr(FileSize(datfile)));
	  }
	  else if (FileSize(datfile)<1)
	    return ShowError(msg+"problem 2: datfile="+datfile+
			       " first_orphandatfile="+first_orphandatfile+
			       " datfile.size()="+ToStr(FileSize(datfile)));
	  else
	    existed = true;

	  FloatVectorSet data;
	  data.FileName(datfile);
	  if (existed)
	    data.Read(datfile);
	  else
	    data.Description(orphandata_all.Description());

	  for (int di=data.Nitems()-1; di>=0; di--) {
	    bool found = false;
	    for (int oi=orphandata_all.Nitems()-1; oi>=0 && !found; oi--)
	      if (data[di].LabelsMatch(orphandata_all[oi]))
		found = true;
          
	    if (found) {
	      WriteLog("    removed duplicate <"+data[di].LabelStr()+">");
	      data.Remove(di);
	    }
	  }

	  if (existed) {
	    if (RenameToOld(datfile))
	      db->AddCreatedFile(datfile+".old");

	    else if (!Unlink(datfile))
	      WarnOnce(msg+"Error: unable to rename or remove <"+datfile+">");
	  }

	  size_t dataitems = data.Nitems();

	  // append orphan to original data and write
	  data.AppendCopy(orphandata_all);
	  data.Precision(7);  // same as default in Feature.C
	  if (data.Write(datfile)) {
	    // move away orphan to .old
	    for (auto of=orphandatfiles.begin(); of!=orphandatfiles.end();
		 of++) {
	      if (RenameToOld(of->first))
		db->AddCreatedFile(of->first+".old");
            
	      size_t dataitems_was = dataitems;
	      dataitems += of->second;
	      stringstream ss;
	      ss << " " << dataitems_was << " + " << of->second
		 << " -> " << dataitems;

	      WriteLog(msg+"Added <"+db->ShortFileName(of->first)+"> to <"+ 
		       db->ShortFileName(datfile)+">", ss.str());
	    }
	  } else
	    WarnOnce(msg+"Error: unable to write <"+datfile+">");

	  if (dataitems!=(size_t)data.Nitems())
	    return ShowError(msg+"problem X: dataitems="+ToStr(dataitems)
			     +" data.Nitems()="+ToStr(data.Nitems()));
	}
      }

      stringstream ssout2;
      ssout2 << query->MapName(true, m) << "   fixed:"
	     << "   orphans: " << dat_orphan.size();
      WriteLog(ssout2.str());
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////
  
  bool Analysis::CombineOrphansOld(Query&) {
    string msg = "Analysis::CombineOrphansOld() : ";
    bool debug = verbose>2;

    bool free_slaves = Picsom()->HasFreeSlaves();
    if (free_slaves) {
       WriteLog("Skipping combineorphans in slave master.");
       return true;
    }

    DataBase *db = CheckDB();
  
    ground_truth restr = QueryRestrictionGT(); // obs!

    for (size_t m=0; m<Nindices(); m++) {
      bool allow_empty = true;
      TSSOM& ts = TsSom(m);
      if (ts.FeatureTarget()==target_no_target)
	ts.FeatureTarget(query->Target());

      vector<size_t> dat_missing, dat_orphan, dat_zero, div_missing;
      int tot =  ts.CheckDataSet(restr, verbose-1, allow_empty, dat_missing,
				 dat_orphan, dat_zero, div_missing,
				 true, false);

      stringstream ssout;
      ssout << query->MapName(true, m) << "   total: " << tot
	    << "   no data: " << dat_missing.size() 
	    << "   orphans: " << dat_orphan.size() 
	    << "   zero data: " << dat_zero.size() 
	    << "   no div: " << div_missing.size();
      WriteLog(ssout.str());

      // db->FindAllIndices();

      // fix orphans
      if (!dat_orphan.empty()) {
	WriteLog(msg+"fixing orphans of "+query->MapName(true, m));
	for (vector<size_t>::iterator it=dat_orphan.begin(); 
	     it != dat_orphan.end(); it++) {

	  if (debug)
	    cout << " idx=" << *it << " label=" << db->Label(*it) << endl;

	  // get orphan data
	  string orphandatfile = db->MostAuthoritativeDataFile(*it, &ts);
	  FloatVectorSet orphandata;
	  orphandata.FileName(orphandatfile);

	  if (!orphandata.Read(orphandatfile) && db->RemoveBrokenDataFiles()) {
	    WriteLog(msg+"reading <",orphandatfile 
		     , "> failed, moving away");
	    RenameToExt(orphandatfile,".broken");
	    db->AddCreatedFile(orphandatfile+".broken");
	    continue;
	  }

	  // get original data file
	  string datfile = db->LeastAuthoritativeDataFile(*it, &ts);
	  bool existed = false;
	  if (datfile==orphandatfile) {
	    datfile = db->OrphanToLeafFileName(orphandatfile);
	    if (FileSize(datfile)>0)
	      return ShowError(msg+"problem 1: datfile="+datfile+
			       " orphandatfile="+orphandatfile+
			       " datfile.size()="+ToStr(FileSize(datfile)));
	  }
	  else if (FileSize(datfile)<1)
	    return ShowError(msg+"problem 2: datfile="+datfile+
			       " orphandatfile="+orphandatfile+
			       " datfile.size()="+ToStr(FileSize(datfile)));
	  else
	    existed = true;

	  FloatVectorSet data;
	  data.FileName(datfile);
	  if (existed)
	    data.Read(datfile);
	  else
	    data.Description(orphandata.Description());

	  stringstream ss;
	  ss << " " << data.Nitems() << " + " << orphandata.Nitems();

	  for (int di=data.Nitems()-1; di>=0; di--) {
	    bool found = false;
	    for (int oi=orphandata.Nitems()-1; oi>=0 && !found; oi--)
	      if (data[di].LabelsMatch(orphandata[oi]))
		found = true;
          
	    if (found) {
	      WriteLog("    removed duplicate <"+data[di].LabelStr()+">");
	      data.Remove(di);
	    }
	  }

	  if (existed) {
	    if (RenameToOld(datfile))
	      db->AddCreatedFile(datfile+".old");

	    else if (!Unlink(datfile))
	      WarnOnce("Error: unable to rename or remove <"+datfile+">");
	  }

	  // append orphan to original data and write
	  data.AppendCopy(orphandata);
	  data.Precision(7);  // same as default in Feature.C
	  if (data.Write(datfile)) {

	    ss << " -> " << data.Nitems();

	    // move away orphan to .old
	    if (RenameToOld(orphandatfile))
	      db->AddCreatedFile(orphandatfile+".old");
            
	    WriteLog(msg+"Adding <", 
		     db->ShortFileName(orphandatfile)+"> to <"+ 
		     db->ShortFileName(datfile)+">", ss.str());
	  } else
	    WarnOnce("Error: unable to write <"+datfile+">");

	  for (int ix=0; ix<orphandata.Nitems(); ix++)
	    for (vector<size_t>::iterator iix=it+1; iix!=dat_orphan.end(); iix++)
	      if (db->Label(*iix)==orphandata[ix].Label()) {
		if (debug)
		  cout << " + idx=" << *iix << " label=" << db->Label(*iix)
		       << " (" << ix << "/" << orphandata.Nitems() << ")"
		       << endl;
		dat_orphan.erase(iix);
		break;
	      }
	}
      }

      stringstream ssout2;
      ssout2 << query->MapName(true, m) << "   fixed:"
	     << "   orphans: " << dat_orphan.size();
      WriteLog(ssout2.str());
    }

    return true;
  }

///////////////////////////////////////////////////////////////////////////////
  
bool Analysis::UpdateDiv(Query&) {
  const string msg = "Analysis::UpdateDiv() : ";
  bool ok = true;
  DataBase* db = CheckDB();
  ground_truth restr = db->RestrictionGT(); // obs!

  for (size_t m=0; ok && m<Nindices(); m++) {
    TSSOM& ts = TsSom(m);

    vector<size_t> dat_missing, dat_orphan, dat_zero, div_missing;
    int tot =  ts.CheckDataSet(restr, verbose-1, false, dat_missing, dat_orphan,
                               dat_zero, div_missing, false, false);

    *aout << query->MapName(true, m) << "   total: " << tot
          << "   no data: "   << dat_missing.size() 
//          << "   orphans: "   << dat_orphan.size() 
          << "   zero data: " << dat_zero.size() 
          << "   no div: "    << div_missing.size()
          << endl;

    if (!div_missing.empty()) {
      if (!ts.HasDiv()) {
        // If no explicit bmudivdepth has been set, construct default 
        if (!bmudivdepth.Length())
          for (size_t i=0; i<ts.Nlevels(); i++)
            bmudivdepth.Append(1);
        
        ts.BmuDepths(bmudivdepth);
        ts.CreateBackReferences();
        ts.InitializeDivision();
      }
    
      if (!metric.empty())
        ts.SetMetric(MakeMetric(ts.VectorLength()));

      WriteLog("Analysis::UpdateDiv() : matching features");

      FloatVectorSet data = ts.DataByIndices(div_missing,
					     tolerate_missing_features);

      for (size_t j=0; j<div_missing.size(); j++) {
        size_t ii = div_missing[j];
        const FloatVector *v = data.FindByNumber(ii);
        
        if (!v)
          return ShowError(msg, "failed to find vector for #"+ToStr(ii)+
                           Label(ii));
          
        if (!ts.MatchFeatures(*v))
          ok = false;
      }

      if (ok) {
        bool cwd = true;
        ok = ts.ReWriteDivisionFile(cwd, zipped);
        if (ok)
          WriteLog("Successfully divided and wrote "+ToStr(div_missing.size())+
                   " vectors of "+ts.Name());
      }
    }
  }
  
  return ok;
}

///////////////////////////////////////////////////////////////////////////////

bool Analysis::StripVectors(Query& my_query) {
  for (size_t m = 0; m<my_query.Nindices(); m++) {
    TreeSOM& ts = my_query.Map(m, 0);

    char newname[1000];
    strcpy(newname, my_query.TsSom(m).Name().c_str());
    strcat(newname, ".cod");
    ts.FileName(newname);

    cout << my_query.IndexFullName(m) << " -> " << ts.FileName() << endl;

    ts.Zipped(zipped);
    ts.WriteLabelsOnly(true);
    ts.Write();
  }
  return true;
}

///////////////////////////////////////////////////////////////////////////////

string Analysis::ExpandFileName(const string& x, const string& s,
                                const string& fn) const {
  string r = s;

  for (;;) {
    size_t p = r.find('%');
    if (p==string::npos)
      break;

    if (r.substr(p, 2)=="%f") {
      r.erase(p, 2);

      if (fn!="")
        r.insert(p, fn);

      else if (query) {
        string f;
        for (size_t i=0; i<Nindices(); i++)
          f += (f==""?"":"_")+IndexFullName(i);
        r.insert(p, f);
      }
      continue;
    }

    if (r.substr(p, 2)=="%r") {
      r.erase(p, 2);

      string restr = GetDataBase() ? GetDataBase()->RestrictionName() : "";

      if (restr!="")
        r.insert(p, restr);

      continue;
    }

    if (r.substr(p, 2)=="%l") {
      r.erase(p, 2);
      r.insert(p, loopid);

      continue;
    }

    ShowError("Analysis::ExpandFileName() : unable to expand [",
              r.substr(p, 2), "...] in ["+s+"]");

    r.erase(p, 2);
  }

  if (x=="matlab") {
    string t = Simple::MakeMatlabCompliant(r); 
    if (!MatlabNameOK(t))
      ShowError("Analysis::ExpandFileName() : produced incompliant name [",
                t, "]");
    return t;
  }

  return r;
}

///////////////////////////////////////////////////////////////////////////////

string Analysis::MatlabFileName(int feat, int lev,
                                        const string& xtra) const {
  string n(MatlabName());
  if (n.length())
    n += "_";

  if (DataBaseName()!=".")
    n += DataBaseName()+"_";

  n += IndexFullName(feat);

  if (lev!=-1) {
    char tmp[100];
    sprintf(tmp, "_%d", lev);
    n += tmp;
  }

  if (xtra.length())
    n += string("_")+xtra;

  string t = Simple::MakeMatlabCompliant(n);
  if (!MatlabNameOK(t))
    ShowError("Analysis::MatlabFileName() : produced incompliant name [",
              t, "]");

  return t;
}

/////////////////////////////////////////////////////////////////////////////

  bool Analysis::AddToXML(XmlDom& xml) const {
    XmlDom a = xml.Element("analysis");
    
    bool ok =  AddToXMLvariables(a);
    ok = ok && AddToXMLsearchtasks(a);
    ok = ok && AddToXMLxhtml(a);
    
    return ok;
  }

  ////////////////////////////////////////////////////////////////////////////

  bool Analysis::AddToXMLvariables(XmlDom& xml) const {
    XmlDom h = xml.Element("variables");
  
    h.Element("method",   method);
    h.Element("commands", commands_str);

    return true;
  }

  ////////////////////////////////////////////////////////////////////////////

  bool Analysis::AddToXMLsearchtasks(XmlDom& xml) const {
    if (searchtasks.empty())
      return true;

    bool ok = true;
    XmlDom a = xml.Element("searchtasks");
    a.Prop("name", topics);

    for (list<pair<string,string> >::const_iterator i=searchtasks.begin();
	 i!=searchtasks.end(); i++) {
      XmlDom n = a.Element("task", i->second);
      n.Prop("num", i->first);
      // if (n!=NULL)
      // 	SetProperty(n,"num",i->first);
      // else 
      // 	ok = false;
    }

    return ok;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AddToXMLxhtml(XmlDom& xml) const {
    if (!xhtml) {
      XmlDom h = xml.Element("xhtml");
      h.Element("b", "Analysis results not in XHTML format yet!!!");
      return true;
    }
    
    xmlNodePtr n = xmlCopyNode(xhtml, 1);
    if (!n)
      return false;
    
    return xmlAddChild(xml.node, n)!=NULL;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AddToXMLanalyse_result(XmlDom& xml,
					const analyse_result& res) const {
    return res.to_xml(xml, false);
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::AddToXMLxml_result(XmlDom& xml) const {
    if (xml_result.Root()) {
      XmlDom c = xml.CopyElement(xml_result.Root());
      XmlDom l = xml.LastElementChild();
      if (l)
	l.MoveAfter(c);
      else
	xmlAddChild(xml.node, c.node);
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  pair<float,float> Analysis::OptimizeValue(const analyse_result& r) {
    if (!r.ok() || r.empty()) {
      ShowError("Optimize variable not readable from result");
      return pair<float,float>(0.0, 0.0);
    }
    
    float mul = 1.0/r.rescount;
    if (optimize=="mir")
      return pair<float,float>(mul*r.mean_inv_rank, -mul*r.mean_inv_rank);
    
    if (optimize=="roc_eer")
      return pair<float,float>(mul*r.roc_eer, mul*r.roc_eer);
    
    if (optimize=="roc_auc")
      return pair<float,float>(mul*r.roc_auc, -mul*r.roc_auc);
    
    if (optimize.find("avgprec")==0) {
      double v = AveragePrecisionInferred() ? r.inferredap : r.avgprec;
      return pair<float,float>(mul*v, -mul*v);
    }
    
    if (optimize!="")
      ShowError("Optimize value <"+optimize+"> unknown");
    
    return pair<float,float>(0.0, 0.0);
  }
  
  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ReadResultTrecvid(const string& fname,
                                   const string& runlab, 
                                   const string& topicnum) {
    bool debug_stats=false;

    if (!FileExists(fname))
      return ShowError("Analysis::ReadResultTrecvid() : bad filename <",
                       fname, ">");
    
    textfile tf(fname);
    textlines_t tlines = tf.Data().get_lines_as_words();
    
    int topic_column = -1;
    bool found = false;
    for (textlines_t::iterator it=tlines.begin(); it!=tlines.end(); it++) {
      const vector<string>& words = *it;
      if (words.empty()) continue;
      if ((words[0] == "Topic" || words[0] == "Feature") 
          && words[1] == "number") {
        for (size_t i=2; i<words.size(); i++)
          if (words[i] == topicnum)
            topic_column = i-2;
      }
      if (((words[0].find("SOM-"+runlab,0) != string::npos) ||
           (words[0].find("SOM_"+runlab,0) != string::npos) ||
           (words[0].find(runlab,0) == 0 && runlab.length()>2))
          && topic_column != -1) {
        old_rank_value = atof(words[topic_column].c_str());
        found = true;
      }
    }    
    
    if (found) {
      if (debug_stats) 
        cout << "Analysis::ReadResultTrecvid() : Found old result value: " 
             << old_rank_value << endl;
    } else
      return ShowError("Analysis::ReadResultTrecvid() : could not find old "
                       "result with label "+runlab+", column="+
                       ToStr(topic_column)+"!");

    return true;
  }


  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ReadStatsTrecvid(const string& fname,
                                  const string& runlab, 
                                  const string& topicnum) {
    bool debug_stats=false;
    
    const string msg = "ReadStatsTrecvid() : ";

    if (!FileExists(fname))
      return ShowError(msg,"bad filename <", fname, ">");

    textfile tf(fname);
    textlines_t tlines = tf.Data().get_lines_as_words();
    
    bool found = false;
    char proc_type = runlab[0];
    if (isdigit(proc_type) || proc_type == 'A' || proc_type == 'B' 
        || proc_type == 'C') 
      proc_type = 'X';
    else if (proc_type != 'I' && proc_type != 'M' && proc_type != 'F')
      return ShowError(msg+"bad processing type: "+ proc_type,
                       ", only I, M or F allowed.");

    for (textlines_t::iterator it=tlines.begin(); it!=tlines.end(); it++) {
      const vector<string>& words = *it;
      if (words.size() < 2) continue;
      if ((words[0] == ToStr(proc_type) || words[0] == "X")
          && words[1] == topicnum) {
        for (size_t i=words.size()-1; i>=6; i--)
          rank_stats.insert((float)atof(words[i].c_str()));
        
        // remove our result... any result with the same value will do
        // as the list is ordered
        multiset<float>::iterator vpos = rank_stats.find(old_rank_value);
        if (vpos == rank_stats.end())
          return ShowError(msg,"Our result value not found in stats!");
        rank_stats.erase(vpos);

        if (debug_stats) {
          cout << msg << "Read stats: (";
          for (multiset<float>::iterator mit = rank_stats.begin(); 
               mit != rank_stats.end(); mit++) {
            char fstr[10];
            sprintf(fstr,"%0.3f",*mit);
            cout << (mit!=rank_stats.begin()?", ":"") << fstr;
          }
          cout << ")" << endl;
          
          cout << msg << "Old ranking: " << GetRanking(old_rank_value) << endl;
        }

        found = true;
      }
    }    
    if (!found)
      return ShowError(msg+"could not find stats");
    
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::CbirStagesEnded(const Query *q) {
    if (trecvid=="")
      return true;

    cout << endl << endl << endl
         << "Analysis::CbirStagesEnded() : "
         << " trecvid="          << trecvid
         << " trecvid_runid="    << trecvid_runid
         << " trecvid_priority=" << trecvid_priority
         << " query=" << query << " " << query->Identity() << "    q=";
    
    for (const Query *p=q ; p; p = p->Parent())
      cout << p << " " << p->Identity() << "    ";
    
    cout << endl << endl << endl;

    SetElapsedTime(query);

    string trecvid_was = trecvid;
    string ext = q->Identity();
    size_t e = ext.find('!');
    if (e!=string::npos)
      ext.erase(e);
    e = ext.rfind(':');
    if (e!=string::npos)
      ext.erase(0, e);
    trecvid += ext;

    string tnum = trecvid_was;
    e = tnum.find('0');
    if (e!=string::npos)
      tnum.erase(0, e);
    tnum = "tNum"+tnum;

    target_type tt = target_video;
    Query *tmp = query->DepthFirstRelevantObjects(tt);

    size_t nimg = 1000; // trecvid2005, trecvid2006

    const float min_val = 1.0;
    for (int k=tmp->NnewObjects()-1; k>=0; k--)
      if (tmp->NewObject(k).Value()<min_val)
        tmp->NewObject().erase(k);

    tmp->DumpNew();

    for (size_t k=0; k<q->NnewObjects() && tmp->NnewObjects()<nimg; k++) {
      const Object& obj = q->NewObject(k);
      if (PicSOM::TargetTypeContains(obj.TargetType(), tt)) {
        Object ooo(obj);
        ooo.SelectType(select_answer);
        ooo.Retained(true);
        tmp->AppendNewObject(ooo);
      }
    }

    // tmp->DumpNew();

    tmp->SetPositive(tnum);
    tmp->MaxQuestions(nimg);

    objectlist_t bestidxval; // obs! this is for faking *ResultsTrecvid()
    AnalyseBestResultsTrecvid(tmp, bestidxval);
    delete tmp;

    trecvid = trecvid_was;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  pair<string,string> Analysis::ElapsedTime(const timespec& a,
					    const timespec& b) {
    float diff = b.tv_sec-a.tv_sec+(b.tv_nsec-a.tv_nsec)/1000000000.0;

    stringstream ss;
    ss << diff/60;
    string et = ss.str();

    string info = TimeString(a, true)+" .. "+TimeString(b, true)
      +" = "+ToStr(diff)+" s = "+et+" min";

    return make_pair(et, info);
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::SetElapsedTime(const timespec& a, const timespec& b) {
    pair<string,string> t = ElapsedTime(a, b);
    elapsed_time = t.first;

    WriteLog("Elapsed "+t.second);

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::SetElapsedTime(const Query *q) {
    timespec now;
    Simple::SetTimeNow(now);
    const timespec& ref = q->StartTime();
    return SetElapsedTime(ref, now);
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::StoreMatrices(analyse_result& res) const {
    if (!StoreMatrices())
      return true;

    for (size_t i=0; i<Nindices(); i++)
      for (int j=0; j<query->NlevelsEvenAlien(i); j++) {
        if (level>=0) {
          if (!TsSom(i).LevelOKEvenAlien(level)&&j==0)
            return ShowError("StoreMatrices() : ", IndexFullName(i), "[",
                             ToStr(level), "] level inexistent");
          if (j!=level)
            continue;
        }
        size_t k=0;
        string mname = IndexFullName(i);
        const simple::FloatMatrix& cmat = Convolved(i, j, k);
        res.conv_matrix[mname] = cmat;
        WriteLog("Stored matrix ["+mname+"] of size "+ToStr(cmat.Rows())
                 +"x"+ToStr(cmat.Columns()));
      }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::InitializeXmlResult(bool warn) {
    string msg = "Analysis::InitializeXmlResult() : ";

    if (warn && HasXmlResult())
      ShowError(msg+"XML analysis result already exists");

    xml_result.DeleteDoc();
    pair<XmlDom,XmlDom> docroot = Connection::XMLdocroot("xmlresult", false);
    xml_result = docroot.first;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  XmlDom Analysis::SetXmlResultError(const string& msg) {
    InitializeXmlResult(false);

    return xml_result.Root().Element("error", msg);
  }

  /////////////////////////////////////////////////////////////////////////////

  XmlDom Analysis::SetXmlResultOK() {
    if (!xml_result.DocOK())
      InitializeXmlResult(false);
    
    if (xml_result.Root().FirstElementChild())
      return XmlDom();

    return xml_result.Root().Element("status", "OK");
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::CopyXmlResultTo(Analysis *a) const {
    if (xml_result.Root()) {
      if (!a->HasXmlResult())
	a->InitializeXmlResult(true);
      XmlDom e = xml_result.Root().FirstElementChild();
      while (e) {
	xmlAddChild(a->xml_result.Root().node, xmlCopyNode(e.node, 1));
	e = e.NextElement();
      }
    }
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ProcessObjectRequest(object_type ot, const string& oname,
                                      const string& ospecin, int& result) {
    string msg = "Analysis::ProcessObjectRequest("+ObjectType(ot)+") : ";
    cout << endl << msg << endl << endl;

    InitializeXmlResult(true);

    XmlDom root   = xml_result.Root();
    Connection *c = NULL;

    if (ot==ot_objectinfo && GetDataBase() && !GetDataBase()->IsLabel(oname)) {
      XmlDom ol = root.Element("objectlist");
      ground_truth gt = GetDataBase()->GroundTruthExpression(oname);
      for (size_t i=0; i<gt.size(); i++)
        if (gt[i]==1) {
          const string& lab = GetDataBase()->Label(i);
	  string ospec = ospecin;
	  if (ospec=="")
	    ospec = "nodbinfo";
          if (!GetDataBase()->AddToXML(ol, ot, lab, ospec, NULL, NULL))
            return ShowError(msg+"failed with <"+lab+">");
        }
      result = 1;
      return true;
    }

    if (Picsom()->AddObjectToXML(root, query, c, ot, oname, ospecin)) {
      result = 1;
      return true;
    }

    return ShowError(msg+"failed");
  }
  
  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::StoreErfRelevances(const Query *q) {
    bool debug = Query::DebugErfRelevance()>1;
    list<string> erf = q->ErfImageList();
    for (list<string>::const_iterator i=erf.begin(); i!=erf.end(); i++) {
      if (*i=="*collage*")
        continue;

      const Query::erf_image_data& e = q->ErfImageData(*i);
      for (map<string,float>::const_iterator r = e.relevance.begin();
           r!=e.relevance.end(); r++) {
        if (debug)
          cout << "ERF_REL " << *i << " [" << r->first << "] <" << e.label
	       << "> #" << e.index << " " << r->second << endl;
        erf_rel[r->first][e.index] = r->second;
        // cout << "erf_rel[" << r->first << "].size()="
        //      << erf_rel[r->first].size()
        //      << endl;
      }
    }

    return true;
  }
  
  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::ErfRelevancesToROC() {
    const ground_truth& corr = PositiveGT();
    if (corr.empty())
      return false;

    bool worstcase = false, debug = Query::DebugErfRelevance()>1;

    for (map<string,map<size_t,float> >::const_iterator i=erf_rel.begin();
         i!=erf_rel.end(); i++) {
      if (debug)
        cout << endl << i->first << endl;

      const float zeroplus = numeric_limits<float>::min();
      const float oneminus = 1.0-numeric_limits<float>::epsilon();

      multimap<float,size_t> r;
      for (map<size_t,float>::const_iterator j=i->second.begin();
           j!=i->second.end(); j++) {
        float v = j->second;
        if (v==1 && corr[j->first]==1 && worstcase)
          v = oneminus;
        if (v==0 && corr[j->first]!=1 && worstcase)
          v = zeroplus;
        r.insert(make_pair(v, j->first));
      }

      vector<float> hits(r.size());
      size_t l = 0;
      double csum = 0, dbsize = hits.size();
        
      for (multimap<float,size_t>::const_reverse_iterator k=r.rbegin();
           k!=r.rend(); k++) {
        bool is_corr = corr[k->second]==1;
        hits[l++] = is_corr;
        csum += is_corr;

        if (debug) {
          char tmp[100];
          if (k->first==0 || k->first==1)
            sprintf(tmp, "%u        ", (int)k->first);
          else if (k->first==zeroplus && worstcase)
            sprintf(tmp, "%-9s", "0+");
          else if (k->first==oneminus && worstcase)
            sprintf(tmp, "%-9s", "1-");
          else
            sprintf(tmp, "%09.7f", k->first);
          cout << "    " << tmp << " " << Label(k->second) << " " << is_corr
               << endl;
        }
      }
      if (debug)
        cout << endl;

      analyse_result res;
      res.set_roc_from_hits(hits, csum, dbsize, 0);
      res.rescount = 1;
      res.seen     = hits.size();
      res.found    = (int)floor(csum+0.5);
      res.set_roc_eer();
      res.set_roc_auc();

      string outname = resultname;
      outname += (outname==""?"":"-")+i->first+".xml";
      if (res.write(outname))
        WriteLog("Wrote ERF ROC in <"+outname+">");
      else
        ShowError("Failed to write in <"+outname+">");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  string Analysis::ground_truth_noise::str() const {
    string rfbnoise;
    if (gt_pn) rfbnoise += " pn:"+ToStr(gt_pn);
    if (gt_np) rfbnoise += " np:"+ToStr(gt_np);
    if (gt_p0) rfbnoise += " p0:"+ToStr(gt_p0);
    if (gt_0p) rfbnoise += " 0p:"+ToStr(gt_0p);
    if (gt_0n) rfbnoise += " 0n:"+ToStr(gt_0n);
    if (gt_n0) rfbnoise += " n0:"+ToStr(gt_n0);
    if (rfbnoise=="")
      rfbnoise = " none";

    return rfbnoise.substr(1);
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::SetNoiseValue(const string& sin, float v) {
    string s = sin, a;
    size_t p = s.find('.');
    if (p!=string::npos) {
      a = s.substr(p+1);
      s.erase(p);
    }
    
    ground_truth_noise& gtn = a=="gaze" ? gt_gaze_noise : gt_noise;

    if      (s=="pn") gtn.gt_pn = v;
    else if (s=="np") gtn.gt_np = v;
    else if (s=="p0") gtn.gt_p0 = v;
    else if (s=="0p") gtn.gt_0p = v;
    else if (s=="0n") gtn.gt_0n = v;
    else if (s=="n0") gtn.gt_n0 = v;
    else
      return ShowError("Analysis::SetNoiseValue(\""+sin+"\") failed");

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  bool Analysis::DoCallback(const string& f) {
    string msg = "Analysis::DoCallback("+f+") : ";

    vector<string> a;
    string m = f;
    size_t p = m.find('(');
    if (p!=string::npos) {
      string z = m.substr(p+1, m.size()-p-2);
      a = SplitInCommasObeyParentheses(z);
      m.erase(p);
    }

    if (m.find("restca")==0)
      return Connection::RestCaCallback(m.substr(6), this, a);

    return ShowError(msg+"failed");
  }

  /////////////////////////////////////////////////////////////////////////////

#if defined(HAVE_CAFFE_CAFFE_HPP) && defined(PICSOM_USE_CAFFE)
  Analysis::analyse_result Analysis::AnalyseCreateLevelDB(const
							  vector<string>&) {
    DataBase *db = CheckDB();
    
    ground_truth gt = QueryRestrictionGT();
    vector<size_t> vi = gt.indices(1);

    for (size_t j=0; j<Nindices(); j++) {
      FloatVectorSet vset = TsSom(j).DataByIndices(vi,
						   tolerate_missing_features);
      cout << "  " << IndexFullName(j) << " " << vset.Nitems() << " x "
	   << vset.VectorLength() << endl;

      db->CreateLevelDB("foo", IndexFullName(j), gt);
    }
   
    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result Analysis::AnalyseCaffeTest(const vector<string>&
						      args) {
    string msg = "Analysis::AnalyseCaffeTest() : ";

    if (detections.size()!=1)
      return ShowError(msg+"detections.size()!=1");

    DataBase *db = CheckDB();
    
    list<imagedata> imgl;

    size_t nimg = 1;

    Tic("AnalyseCaffeTest");
    for (size_t i=0; i<args.size(); i++) {
      if (i==0 && args[i][0]=='-') {
	nimg = atoi(args[i].substr(1).c_str());
	continue;
      }

      imagefile img(args[i]);
      imgl.push_back(img.frame(0));
      if (imgl.size()==nimg || i==args.size()-1) {
	list<vector<float> > r = db->RunCaffe(db, detections[0], imgl);
	cout << TimeStamp() << "RunCaffe() returned " << r.size() << " x "
	     << (r.size()?r.begin()->size():0) << " dimensional results"
	     << endl;
	imgl.clear();
      }
    }
    Tac("AnalyseCaffeTest");

    return true;
  }
#endif // HAVE_CAFFE_CAFFE_HPP && PICSOM_USE_CAFFE

  /////////////////////////////////////////////////////////////////////////////

#if defined(HAVE_CAFFE2_CORE_MACROS_H) && defined(PICSOM_USE_CAFFE2)
  Analysis::analyse_result Analysis::AnalyseCaffe2Test(const vector<string>&
						       /*args*/) {
    string msg = "Analysis::AnalyseCaffe2Test() : ";
    WriteLog(msg+"starting");

    // https://github.com/leonardvandriel/caffe2_cpp_tutorial/blob/master/src/caffe2/binaries/pretrained.cc

    using namespace caffe2;
    Workspace wsp("test");
    std::vector<TIndex> dims({1, 3, 400, 640});
    std::vector<float> data(3*400*640);
    TensorCPU tensor(dims, data, NULL);
    NetDef init_net, predict_net;

    CAFFE_ENFORCE(ReadProtoFromFile(FLAGS_init_net, &init_net));

    CAFFE_ENFORCE(ReadProtoFromFile(FLAGS_predict_net, &predict_net));

    Workspace workspace("tmp");
    CAFFE_ENFORCE(workspace.RunNetOnce(init_net));
    auto input = workspace.CreateBlob("data")->GetMutable<TensorCPU>();
    input->ResizeLike(tensor);
    input->ShareData(tensor);
    CAFFE_ENFORCE(workspace.RunNetOnce(predict_net));
    
    auto output = workspace.GetBlob("softmaxout")->Get<TensorCPU>();

    WriteLog(msg+"ending");

    return true;
  }
#endif // HAVE_CAFFE2_CORE_MACROS_H && PICSOM_USE_CAFFE2

  /////////////////////////////////////////////////////////////////////////////

#if defined(HAVE_THC_H) && defined(PICSOM_USE_TORCH)

  // env LD_LIBRARY_PATH=/share/apps/easybuild/software/Qt/4.8.7-GCC-5.3.0/lib qlua
  // > require 'torch'; require 'image'; require 'qttorch'
  // > t = torch.FloatTensor(3,256,256)
  // > image.display(t)

  Analysis::analyse_result Analysis::AnalyseTorchTest(const vector<string>&) {
    string msg = "Analysis::AnalyseTorchTest() : ";
    list<imagedata> imgl;
    //size_t nimg = 1;
    //Tic("AnalyseTorchTest");
    //DataBase *db = CheckDB();
    //Tac("AnalyseTorchTest");

    lua_State *L = lua_open();
    luaL_openlibs(L);

    list<string> require      { "torch", "paths", "xlua", "optim", "nn"
	// , "image", "qttorch"
	};
    list<string> require_cuda { "cutorch", "cudnn", "cunn" };
    // migh also require "image" but ... 
    // module 'qt' not found:No LuaRocks module found for qt

    for (auto i=require.begin(); i!=require.end(); i++) {
      string s = "require '"+*i+"'";
      if (luaL_dostring(L, s.c_str()))
	return ShowError(msg+"luaL_dostring() failed : <"+s+">");
    }

    if (Picsom()->GpuDeviceId()>-1)
      for (auto i=require_cuda.begin(); i!=require_cuda.end(); i++) {
	string s = "require '"+*i+"'";
	if (luaL_dostring(L, s.c_str()))
	  return ShowError(msg+"luaL_dostring() failed : <"+s+">");
      }

    picsom::imagedata img = picsom::imagefile("girl.jpg").frame(0);
    cout << img.info() << endl; 
    picsom::scalinginfo si(img.width(), img.height(), 256, 256);
    img.rescale(si, 1);
    cout << img.info() << endl; 
    
    vector<size_t> vsize, vstride;
    vector<float> vx = img.get_ordered_float("cyx", vsize, vstride);

    THFloatStorage *s = THFloatStorage_newWithData(vx.data(), vx.size());
    THFloatTensor *t = THFloatTensor_newWithStorage3d(s, 0, vsize[0], vstride[0],
						      vsize[1], vstride[1],
						      vsize[2], vstride[2]);

    luaT_pushudata(L, t, "torch.FloatTensor");
    lua_setglobal(L, "t");
    //luaL_dostring(L, "image.display(t)"); for(;;);
    //luaL_dostring(L, "print(t)");

    if (luaL_dostring(L, "model = torch.load('/scratch/cs/imagedb/picsom/databases/torch/"
		      "torch/models/alexnet_BWN/alexnet_BWN.t7')"))
      return ShowError(msg+"luaL_dostring() failed C");

    // if (luaL_dostring(L, "print(model)"))
    //   return ShowError(msg+"luaL_dostring() failed D");

    luaL_dostring(L, "ct = t:cuda()");
    luaL_dostring(L, "print(ct)");
    luaL_dostring(L, "ct = t:cuda()");
    //luaL_dostring(L, "print(ct)");

    luaL_dostring(L, "co = model:forward(ct)");
    luaL_dostring(L, "cutorch.synchronize()");
    luaL_dostring(L, "o = co:float()");
    luaL_dostring(L, "print(o)");

    lua_getglobal(L, "o");
    void *p = luaT_checkudata(L, -1, "torch.FloatTensor");
    cout << p << endl;
    THFloatTensor *o = (THFloatTensor*)p;
    THFloatStorage *v = THFloatTensor_storage(o);
    size_t vo = THFloatTensor_storageOffset(o);
    size_t vd = THFloatTensor_nDimension(o);
    cout << v << " " << vo << " " << vd << endl;
    for (size_t i=0; i<vd; i++)
      cout << " " << i << " " << THFloatTensor_size(o, i)
	   << " " << THFloatTensor_stride(o, i) << endl;

    float *d = THFloatStorage_data(v)+THFloatTensor_storageOffset(o);
    vector<double> esum(THFloatTensor_size(o, 0));
    for (size_t i=0; i<(size_t)THFloatTensor_size(o, 1); i++) {
      cout << i;
      for (size_t j=0; j<(size_t)THFloatTensor_size(o, 0); j++) {
	size_t ij = j*THFloatTensor_stride(o, 0)+i*THFloatTensor_stride(o, 1);
	cout << " " << ij << "/" << d[ij];
	esum[j] += exp(d[ij]);
      }
      cout << endl;
    }
    cout << "***";
    for (size_t j=0; j<(size_t)THFloatTensor_size(o, 0); j++)
      cout << " " << esum[j];
    cout << endl;

    lua_close(L);

    // THCState *state = THCState_alloc();
    // THCudaInit(state);
    // cout << "THCState_getNumDevices() = " << THCState_getNumDevices(state) << endl;
    // cout << "THCState_getNumStreams() = " << THCState_getNumStreams(state) << endl;

    // THFile *file = THDiskFile_new("test.t7", "r", 0);
    // cout << "THDiskFile_name() = " << THDiskFile_name(file) << endl;

    return true;
  }
#endif // HAVE_THC_H && PICSOM_USE_TORCH

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseUpdateObjectInfo(const vector<string>& argv) {
    string msg = "Analysis::AnalyseUpdateObjectInfo() : ";

    DataBase *db = CheckDB();
    ground_truth gt(db->Size());
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }

    vector<size_t> vidx = gt.indices(1);

    if (Picsom()->HasSlaves() && vidx.size()>1) {
      list<analyse_result> ar = SplitSlavesAndAnalyse(vidx, script, 
						      "updateobjectinfo");
      WriteLog("Updated "+ToStr(vidx.size())+" objectinfos in slaves");
      return true;
    }

    for (auto vi=vidx.begin(); vi!=vidx.end(); vi++) {
      size_t idx = *vi;

      if (!db->ObjectsTargetTypeContains(idx, Target()))
	continue;
      
      // object_info *oi = db->FindObject(idx);
      map<string,string> m = db->ReadOriginsInfo(idx, false, true);
      // for (auto i : m)
      // 	cout << i.first << "=" << i.second << endl;

      string fname = db->ObjectPathEvenExtract(idx);

      string datain, date;
      target_type tt = db->ObjectsTargetType(idx);
      int nframes = 0;
      float framerate = 0;

      if (!HasXmlResult())
	InitializeXmlResult(true);
      XmlDom oihl = xml_result.Root().Element("objectinfohashlist");

      if (!db->InsertOriginsInfo(idx, true, fname, m["filename"], m["format"], 
				 m["url"], m["page"], datain, m, m["date"], 
				 tt, nframes, framerate, oihl))
	ShowError(msg+"InsertOriginsInfo() failed");
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseUpdateVideoInfo(const vector<string>& argv) {
    string msg = "Analysis::AnalyseUpdateVideoInfo() : ";

    DataBase *db = CheckDB();
    ground_truth gt(db->Size());
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_video,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }

    if (!db->SqlExec("PRAGMA synchronous=OFF;", true))
      return ShowError(msg+"'PRAGMA synchronous=OFF' failed");

    if (!db->SqlExec("PRAGMA journal_mode=OFF;", true))
      return ShowError(msg+"'PRAGMA journal_mode=OFF' failed");

    vector<size_t> vidx = gt.indices(1);
    for (auto vi=vidx.begin(); vi!=vidx.end(); vi++) {
      size_t idx = *vi;
      const string& label = db->Label(idx);
      WriteLog(msg+"STARTING "+label);

      //string f = db->SolveObjectPath(label);
      string f = db->ObjectPathEvenExtract(idx);
      videofile vf(f);
      size_t w = vf.get_width();
      size_t h = vf.get_height();
      double r = vf.get_frame_rate();

      vector<pair<size_t,size_t> > v = db->VideoOrSegmentFramesOrdered(idx);
      size_t n = v.size();
      if (n==0)
	n = (size_t)floor(0.5+vf.get_length()*r);

      vector<string> a {
	label,
	  "width="+ToStr(w),
	  "height="+ToStr(h),
	  "frames="+ToStr(n),
	  "framerate="+ToStr(r)//,
	  //"dimensions='"+ToStr(w)+"x"+ToStr(h)+"x"+ToStr(n)+"@"+ToStr(r)+"'"
	  };
      cout << JoinWithString(a, " ") << " " << f << endl;
      SqlUpdateOneSet(a);

      if (false)
	for (size_t i=0; i<v.size(); i++) {
	  vector<string> a {
	    db->Label(v[i].first),
	      "width="+ToStr(w),
	      "height="+ToStr(h),
	      "frames=1"//,
	      //"dimensions='"+ToStr(w)+"x"+ToStr(h)+"'"
	      };
	  cout << JoinWithString(a, " ") << endl;
	  SqlUpdateOneSet(a);
	}
    }

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  Analysis::analyse_result
  Analysis::AnalyseUpdateImageInfo(const vector<string>& argv) {
    string msg = "Analysis::AnalyseUpdateImageInfo() : ";

    DataBase *db = CheckDB();
    ground_truth gt(db->Size());
    for (auto a=argv.begin(); a!=argv.end(); a++) {
      ground_truth gta = db->GroundTruthExpression(*a, target_image,
						   -1, false);
      gt = gt.TernaryOR(gta);
    }

    // if (!db->SqlExec("PRAGMA synchronous=OFF;", true))
    //   return ShowError(msg+"'PRAGMA synchronous=OFF' failed");

    // if (!db->SqlExec("PRAGMA journal_mode=OFF;", true))
    //   return ShowError(msg+"'PRAGMA journal_mode=OFF' failed");

    db->SqlBeginTransaction();

    vector<size_t> vidx = gt.indices(1);
    for (auto vi=vidx.begin(); vi!=vidx.end(); vi++) {
      size_t idx = *vi;
      const string& label = db->Label(idx);
      WriteLog(msg+"STARTING "+label);

      string f = db->ObjectPathEvenExtract(idx), format;
      imagedata idata = db->ImageData(idx, false, &format);
      bool is_image = format.find("image/")==0;
      size_t w = idata.width();
      size_t h = idata.height();
      size_t n = is_image ? 1 : 0; // obs! might be >1 also !

      vector<string> a {
	label,
	  "type="+TargetTypeString(is_image?target_image:target_no_target),
	  "format="+format,
	  "width=" +ToStr(w),
	  "height="+ToStr(h),
	  "frames="+ToStr(n),
	  "bytes=" +ToStr(FileSize(f))
	  // "md5" could be calculated also, see
	  // DataBase::SolveMissingOriginsInfo() which should be Util.C...
	  };
      WriteLog(JoinWithString(a, " ")+" #"+ToStr(idx));
      SqlUpdateOneSet(a);
    }

    db->SqlEndTransaction();

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////

  // bool Analysis::() const {
  //   return true;
  // }

} // namespace picsom

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

